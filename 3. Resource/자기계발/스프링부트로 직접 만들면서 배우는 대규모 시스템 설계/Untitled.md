

**Monolithic Architecture**
- 모든 기능이 단일 코드베이스로 결합된 아키텍처
- 소규모 시스템에서 개발 및 배포가 간단하기 때문에 많이 선택
	- 빠르고 효율적으로 개발할 수 있음
- 하지만
	- 특정 부분만 확장하기 어려움
	- 변경사항이 시스템 전체에 영향을 미침
	- 대규모 시스템에서 복잡도가 커지고 개발이 어려움 
- 이러한 문제를 해결하기 위해 Microservice Architecture를 살펴봄


**Microservice Architecture**
- 시스템이 작고 독립적인 서비스(Microservice)로 구성 
- 각 서비스는 단일 기능을 담당하며, 독립적 배포 가능
	- 우리의 시스템에서는 
		- 게시글, 댓글, 좋아요, 조회수, 인기글, 게시글 조회 
		- 각 요구사항(기능)을 독립된 마이크로 서비스로 볼 수도 있다
- 서비스 단위로 유연한 확장 가능
- 하지만 
	- 서비스 간 복잡한 통신 및 모니터링 필요
	- 데이터 일관성 및 트랜잭션 관리의 어려움
	- 어려운 개발 난이도


|              | 모놀리틱       | MSA             |
| ------------ | ---------- | --------------- |
| **구조**       | 통합         | 분산              |
| **결합도**      | 높음         | 낮음              |
| **확장성**      | 개별 확장 어려움  | 개별 확장 쉬움        |
| **배포**       | 통합 배포      | 독립 배포           |
| **기술 스택**    | 단일 기술 스택   | 여러 기술 스택 가능     |
| **변경 전파 범위** | 시스템 전체     | 서비스 또는 전파 범위 이내 |
| **통신 비용**    | 낮음         | 높음              |
| **개발 난이도**   | 쉬움(소규모일수록) | 어려움             |

> [!note] MSA는 서비스간 통신 비용, 트랜잭션 관리, 서비스 분리 기준, 모니터링, 개발 비용, 테스트, 설계 등 고려해야 할 부분이 엄청 많다


**Docker**
- 애플리케이션을 컨테이너라는 격리된 환경에서 실행할 수 있게 해주는 플랫폼
	- 쉽게 배포하고 관리할 수 있음 
	- 환경에 구애 받지 않음

**프로젝트 구조**
```text
board 
	- service: 하위 모듈로 각 마이크로서비스를 가짐
		- article: 게시글 서비스
		- comment: 댓글 서비스
		- like: 좋아요 서비스
		- view: 조회수 서비스
		- hot-article: 인기글 서비스
		- article-read: 게시글 조회 서비스
	- common: 하위 모듈로 개발 편의를 위한 공통 코드를 관리
```


**프로젝트 생성**
- 스프링부트 - 멀티 모듈 프로젝트 

|              | 포트   |
| ------------ | ---- |
| article      | 9000 |
| comment      | 9001 |
| like         | 9002 |
| view         | 9003 |
| hot article  | 9004 |
| article read | 9005 |
| article read | 9006 |

```shell
$ sdk use java 21.0.3-ms

$ spring shell

$ init --list 

$ init -a board -g com.example -n board --package-name com.example.board -p jar -j 21 -b 3.3.2 -x board -d lombok,web
```
-x : jdbc 폴더에 프로젝트 생성
-d : dependency, **spring shell**에서  **init --list** 통해서 supported dependencies 확인 

---
## 섹션2. 게시글
### Distributed Relational Database
- **샤딩(Sharding)**: 데이터를 여러 DB에 분산하여 저장하는 기술
	- 수직 샤딩(Vertical Sharding): 
		- 데이터를 수직으로 분할하는 방식(**컬럼 단위**)
		- 각 샤드별로 테이블에 기본키가 존재하고 컬럼을 나눠서 관리
		- 각 샤드가 적은 수의 컬럼을 저장하므로, 성능 및 공간 이점이 생긴다
		- 하지만, <u>데이터 분리로 인해 조인 또는 트랜잭션 관리가 복잡</u>해질 수 있다
		- 그리고 <u>수직으로 분할되므로 수평적 확장에 제한</u>이 있다
	- 수평 샤딩(Horizontal Sharding)
		- 데이터를 수평으로 분할하는 방식(**행 단위**)
		- 예로 두 샤드가 있을 때 `id = 1 ~ 5000`, `id = 5001 ~ 10000` 각각 관리
		- 각 샤드에 데이터가 분산되므로 성능 및 공간 이점이 생긴다
		- 하지만 데이터의 분리로 인해 조인 또는 트랜잭션 관리가 복잡해질 수 있다.
		- 수평으로 분할되므로 수평적 확장에 용이하다.
- **샤드(Shard)**: 샤딩된 각각의 데이터 단위


|         | 수직샤딩                           | 수평 샤딩         |
| ------- | ------------------------------ | ------------- |
| **샤딩**  | 수직으로 분할(컬럼 단위)                 | 수평으로 분할(행 단위) |
| **확장성** | 제한                             | 용이            |
| **장점**  | 각 샤드로 데이터 분산되므로 성능 및 공간 이점(공통) | -             |
| **단점**  | 조인 또는 트랜잭션 고나리 등의 어려움(공통)      | -             |

**기법** 
- Range-based Sharding:
	- 데이터 쏠림 현상 발생 가능
- Hash-based Sharding(해시 기반 샤딩)
	- 균등한 분산을 위한 shard key와 해시 함수가 필요하다
	- 범위 데이터 조회에 불리할 수 있다.
- Directory-based Sharding(디렉토리 기반 샤딩)
	- 디렉토리 관리 비용이 있지만, 데이터 규모에 따라 유연한 관리가 가능

**물리적 샤드**
- 샤드 개수가 늘어나면 해시 함수 통해 재배치 발생

**논리적 샤드**
- 물리적 샤드가 2개이지만 가상의 샤드 4개가 있을 수 있다
- client는 router를 통해 4개 논리적 샤드에 요청이 가게 된다


|         | 물리적 샤드                | 논리적 샤드                                 |
| ------- | --------------------- | -------------------------------------- |
| **정의**  | 데이터를 물리적으로 분산한 실제 단위  | 데이터를 논리적으로 분산한 가상의 단위                  |
| **필요성** | 대규모 데이터 분산 저장 및 성능 향상 | 물리적 확장시, client 변경없이 유연한 매핑(router 위임) |

>[!note] 고가용성을 확보하기 위한 복제 
>primary/replica, leader/follower, master/slave, main/standby 등 유사한 개념이지만, 시스템이나 목적에 따라 다르게 사용되기도 한다.

이러한 복제는 동기적, 비동기적으로 처리 될 수 있다.
- 동기적(Synchronous): 데이터 일관성을 보장하나, 쓰기 성능 저하된다
- 비동기적(Asynchronous): 쓰기 성능 유지되나, 복제본에 최신 데이터가 즉시 반영되지 않을 수 있다.


**Primary Key 선택**
- 오름차순 유니크 숫자를 만들기 위한 알고리즘으로 Snowflake 선택
	- 그외 TSID 등이 있다
- Snowflake
	- X(전 트위터)에서 개발 
	- 분산 시스템에서 고유한 64비트 ID를 생성하는 알고리즘
		- `[1비트][41비트: 타임스탬프][10비트: 노드 ID][12비트: 시퀀스 번호]`
		• 분산 환경에서도 중복 없이 순차적 ID 생성하기 위한 규칙
			• 타임스탬프 : 순차성
			• 노드ID + 시퀀스 번호 : 고유성
	• 유니크, 시간 기반 순차성, 분산 환경에서의 높은 성능