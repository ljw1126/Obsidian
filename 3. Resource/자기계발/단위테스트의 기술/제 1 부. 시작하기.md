## 1장. 단위 테스트의 기초

**예제 자료**  
https://github.com/gilbutITbook/080410/tree/master

**마틴 파울러 블로그**
https://martinfowler.com/

**xunitpatterns**
http://xunitpatterns.com/index.html

### 1.2 단위 테스트의 정의

>[!info] 1.9절에서 단위 테스트의 최종 정의를 완성 시킨다 


>[!note] 위키백과
>단위 테스트는(unit test)는 컴퓨터 프로그래밍에서 예저 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차다. 즉, 모든 함수와 메서드에 대한 테스트 케이스(test case)를 작성하는 절차를 말한다. 이를 통해서 언제라도 코드 변경으로 인해 문제가 발생할 경우, 단시간 내에 이를 파악하고 바로 잡을 수 있도록 해준다. 이상적으로, 각 테스트 케이스는 서로 분리되어야 한다. 


**테스트를 작성할 대상**
- 주제(subject)
- 시스템(system)
- 테스트 대상 (Suite Under Test, SUT)


>[!note] SUT 정의
>SUT는 테스트 중인 주제, 시스템, 테스트의 모음(suite)을 의미하며, 일부 사람들은 테스트 중인 컴포넌트(component), 클래스(class), 코드(code)를 의미하는 CUT(Component, class, code Under Test)라는 용어를 사용하기도 한다. 무언가를 테스트할 때, 테스트하고자 하는 주요 대상을 SUT라고 한다


**작업 단위**
- 진입점의 호출부터 하나 이상의 종료점까지, 눈에 띄는 결과가 나타날 떄까지 발생하는 모든 작업을 의미한다
- 어떤 동작을 하는 **함수**가 있을 때
	- body : 작업 단위 전체나 일부를 의미
	- 입력 : 선언과 서명은 body로의 진입점
	- 출력 : 실행 결과, 함수의 종료점


65-66 진입점과 종료점
72-73 코드의 설계 방향
76-78 서드파티 호출, 의존성 정의

>[!tip] (한 함수에) 종료점이 여러 개인 경우 종료점마다 테스트를 만들어 분리하면 각 테스트끼리 영향을 주지 않고, 더 읽기 쉬우며, 디버깅하기도 쉽다

p80
**단위 테스트**는 작업 단위를 호출하고, 그 작업 단위의 최종 결과로서 하나의 특정 종료점을 테스트 검증 목표로 사용한다. 최종 결과가 테스트가 검증하고자하는 바와 다르면 단위 테스트는 실패한다. 단위 테스트 범위는 진입점과 종료점 사이

### 1.5 다른 종료점, 다른 기법
p83
서드 파티를 호출하는 종료점이 가장 다루기 꺼림
mock을 사용해야 하고

p94
**helper** 메서드
테스트 프레임워크 없이 테스트 작성 예제
Node.js assert : https://nodejs.org/api/assert.html


### 1.7 좋은 단위 테스트의 특징

테스트를 포기하게 되는 이유 (경험단)


#### 1.7.1 좋은 단위 테스트란
- 테스트 작성자 의도를 이해하기 쉬워야 한다
- 읽고 쓰기 쉬워야 한다
- 테스트를 자동화할 수 있어야 한다
- 같은 조건에서 실행 결과는 항상 같아야 한다
- 의미 있는 테스트여아 하고, 구체적인 결과를 제공하여 문제를 쉽게 파악하고 해결할 수 있어야 한다
- 누구나 쉽게 실행할 수 있어야 한다
- 실패할 경우 무엇이 잘못되었는지 쉽게 알 수 있어야 한다

**좋은 단위 테스트의 특징**
- 빠르게 실행되어야 한다
- 테스트 환경을 일관되게 유지하고, 테스트 결과가 항상 예측 가능해야 한다
- 다른 테스트와 완전히 독립적으로 실행되어 한다
- 시스템 파일, 네트워크, 데이터베이스가 없어도 메모리 내에서 실행되어야 한다
- 가능한 동기적인 흐름으로 실행되어야 한다(가능하다면 병렬 스레드 사용x)

>[!note] p97
>모든 테스트가 좋은 단위 테스트의 특성을 전부 만족하는 것은 사실 불가능에 가깝다.
>그렇기에 항상 모든 조건을 만족할 필요는 없다.
>단위 테스트 조건을 만족하기 까다로운 테스트는 적당한 리팩토링을 거쳐 보다 많은 조건을 충족하도록 만들 수도 있지만, 통합 테스트로 만드는 것도 하나의 방법이다


**데이터베이스나 다른 의존성을 스텁으로 대체하기**
- **Stub** : 간단히 말해 실제 의존성을 흉내내는 가짜 의존성
- 실제 의존성에 접근하지 않고도 테스트를 수행할 수 있어 테스트가 더 예측 가능하고 안정적으로 진행된다

//데이터베이스, dom 관련 
### 1.8 통합 테스트
p103 

단위 테스트 빨라야 한다

p105
개발자 대부분은 앱의 전체 기능, REST API의 응답 결과, UI의 동작을 통해 기능을 테스트한다.
이는 단일 기능이나 모듈이 아니라 여러 구성 요소가 함께 작동하여 최종 결과를 만들어 내는 방식을 테스트하는 것이다. (..) 테스트가 실패하면 이 소프트웨어 구성 요소 모두가 다 같이 실패하여 전체 작업의 실패 원인을 파악하기가 어려울 수 있다

>[!note] 그림1-7. 통합 테스트는 하나라도 실패하면 제대로 된 결과를 얻을 수 없다. 여러 기능이 연쇄적으로 적용하기 때문에 버그 원인을 찾는 것도 쉽지 않다.


>[!summary]
>통합 테스트는 다른 팀이 만든 모듈, 외부 API나 서비스, 네트워크, 데이터베이스, 스레드 등 실제 의존성을 완전히 제어할 수 없는 상태에서 작업 단위를 테스트하는 것이다.

- 통합 테스트는 실제 의존성을 사용
- 단위 테스트는 작업 단위를 의존성에 격리시켜 항상 일관된 결과를 받을 수 있도록 하여 작업 단위의 모든 측면을 쉽게 조작할 수 있게 한다.


p107
코드를 변경한 후 이전에 잘 돌아가던 테스트를 실행할 수 없게 되면 코드에 버그가 생겨도 알아차리지 못할 수 있다. 이를 **회귀**(regression)라고 한다

>[!note] 회귀 정의
>회귀는 이전에 동작하던 기능이 지금은 동작하지 않는 것이다. 즉, 한때 작동하던 하나 이상의 작업 단위가 이제는 작동하지 않는 것을 의미한다.


p108 **(개인적으로 좋은 부분)**
 다른 사람의 코드를 변경할 때 당연히 문제가 발생하지 않길 원할 것이다. 많은 개발자가 오래된 레거시(legacy) 코드를 수정하는 것에 부담감을 느끼는 이뉴는 코드를 바꾸면 다른 코드에 어떤
형태로 영향을 주는지 분명히 알 수 없기 때문이다. 코드 안정성을 보장할 수 없는 상태로 바꿀 가능성이 있기 때문이다.

(..)
단위 테스트에서 쌓아 올린 신뢰도는 하나의 울타리가 되어 낯선 코드와 마주칠 때 두려움을 덜어 줄것이다. 좋은 테스트는 누구나 제한 없이 실행할 수 있어야 한다

p108 레거시 코드 정의 - **'테스트가 없는 코드'**

>[!note] 체크 리스트
>- 2주, 2개월, 2년 전에 만든 테스트가 여전히 잘 돌아가는가?
>- 내가 2개월 전에 작성한 테스트를 팀 내 다른 동료가 실행했을 때 문제 없이 결과를 받을 수 있는가 
>- 내가 만든 테스트가 수분 내로 전부 실행되는가?
>- 버튼 하나만 눌러서 내가 작성한 모든 테스트를 실행할 수 있는가?
>- 기본적인 테스트를 몇 분 내로 작성할 수 있는가?
>- 다른 팀 코드에 버그가 있어도 내 테스트는 통과하는가? 내 테스트는 다른 실행 환경에서 실행해도 동일한 결과를 보장하는가? 데이터베이스나 네트워크, 배포 없이도 내 테스트는 동작하는가?
>- 하나의 테스트를 삭제, 이동, 변경해도 다른 테스트는 영향받지 않고 잘 실행되는가?

p113
테스트 준비 과정에서 시간이 많이 걸리는 이유는 내외부 의존성(ex.데이터베이스)을 고려해야 하기 때문이다
(..)
좋은 테스트는 특정 객체, 함수, 의존성(도메인 모델)을 테스트하는 방법을 수립한 후에는 쉽고 빠르게 작성할 수 있어야 한다.


p114
테스트 결과가 항상 동일한 이유는 시스템에 대한 간접 입력을 우리가 제어할 수 있기 때문이다. 여기에서 간접 입력이란 데이터베이스, 네트워크, 시스템 시간 등 외부 의존성을 의미한다

- 가독성
- 유지보수성
- 신뢰성
..
지금까지 단위 테스트가 무엇을 의미하는지 의미있는 좋은 테스트를 만드는데 어떤 기능이 필요한지 설명했다.


### 1.9 최종 정리 
>[!note] 단위 테스트는 진입점을 통해 작업 단위를 호출한 후 그 종료점을 확인하는 자동화된 코드다. 단위 테스트는 거의 항상 단위 테스트 프레임워크를 사용하여 쉽게 작성할 수 있고 빠르게 실행할 수 있다. 잘 작성된 단위 테스트는 신뢰성이 높고 가독성도 좋아서 유지 보수하기에 용이하다. 우리가 운영하는 코드가 변경되지 않는 한 동일한 결과를 보장한다.

### 1.10 테스트 주도 개발
TDD 사이클에 대한 설명 
실패하는 테스트 코드를 작성한다
테스트를 통과할 수 있게 코드를 수정한다
테스트가 통과하는 것을 확인한 후 코드를 리팩터링하거나 다음으로 구현해야 하는 기능에 대한 테스트를 작성한다.

함수나 클래스 생성 > 테스트 작성 > 테스트 동작 확인 > 버그 수정
p123~124 **tdd 진행 흐름도**

p128
코드를 리팩터링하는 단계에서 "설계"란 코드 구조를 재정비하고 개선하는 과정을 의미한다 

>[!note] 리팩터링의 정의
>기능은 바꾸지 않으면서 코드 구조를 개선하는 것이다. 작게는 함수 이름을 바꾸는 것도 리팩터링이라고 할 수 있다. 큰 함수를 작은 함수 여러 개로 나누는 것도 리팩터링이다. 코드는 여전히 같은 기능을 수행하지만 더 유지보수하기 쉽고, 읽기 쉽고, 디버깅하기 쉽고, 수정도 쉽다

p129
TDD를 올바르게 사용하면 코드 품질이 크게 향상되고, 버그가 줄어들고, 코드에 대한 자신감이 높아지고, 버그를 찾는 시간이 단축되고, 코드 설계가 개선되며, 관리자 만족도가 높아진다

하지만 TDD를 잘못 사용하면 프로젝트 일정이 밀리고, 시간 낭비가 발생하고, 동기 부여가 떨어지고, 코드 품질이 낮아질 수 있다. 이것은 양날의 검과 같으면 많은 사람이 직접 어려움을 겪으면서 깨닫는다

.. **테스트를 잘 작성할 수 록 디버깅이 줄어든다.. (좋은 글이네)**

성공적으로 TDD를 하려면 기본적으로 세 가지 핵심 전략이 필요하다
- **좋은 테스트를 작성하는 방법을 알고** // 책에서 다루는 내용
- 코드보다 테스트를 먼저 작성하며
- 테스트와 프로덕션 코드를 잘 설계하는 것이다

### 1.11 요약 
이 장에서 살펴본 내용을 정리하면 다음과 같다


---
**도서 추천** 
- 켄트벡 - 테스트 주도 개발 (2014)
- 스티브 프리먼과 냇 프라이스 - 테스트 주도 개발로 배우는 객체 지향 설계와 실천(인사이트2013)
- 로버트 C.마틴 - 클린코드(인사이트, 2013)