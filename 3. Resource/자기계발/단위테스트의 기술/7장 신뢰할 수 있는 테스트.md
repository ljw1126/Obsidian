이 장에서 다룰 핵심 내용
- 테스트를 신로할 수 있는 판단하는 방법
- 신뢰도가 낮은 실패 테스트
- 신뢰도가 낮은 성공 테스트
- 불안정한 테스트 처리 방법

p556
좋은 테스트는 다음 세가지 특성을 만족해야 한다
- **신뢰성**
	- 신뢰할 수 있는 테스트란 버그가 없고 올바른 대상을 테스트함을 의미한다
- **유지 보수성**
	- 유지 보수성이 덜어지는 테스트는 항상 골칫거리다
	- 코드가 조금만 바뀌어도 테스트를 계속 수정해야 한다면 결국 유지 보수에 지친 개발자들이 손을 놓는다.
- **가독성**
	- 가독성은 테스트를 읽을 수 있는 것 외에도 테스트가 잘못된 경우 문제를 파악할 수 있는 능력을 의미한다
	- 가독성이 없으면 테스트를 유지보수하기 어려워지고 이해하지 못하므로 결국 테스트르르 신뢰할 수 없게 된다

## 7.1 테스트를 신로할 수 있는 판단하는 방법

일반적으로 다음 상황에서는 테스트를 신뢰하지 않는다
- 4가지 설명

반대로 다음 상황에서는 테스트를 신뢰한다 
- 2가지 설명


## 7.2 테스트가 실패하는 이유
단위 테스트를 포함한 모든 종류의 테스트 실패는 **합당한 이유**가 있어야 납득할 수 있다.
이 합당한 이유란 바로 실제 버그가 프로덕션 코드에서 발견된 경우를 의미한다.

테스트가 실패하는 이유는 다음과 같다.
- 프로덕션 코드에서 실제 버그가 발생된 경우
- 테스트가 거짓 실패를 일으키는 경우 
- 기능 변경으로 테스트가 최신 상태가 아닌 경우
- 테스트가 다른 테스트와 충돌하는 경우
- 테스트가 불안정한 경우

첫 번째 이유를 제외하면 나머지 이유 모두가 현재 단계에서는 테스트를 신뢰할 수 없음을 의미한다


### 7.2.1 프로덕션 코드에서 실제 버그가 발생된 경우

### 7.2.2 테스트가 거짓 실패를 일으키는 경우 

**테스트에 버그가 있는지 찾아내는 방법**
다음 항목에 해당하면 거짓 실패를 일으킨다고 볼 수 있다.
- 잘못된 항목이나 잘못된 종료점을 검증하는 경우
- 잘못된 값을 진입점에 전달하는 경우
- 진입점을 잘못 호출하는 경우

**테스트 버그를 발견했을 때 해야 할 일**
우선 침착하자. 버그를 수정하고 테스트를 다시 실행하여 통과하는지만 확인하면 된다.

테스트가 통과했다고 해서 바로 안심하지 말자. 이번에는 프로덕션 코드에 일부러 버그를 넣어 보자.
실패하지 않는다면 여전히 테스트 문제가 있을 수 있다는 의미이므로 테스트가 프로덕션 코드의 버그를 제대로 찾아내고 실패할 떄까지 계속해서 수정을 반복해야 한다

하지만 테스트가 계속 실패한다면 다른 문제(프로덕션 코드)를 의심해 볼 필요가 있다.
이때는 테스트를 해서 버그를 찾아낸 것이므로 오히려 잘된 일이라고 할 수 있다.

**향후 잘못된 테스트를 방지하는 방법**
<u>TDD 방식으로 코드를 작성하면 코드의 어디가 잘못되었는지 쉽게 찾을 수 있어 버그를 미리 막을 수 있다</u>

테스트 버그를 줄일 수 있는 또 다른 방법은 테스트 내부의 복잡한 로직을 제거하는 것이다 (7.3절)

### 7.2.3 기능 변경으로 테스트가 최신 상태가 아닌 경우
기능이 변경되면 테스트가 검증하려는 현재 기능과 맞지 않아 실패할 수 있다.

이때 두 가지 선택지가 있다
- 테스트를 새로운 기능에 맞게 수정한다
- 새로운 기능을 대상으로 새 테스트를 만들고 기존 테스트는 삭제한다 

> 변화는 막을 수 없다.


### 7.2.4 테스트가 다른 테스트와 충돌하는 경우
하나의 함수에 대해 기능 변경 전후 테스트(2개)가 존재할 때 하나는 성공, 하나는 실패하는 문제를 말하는 듯

**how?**
문제의 근본적인 원인은 두 테스트 중 하나가 더 이상 쓸모없어졌다는 것이다.
제품의 기능과 요구사항을 결정하는 사람, 즉 프로덕트 오너에게 물어보아야 한다.
어떤 기능이 필요하고 서비스의 요구 사항을 만족하는지에 대한 답은 그 사람들이 알 수 있기 때문이다

**향후 예방하는 방법**
테스트와 기능이 발전하는 과정에서 자연스러운 현상이므로 피하려 하지 않아도 괜찮다


### 7.2.5 테스트가 불안정한 경우
프로덕션 코드가 바뀌지 않았는데도 테스트가 실패하거나 통과하는 경우가 있다
이를 '불안정한 테스트'라고 한다 (7.5절에서 자세히)


## 7.3 단위 테스트에서 불필요한 로직 제거
테스트에 로직을 많이 넣을수록 테스트에 버그가 생길 확률이 기하급수적으로 증가한다.

(..)

단순히 실패한 테스트가 있다면 프로덕션 코드에서 원인을 찾기보다 테스트 코드 자체의 로직을 점검하는 것도 중요하다.

다음 내용이 단위 테스트에 포함되어 있다면 불필요한 로직이 포함된 것이므로, 이를 줄이거나 완전히 없애는 편이 좋다.
- switch, if, else 문
- foreach, for, while 루프
- 문자열 연결 (+기호) 등
- try/catch 블록 


### 7.3.1 Assert 문에서 로직: 동적 기댓값 생성

예제7-1. 로직이 포함된 테스트 
문자열 연결 결과값을 확인하는데, 이게 검증하려는 로직이 단위 테스트에 침범한거였구나
<u>함수의 버그를 감지하지 못하고 테스트가 통과한다. 이는 더 복잡한 로직에서도 동일한 문제가 발생할 수 있으며, 테스트 신뢰성을 크게 떨어뜨린다</u>

>[!warning] 검증(assert) 단계에서 기댓값을 동적으로 생성하지 말고 가능하면 하드 코딩된 값을 사용해야 한다.


### 7.3.2 다른 형태의 로직
반복문을 사용하여 입력 값을 동적으로 생성하면 기대 출력 값도 동적으로 생성해야 한다. 

예제 7-4, 7-5 안티 패턴 설명 (if else 문이 포함된 단위 테스트)

p582
즉, <u>프로덕션 코드와 동일한 방식으로 값을 처리하거나 결과를 계산하는 로직을 테스트 코드에 포함하면, 프로덕션 코드에 버그가 있을 때 테스트 코드도 동일한 버그를 포함하게 되어 테스트가 버그를 제대로 잡아내지 못한다.</u>

테스트 이름도 모호하면 가독성이 떨어진다.

이를 테스트 두세 개로 분리하여 각 테스트별로 다른 이름을 부여해서 의미를 살리는 편이 더 낫다.

복잡한 테스트가 원래의 간단한 테스트를 대체하면 오히려 프로덕션 코드에서 버그를 찾기가 더 어렵다. 이는 복잡한 테스트가 다양한 상황을 다루다 보니 특정 문제를 정확히 파악하기 어려워 실제로 버그를 놓칠 가능성이 높기 때문이다. <u>따라서 복잡한 테스트를 만들어야 한다면 기존의 간단한 테스트를 대체하지 말고 새로운 테스트로 추가해야 한다. </u>

> 복잡한 테스트를 '통합 테스트'라고 하며 그 수를 최소한으로 유지하려고 노력한다


### 7.3.3 로직이 더 많이 포함된 경우
이러한 곳(직접 작성한 가짜 객체, 테스트 유틸 클래스 등 )에 로직을 추가할수록 코드를 읽기 어렵게 만들고 테스트에서 사용하는 헬퍼 함수에 버그가 생길 가능성도 높다

어떤 이유로든 테스트에 복잡한 로직이 필요하다면(보통 단위 테스트보다는 통합 테스트에서 그렇게 한다) 최소한 유틸 함수의 로직을 검증하는 몇가지 테스트를 추가하는 것이 좋다. 
이렇게 하면 나중에 잠재적인 문제를 예방할 수 있다.


## 7.4 테스트가 통과하더라도 끝이 아니다

>[!note] 잘못된 신뢰
>잘못된 신뢰는 신뢰하지 말아야 할 테스트를 신뢰하지만, 그 사실을 아직 모르는 상태를 읨미한다. 테스트를 검토하고 잘못된 시뢰를 찾아내는 것이 매우 중요하다

테스트를 믿지 못하는 몇 가지 이유
- 검증 부분이 없는 경우 
- 테스트를 이해할 수 없는 경우 
- 단위 테스트가 불안정한 통합 테스트와 섞여 있는 경우
- 테스트가 여러 가지를 한꺼번에 검증하는 경우


### 7.4.1 검증 부분이 없는 경우 
테스트에 검증(assert) 부분이 없으면 함수 호출 내 검증 로직이 숨어 있을 수 있다.
그러나 함수 이름에 어떤 설명도 포함하지 않으면 가독성이 떨어질 수 밖에 없다

테스트 경험이 부족하면 검증 단계를 빼먹는 경우도 있다
이때는 빠진 부분을 추가하거나, 도움이 되지 않는 테스트는 삭제하는 것이 좋다
테스트 커버리지 올리는 것은 실질적인 가치 x

>[!tip] 
>테스트 코드 커버리지는 그 자체로 목표가 되어서는 안 된다.
>이는 '코드 품질'을 의미하지도 않는다. 사실 코드 커버리지를 목표로 삼으면 개발자가 유지 보수에 더 많은 시간이 드는 의미 없는 테스트를 작성할 수 잇다. 
>대신에 '발견되지 않은 버그', '수정 시간' 등 지표를 측정하는 것이 좋다(11장에서 더 자세히)

### 7.4.2 테스트를 이해할 수 없는 경우 
p589 
6가지 경우에 대해 나열


### 7.4.3 단위 테스트가 불안정한 통합 테스트와 섞여 있는 경우
'미꾸라지 한 마리가 온 웅덩이를 흐려 놓는다'는 속담이 있다.
불안정한 테스트와 언정적인 테스트를 섞어 놓는 것도 마찬가지다. 

불안전할 가능성은 `통합 테스트 > 단위 테스트`

통합 테스트와 단위 테스트를 분리하여 두 테스트가 섞이지 않도록  **안정적인 테스트 영역(safe green zone)** 을 만드는 것이 중요하다

이렇게 분리하면 단위 테스트는 더 빨리 실행되고 더 자주 실행하게 되는 효과가 있다.

### 7.4.4 테스트가 여러 가지를 한꺼번에 검증하는 경우
**종료점**(또는 **관심사**)을 1장에서 설명한 바가 있다.
이는 하나의 작업 단위에서 나오는 최종 결과를 의미한다. 
- 반환값
- 상태값 변경 
- 서드 파티 호출 등

예제7-6. 두 종료점을 동시에 검증하기 

하나의 테스트에서 여러 가지 검증할 경우 문제점 
- 테스트명이 모호해짐 (stub만 검증해야 하는데 verfiy까지 검증 하는 경우)
- 1번 검증에서 실패할 경우 2번 검증은 실행이 전혀 되지 않음

<u>각각의 검증은 서로 다른 작업 단위 요구 사항으로 볼 수 있으며, 이를 따로 구현하고 순차적으로 실행하는 것이 좋다</u>

>[!tip] 테스트를 나눌 때 고려해야 할 점 
>첫 번째 검증이 실패했을 때, 다음 검증 결과가 여전히 중요하다면 각 검증을 서로 다른 테스트 두 개로 독립적으로 진행하는 것이 좋다

예제 7-8. 관심사가 같다면 함께 검증 ok


### 7.4.5 테스트가 자주 변경되는 경우