
### 2.1 제스트 소개 

**제스트(jest)**
- 페이스북에서 만든 오픈 소스 테스트 프레임워크
- 백엔드와 프런트엔드 프로젝트 테스트 모두에 널리 사용되고 있다
- 두 가지 주요 테스트 구문을 지원한다
	- test라는 단어를 사용
	- 자스민(jasmin)문법을 기반
- 두 방식을 모두 시도해 보고 어떤 것이 더 나은지 살펴본다

제스트는 jest.config.js 또는 package.json 파일이 필요하다

**초기화**
```shell
cd ch2-first-test
npm init --yes

// 또는 
yarn init --yes
```


프로젝트에 의존되게 설치하는 경우 /프로젝트 루트/node_modeuls/.bin 폴더에 jest.js 파일이 생성된다. 아래는 글로벌로 설치하는 방법이다 

```shell
npm install -g jest    // 글로벌 설치
npx jest       // 제스트 실행 
```

이렇게 하면 테스트가 있는 폴더 어디에서나 npm을 거치지 않고도 터미널에서 직접 제스트 명령어를 실행할 수 있다. 

<u>실제 프로젝트에서는 전역으로 설치한 제스트를 사용하는 대신 npm 명령어로 테스트를 실행하는 것이 일반적이다</u>


#### 2.1.4 테스트 파일 생성 
제스트는 테스트 파일을 찾을 때 기본적으로 다음 규칙을 따른다 
- `__tests__` 폴더가 있으면 그 안의 모든 파일을 이름과 상관없이 테스트 파일로 간주하고 불러온다
- 프로젝트 최상위 폴더 아래에 있는 모든 폴더를 대상으로 `*.spec.js` 또는 `*.test.js`로 끝나느 파일을 재귀적으로 찾는다

우선 첫번째 규칙을 따르고, 나중에 파일을 옮기거나 폴더를 사용하지 않는 경우 개발 일관성 유지하기 위해 파일이름을 `*.spec.js` 또는 `*.test.js`로 끝나도록 만들 예정이다

제스트를 사용할 때 파일 위에 `require()`를 쓸 필요는 없다.  제스트는 자동으로 글로벌 함수를 불러온다(import). 주로 많이 사용하는 함수로는 test, describe, it, expect 등이 있다 

>[!note] 테스트 파일 위치 
>- 폴더 아래에 모아두거나, 테스트 대상 모듈 옆에 두거나 하는 방법이 있다
>- 프로젝트 전체에서 일관성을 유지하며 테스트 파일을 쉽게 찾을 수 있도록 하는 것이 중요하다
>- 필자는 테스트 폴더에 배치하는 쪽을 선호
>- 테스트에 필요한 헬퍼(helper) 파일을 테스트 폴더 근처에 둘 수 있어 편리하기 때문이다. 빠른 탐색 측면에서도 이점이 있다.


**파일 생성**
```js
// 실패하는 테스트
test('hello jest', () => {
  expect('hello').toEqual('goodbye');
});
```

#### 2.1.5 제스트 실행
아래 명령어를 실행하면 루트 폴더(ex. ch2-first-test)에서 실행하면 node_modules 디렉터리에서 제스트를 불러와 실행한다
```shell
npx jest
```


p154 실패하는 테스트와 성공하는 테스트 출력의 구성 설명* (not bad)

```js
// 성공하는 테스트
test('hello jest', () => {
  expect('hello').toEqual('hello');'
});
```


>[!tip] `jest --watch` 명령어
>제스트가 파일 변화를 감지하고 변경된 파일에 대한 테스트를 자동으로 실행한다. 매번 제스트를 재실행할 필요도 없어지고, 매 실행마다 걸리는 내부적인 초기화 작업을 건너뛰게 되며, 테스트가 많아지면 상당한 시간을 절약할 수 있다. 즉, 지속적인 테스트 프로세스에 큰 도움이 된다.

<u>제스트는 비동기 테스트와 콜백도 지원한다 (책의 후반부, 제스트 문저 참고)</u>


### 2.2 라이브러리, 검증, 러너, 리포터
제스트는 다음 역할을 한다
- 테스트를 작성할 때 사용하는 **테스트 라이브러리** 역할
- 테스트 내에서 expect 함수를 사용하는 **검증(assertion)** 라이브러리 역할
- **테스트 러너(runner)** 역할
- 테스트 실행 결과를 보여주는 **테스트 리포터(reporter)** 역할

또 제스트는 목(mock), 스텁(stub), 스파이(spy) 등을 생성할 수 있는 격리(isolation) 기능도 지원한다. (..) 하지만 자.스에서는 이러한 기능 중 일부만 제공하는 테스트 프레임워크가 많다. 이는 '한 가지 기능에 충실한 것'이라는 철학 때문일 수도 있고, 다른 이유가 있을 수도 있다. <u>어쨋든 제스트는 이 모든 기능을 하나로 통합한 몇 안 되는 테스트 프레임워크 중 하나이다.</u>


### 2.3 단위 테스트 프레임워크가 제공하는 기능 
제스트 프레임워크를 사용하면서 달라진 점 
- 테스트 코드의 일관된 형식
- 반복성
- 신뢰성과 시간 절약
- 공동의 이해

요약하자면 단위 테스트 프레임워크는 테스트 작성부터 실행, 검증까지 과정을 매우 효율적으로 만들므로 시간을 투자해서 학습할 가치가 충분하다.

p162 ~ 163 참고하기 . 테스트 프레임워크로 할 수 있는 것에 대한 설명

>[!note] 단위 테스트 프레임워크를 사용한다고 해서 테스트가 가독성, 유지보수성, 신뢰성을 보장하지 안는다. 게다가 모든 로직을 테스트할 수 있는 것도 아니다 (..)

p167
제스트는 엄밀히 말해 xUnit이나 TAP 프레임워크가 아니다. 기본적으로 xUnit이나 TAP 규격을 따르지 않기 때문이다. 하지만 xUnit 스타일의 테스트 리포팅이 빌드 환경에서 여전히 많이 사용되고 있기에 빌드 서버에서 리포팅을 그 프로토콜에 맞추는 것이 좋다
- `jest-xunit` 모듈을 설치하면 제스트 테스트 결과를 대부분의 빌드 도구에서 쉽게 처리할 수 있다
- 반면에 TAP 형식의 출력을 원한다면 `jest-tap-reporter`를 사용한다. 그런 다음 프로젝트의 jest.config.js 파일을 사용하여 제스트의 보고 형식을 설정할 수 있다.

### 2.4 앞으로  이 책에서 주로 다루는 예제: 비밀번호 검증 프로젝트
- p169 ~ 250까지 내용을 다룬다

```js
// password-verifier0.js
const verifyPassword = (input, rules => {
        const errors = [];
        rules.forEach(rule => {
          const result = rule(input);
          if(!result.passed) {
             errors.push(`error ${result.reason}`);
          }
        });

        return errors;
};
```

### 2.5 verifyPassword() 함수의 첫 번째 테스트 코드
AAA패턴: 테스트 코드를 `준비(Arrange) - 실행(Act) - 검증(Assert)` 순으로 작성


p179
>[!note] USE 이름 유래
>- 테스트할 대상 (Unit under test)
>- 시나리오 (Scenario)
>- 기대 동작 (Expectation)
>- 이 3가지의 앞글자를 합쳐서 USE라는 이름이 탄생 (타일러 렘키)

테스트 이름을 명확하게 지을수록 코드에서 문제가 생겼을 때 코드 전문을 자세히 보지 않아도 어디에 문제가 있는지 쉽게 예측할 수 있다.

p181
- 문자열 비교시 toMatch(), toContain() 사용권장
- 마침표 하나 찍는 변화로 테스트에 영향을 주지 않아야 한다. 중요한 것은 포함된 메시지이지

#### 2.5.5 describe() 함수로 구역 나누기
- 테스트 코드 구조를 좀 더 체계적으로 나누고 관리할 수 있다
- USE 전략에서 말하는 세 가지 요소를 서로 분리할 수 있다
#### 2.5.6 코드 구조로 알 수 있는 테스트 정보
- `describe()` 중첩 가능

#### 2.5.7 it() 함수
- jest 에서 제공하는 함수로 `test()` 함수의 별칭이라고 함 수 있다
- 지금까지 설명한 `describe()` 기반의 방식과 문법적으로 더 잘 어울림

p190
>[!note] 왜 test() 보다 it() 함수가 더 명료하다고 할까 ?


#### 2.5.8 두 가지 제스트 스타일 
- 제스트로 테스트 작성하는 방식은 크게 두 가지로 나뉨
	- test() 혹은 it() 함수를 사용하는 방식 
	- describe() 함수로 계층 구조로 표현하는 방식
		- ruby, 자스민 테스트 프레임워크에서 유래
		- `행동 주도 개발 (BDD)` 스타일이라고 함

p193
필자에게 오늘날의 BDD 프레임워크는 '약간의 문법적 편의(syntactic sugar)가 가미된 테스트 프레임워크'라는 의미로 다가온다

p200
검증 룰렛(assertion roulette) // **안티 패턴**

### 2.6 beforeEach() 함수 사용
- 이 함수는 각 테스트가 실행되기 전에 한 번씩 실행되기 때문에 중복 코드를 제거하는데 도움이 된다

p206
하지만 제스트는 병렬 테스트 방식을 선택했기에 verifier 처럼 여러 곳에서 접근 가능한 변수를 두는 상태 기반 테스트는 잠재적으로 문제가 될 수 있으며, 알수 없는 이유로 테스트가 실패하는 불안정한 테스트를 만들 수 있다

p208
>[!note] 역자의 노트
>'테스트는 분리된 환경에서 독립적으로 실행되어야 한다' ...


"스크롤 피로감" 현상 간략 설명
- 중첩 구조는 테스트 결과를 보기에는 좋지만, 실제로 코드를 읽는 사람에게는 스크롤을 올렸다 내렸다 하는 것이 불편할 수 있다.

예제 2-15까지 beforeEach()로 인한 중복 발생하여 `스크롤 피도감`을 증대시키는 것을 설명

### 2.7 팩토리 함수 사용
**팩토리 함수**는 객체나 특정 상태를 쉽게 생성하고, 여러 곳에서 동일한 로직을 재사용할 수 있도록 도와주는 <u>간단한 헬퍼 함수</u>다. 

예 2-16. 팩토리 함수 적용하여 beforeEach() 에서의 중복도를 줄인다. (rule 생성에 대해)

p221
예 2-17. beforeEach()를 전혀 사용하지 않고 팩토리 함수를 좀 더 작게 만들어서 사용해본다면 
- 병렬적으로 실행하더라도 서로 독립적인 테스트 실행됨!!
- 중독도 제거되고 가독성 향상 
- 스크롤 피로감 x
- 객체가 **어떻게** 생성되는지는 몰라도 **언제** 생성되고 매개변수로 초기화되는지 알 수 있다. (명확해짐)

p224
>[!note] 약자의 노트. 캡슐화 (읽어보기)


### 2.8 다시 test() 함수로 돌아가기
- describe() 함수의 중첩 구조를 버리고, 다시 test()로 나타낸다
- 구조적인 명확성을 조금 잃을 수도 있지만, 경우에 따라 더 가독성이 나을 수 있다
- 프로젝트의 유지보수성과 가독성의 적절한 균형을 이 두 가지 접근 방식 사이 어딘가에 있으므로 그 중간을 잘 찾아야 한다

### 2.9 다양한입력 값을 받는 테스트 리팩터링 
- `password-rules.js` 생성 
- `text.each()` 나 간단하게 `for()`반복문으로 작성할 수 있다
	- 문법 : https://jestjs.io/docs/api#testeachtablename-fn-timeout
	- memo. 앞에 변경전 예제는 생략 .. JUnit에 **ParameterizedTest** 이 있다

### 2.10 예정된 오류가 발생하는지 확인
- `verify()` 함수
- junit 에서도 마찬가지로 throws 가 존재함

p240
>[!not] fail() 함수가 권장되지 않는데 예제에서는 사용한거에 대한 설명 (참고하기)


### 2.11 테스트 카테고리 설정
- 단위 테스트나 통합 테스트등 특정 카테고리의 테스트를 실행하고 싶을 때가 있음 
- 근데 jest에서는 공식적으로 지원하지 않고 설정 파일 통해 정규식으로 파일 명칭 찾아 실행 하는 방법은 존재한다
- @SpringBootTest, @WebMvcTest, @DataJpaTest 등 어노테이션같은 기능은 제공 안함

### 2.12 요약
읽어보기

---
- npm trends 참고
- 단위 테스트 프레임워크가 약 900개 정도 넘는다 (위키백과 참고)
- 제스트 공식 문서 : https://jestjs.io/

---
도서 오타 
2.1.3 제스트 설치 - npm init 중복이다 (p147)
	p183 toMatch -> toContain 수정이 잘 안보인다 흑백이라서 