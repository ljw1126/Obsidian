4장에서 목과 스텁을 수동으로 직접 작성하는 방법을 살펴보았다

이번 장에서는 **격리 프레임워크**(=모의 프레임워크, mocking framework)를 공부한다 

>[!info] 격리 프레임워크
>런타임에 가짜 객체를 생성하고 설정할 수 있는 재사용 가능한 라이브러리를 의미한다
>이러한 객체는 동적 스텁, 동적 목 이라고 한다


모듈형, 함수형, 객체 지향형을 어떻게 사용할 수 있는지 살펴본다
이들을 사용하면서 테스트의 가독성, 유지 보수성, 지속 가능한 테스트 등이 프레임워크들이 지향하는 가치를 배울 수 있다

### 5.1 격리 프레임워크 정의
>[!info] 격리 프레임워크 
>객체나 함수 형태의 목이나 스텁을 동적으로 생성, 구성, 검증할 수 있게 해주는 프로그래밍 가능한 API다. 격리 프레임워크를 사용하면 이러한 작업을 수 작업으로 했을 때보다 더 간단하고 빠르며 코드도 더 짧게 작성할 수 있다.

격리 프레임워크를 적절하게 사용할 경우 
- 객체의 상호 작용을 검증하거나 테스트할 때 반복적 코드를 줄여 줌
- 테스트 지속성을 높여 오랜시간 개발자가 프로덕션 코드 변경될때마다 테스트 수정하지 않게 한다

하지만 잘못 오남용할 경우 가독성 저하, 신뢰할 수 없는/의미없는 테스트 작성하게 된다

#### 5.1.1 선택하기: 느슨한 타입 대 정적 타입
- 느슨한 타입의 자바스크립트 격리 프레임워크
	- 제스트와 사이넌 등
- 정적 타입의 자바스크립트 격리 프레임워크
	- substitute.js 등

의존성 타입에 따라 
- 모듈 의존성(import, require) 
	- 제스트 같은 느슨한 타입의 프레임워크가 좋다
- 함수형 의존성(단일 함수, 고차 함수, 간단한 매개변수와 값)
	- 모듈 의존성과 마찬가지로, 제스트와 같은 느슨한 타입의 프레임워크가 잘 어울린다
- 객체 전체, 객체 계층 구조, 인터페이스 
	- substitute.js 같은 객체 지향적인 프레임워크가 어울린다

### 5.2 동적으로 가짜 모듈 만들기
앞서 했던 PasswordVerifier 예제와 제스트를 계속 사용할 예정


>[!note] 명령과 쿼리 분리
>명령과 쿼리 분리라는 설계 방식이 있다. 이 용어에 대해 더 알고 싶다면 마틴 파울러가 2005년에 쓴글을 읽어보기 바란다. 이 패턴은 다양한 설계 아이디어를 이해하는데 매우 유용하다
https://medium.com/@joohotheman/%EB%B2%88%EC%97%AD-%EB%A7%88%ED%8B%B4-%ED%8C%8C%EC%9A%B8%EB%9F%AC-cqrs-%ED%8F%AC%EC%8A%A4%ED%8C%85-245c63bb1e58


ex) configuration-servier.js 에서 로그 레벨 조회하려고 **쿼리** 보내고,
PasswordVerifier에서 로그를 남기라고 **명령**을 보낸다


#### 5.2.1 제스트 API에 대해 알아 둘 점
제스트로 스텁을 만들때나 목을 만들때나 모든 곳에서 'mock' 단어를 사용하여 헷갈릴 수 있다
<u>'stub'이라는 단어를 'mock'과 동일한 의미로 사용하면 더 와닿을 것이다 </u>

<u>제스트와 같은 프레임워크가 없었다면 모듈을 직접 가짜로 만드는 것이 엄청나게 번거로웠을 것이다.</u> 
//결국 4장에서 했던게 수작업으로 mock을 만들었던 거였구나 

p431
그러나 jest.mock의 단점은 제어권이 있는 코드까지 모두 가짜로 만들어 버린다는 것이다.
이렇게 하면 실제 의존성을 더 간단한 내부 API로 추상화하여 숨기는 방식의 이점을 놓칠 수 있다
이러한 접근 방식 포트와 어댑터 아키텍처(헥사고날 아키텍처)라고도 한다
(코드의 유지보수성이 뛰어나다는 단점이 있다)


### 5.3 함수형 스타일의 동적 목과 스텁
초기화 단계에서 선언만 하고, 검증단계에서 메소드 체인을 통해서 확인하는게 심플해짐


### 5.4 객체 지향 스타일의 동적 목과 스텁

인터페이스 변경이 발생할 경우 모의 객체가 여러 군데 있게 되면 수정이 여러 군데 발생한다 
이러한 모의 객체를 팩토리 함수와 같은 함수 내부로 옮겨서 객체의 생성 처리를 한 곳에서만 하는 것이 좋은 선택일 수 있다.

p447
>[!info] 격리 프레임워크와 AAA 패턴 
>격리 프레임워크를 사용하는 방식은 우리가 1장에서 살펴본 AAA 패턴과 잘 맞아 떨어진다 .
>.. 그외 읽어보기

참고. **AAA패턴**: 테스트 코드를 `준비(Arrange) - 실행(Act) - 검증(Assert)` 순으로 작성


### 5.5 동적 스텁 설정
제스트는 모듈과 함수 의존성의 반환 값을 조작하는 함수 제공
- `mockReturnValue()` : 호출시 동일한 스텁 결과값 반환
- `mockReturnValueOnce()` : 한번씩만 결과값 반환, 메서드 체인 가능, 반환값이 없으면 `undefined` 반환

오류를 테스트해야 하거나 더 복잡한 작업을 해야 하는 경우 
- `mockImplementation()`
- `mockImplementationOnce()`

#### 5.5.1 목과 스텁을 사용한 객체 지향 예제
s/w가 업데이트되는 유지보수 기간 동안 **비밀번호 검증기가 비활성화** 된다고 가정해보자
- 유지보수 기간 중에
	- verify() 호출하면 logger.info()에 Uner Maintenace라는 메시지를 전달한다 
- 유지보수 기간이 아닐 때
	- logger.info()에 passed 또는 failed 결과를 전달한다
	  
		
#### 5.5.2 substitue.js를 사용한 스텁과 목
- 제스트 대신 substitue.js를 사용
- MaintenanceWindow 인터페이스의 스텁과 IComplicatedLogger 인터페이스의 목을 생성함

예제 5-11은 라이브러리를 이용한 덕분에 직접 가짜 객체를 만들 필요는 없엇으나 가독성이 떨어지기 시작했다. 함수형 스타일로 만들면 보통 이보다는 훨씬 간결하다. 반면에 객체 지향 스타일로 만들다 보면 이러한 복잡함이 불가피한 상황도 생기기 마련이다. 

하지만 다양한 유틸리티성 기능이나 목, 스텁을 만드는 과정을 헬퍼 함수로 옮기는 리팩터링을 거치면 더 간결하고 가독성이 좋은 형태로 만들 수 있다.


### 5.6 격리 프레임워크의 장정과 함정

**장점**
- 손쉬운 가짜 모듈 생성
- 값이나 오류를 만들어 내기가 더 쉬워짐
- 가짜 객체 생성이 더 쉬워짐

하지만 편리함 속에서도 잠재적인 위험 요소가 있다

#### 5.6.1 대부분의 경우 모의 객체가 필요하지 않다 (👍)
격리 프레임워크의 가장 위험하면서 무시하기 힘든 함정은 <u>무엇이든 쉽게 가짜로 만들 수 있다는 것</u>과 <u>애초에 모의 객체가 필요하다고 생각하게 하는 것</u>이다
-> 생각없이 만든다는거네

모의 객체는 대부분의 단위 테스트에서 기본적으로 사용해서는 안된다. 

작업 단위에는 **반환 값**, **상태 변화**, **서드 파티 의존성 호출** 이렇게 세 가지 종류의 종료점이 있을 수 있다는 점을 항상 기억하자. 이 중 단 하나의 유형만 테스트에서 모의 객체를 사용했을 때 이점을 누릴 수 있고, 나머지는 그렇지 않다.
-> 제어할 수 없는 서드 파티 의존성에 대한 반환값이나 호출 여부 확인시 모의 객체를 사용

함수형 디자인에서는 몇몇 특수한 경우를 제외하고는 모의 객체가 거의 필요 x

<u>모의 객체 없이도 동일한 기능을 검증할 수 있는지 잠시 생각해보자</u>
- 모의 객체나 스텁을 사용하면 외부 의존성에 영향을 받아 테스트 난이도가 올라갈 수 있다

반환 값을 검증하거나 작업 단위의 동작 변화를 외부에서 확인하는 것이 훨씬 쉬울 수 있다
- 예를 들어 
	- 함수가 호출되었는지 확인하는 대신 해당 함수가 예상대로 예외 발생시키는지 확인
	- 이렇게 하면 함수 동작을 외부에서 검증할 수 있다


#### 5.6.2 읽기 어려운 테스트 코드 (👍)
하나의 테스트에 많은 목을 만들거나 검증 단계를 너무 많이 추가하면 테스트 가독성이 저하될 수 있고, 유지보수가 어려워질 수 있다

테스트 가독성이 떨어지고 이싿고 느낀다면 목이나 검증 단계를 줄이는 것도 하나의 방법일 수 있다.
또는 테스트를 더 작은 하위 테스트로 쪼개서 전체적인 가독성을 끌어올리는 것을 고민해 보는 것도 좋다 

#### 5.6.3 잘못된 대상 검증 (👍)
모의 객체를 사용하면 인터페이스의 메서드나 함수가 호출되었는지 확인할 수 있다
<u>그렇지만 이게 항상 올바른 대상을 테스트하고 있는 것은 아니다</u>

테스트에 입문하는 사람들이 흔하게 저지르는 실수는 실제로 의미 있는 동작을 검증하기보다는 단지 가능하기 때문에 검증을 하는 것이다. 

<u>예로 함수 호출 여부만 확인할 수 있다는 이유로 검증을 수행했지만, 실제로는 그것이 왜 중요한지는 고려하지 않는다</u>
- 내부 함수가 다른 내부 함수를 호출했는지 검증 (종료점이 아닌 경우)
- 스텁이 호출되었는지 검증 (들어오는 의존성은 검증하지 말아야 하는데 이는 **과잉 명세 안티 패턴** 이라 함, 5.6.5절에서 다룸)
- 단순히 누군가가 테스트를 작성하라고 해서 호출 여부 검증

#### 5.6.4 테스트당 하나 이상 목을 사용
<u>하나의 테스트에 목을 두 개 이상 사용하는 것은 동일한 작업 단위의 여러 종료점을 한꺼번에 테스트하는 것과 같다.</u> -> 유지보수 비용 상승, 테스트 가독성 저하

<u>각 종료점마다 별도의 테스트를 작성(분리)하면 좋다</u>. 이는 각 종료점을 별개의 요구사항으로 볼 수 있기 때문이다. 


#### 5.6.5 테스트의 과도한 명세화
테스트에 검증 항목이 너무 많으면 아주 작은 프로덕션 코드 변경에도 쉽게 깨질 수 있다
상호 작용을 테스트 하는 것은 양날의 검과 같아서 너무 많이 테스트하면 전체 기능이라는 큰 그림을 놓치게 되고, 너무 적게 테스트하면 작업 단위간 중요한 상호 작용을 놓치게 된다.

이러한 현상을 균형있게 유지하려면 다음 방법을 고민해 보아야 한다
- **목 대신 스텁을 사용하기**
	- 스텁은 어디에서든 여러 번 사용해도 상관없지만, 모의 객체는 그러지 않다
	- 한 번에 하나의 시나리오만 테스트하면 된다
	- 보통 중요한 검증은 하나뿐이므로 나머지는 그저 들러리 역할을 하는 불필요한 테스트가 될 수 있다
- **가능한 스텁을 목으로 사용하지 않기**
	- 스텁은 테스트 중인 작업 단위에 가짜 값 제공하거나, 예외를 던지기 위해서만 사용
	- <u>스텁에서 메소드 호출 여부 검증은 하지 않는다</u> (반성..😅)

### 5.7 요약
p469 

---

- 블라디미르 코리코프가 쓴 <단위 테스트> 6장에서는 상호 작용 기반 테스트를 더 단순하고 신뢰할 수 있는 반환 값 확인 테스트로 리팩터링 하는 방버을 자세히 다룸



목과 스텁이 구분을 명확히 하기
- 스텁 : 상태 확인
- 목 : 행위 확인, 예로 인터페이스 메서드 호출 여부

진입점과 종료점 