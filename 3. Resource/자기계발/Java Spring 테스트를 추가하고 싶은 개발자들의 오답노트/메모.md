- [인프런 강의](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%98%A4%EB%8B%B5%EB%85%B8%ED%8A%B8)
- [학습 저장소](https://github.com/ljw1126/test-code-with-architecture)


---

테스트 
- 인수 테스트/자동 테스트


1-2. 테스트에 대한 개요와 개발자가 해야할 고민
TDD 장단점 
- 장점1. 깨지는 테스트를 먼저 작성해야 하기 때문에, 인터페이스(=행동)를 먼저 만드는 것이 강제된다 
  - What/Who 사이클: 객체 사이의 협력 관계를 설계하기 위해서는 먼저 "어떤 행위(what)를 수행할 것인지를 결정하고 "누가(who)" 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 '어떤 행위'가 메시지다 
  // 조영호의 객사오
- 장점2. 장기적인 관점에서 개발 비용 감소
- 단점1. 초기 개발 비용 
- 단점2. 난이도 있어서 숙련도 필요

개발자의 고민 
1. 무의미한 테스트 
 - 커버리지만 높이기 위한 테스트
2. 느리고 쉽게 깨지는 테스트 
3. 테스트가 불가한 코드 
>> 테스트가 보내는 신호를 잘 캐치해서 좋은 설계로 만들어간다


1-3. 테스트의 필요성과 테스트 3분류 
regression(회귀 버그)
- 정상적으로 동작하던 서비스가 이번 배포로 동작을 안한다 
- 프로젝트에 합류한지 얼마 안되서 "수정"이 두렵다. 제 코드가 다른 코드에 영향을 주지 않을까요


좋은 아키텍처란?
- 회그버그 방지(TEST)와 좋은 설계(SOLID) 합집합 

테스트 3분류 
- API테스트 / 통합 테스트 / 단위 테스트 
- 구글에서는 대형/중형/소형 테스트로 나눔 

4) 소형 테스트 
- 단일 서버/프로세스/스레드, 디스크 I/O 사용해선 안됨, Blocking call 허용 안됨

5) 중형 테스트
- 단일 서버, 멀티 프로세스, 멀티 스레드 
- h2와 같은 테스트 db를 사용할 수 있다

6) 대형 테스트 
- 멀티서버, end to end(E2E) 테스트 
----------------
1-4.
7) SUT
- System under test : 테스트 하려는 대상

8) BDD
- Behaviour driven development ( given 상황 -when 행동 -then 결과)

9) 상호 작용 테스트 (Interaction Test)
- 대상 함수의 구현을 호출하지 않으면서 그 함수가 어떻게 호출되는지를 검증하는 기법

10) 상태 기반 검증 vs 행위 기반 검증 

11) 테스트 픽스처
- 테스트에 필요한 자원을 생성하는 것

12) 비욘세 규칙 (by 구글)
- "유지하고 싶은 상태가 있으면 전부 테스트로 작성해주세요 "
- 그게 곧 정책이 될겁니다.

개념 
- 테스트는 정책이고 계약입니다
- Teastabiliy
- test double 

테스트 대역 
- dummy : 아무런 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 이해 전달하는 객체 
- fake : local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체, 자체적인 로직이 있다는게 특징
  (*주로 사용)
- stub : 미리 준비된 값을 출력하는 객체 (주로 Mockito 프레임워크 활용) 
- Mock : 메소드 호출을 확인하기 위한 객체, 자가 검증 능력을 갖춤 사실상 테스트 더블과 동일한 의미로 사용됨
- spy: 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체

=======================================================================

1-5. 의존성 
의존성이란?
결합(coupling)과 같은 개념, 어떤 객체가 다른 객체를 사용하는것 

// 하나의 객체가 모든 책임을 가지지 않는다, 객체 지향에서 각 객체는 책임과 역할의 가지고 메시지를 보내 협력하여 하나의 기능이 동작하도록한다. 한 객체가 본인이 할 수 없는 일이 있을때 다른 객체에 그 책임을 위임, 메시지를 보낼때 "의존한다"라고 표현한다


의존성 주입 
- new로 직접 인스턴스 생성하는게 하드코딩이나 다름 없다 

의존성 역전
- 의존성 주입과 의존성 역전은 SOLID_DIP 다르다 
  1) 상위 모듈은 하위 모율에 의존해서는 안된다. 상위 모듈과 하위 모듈 둘다 추상화에 의존해야 한다 
  2) 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다 
  // "의존관계 화살표 방향을 바꾸는 테크닉"
- "고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다 - 로버트 C 마틴"

- "자바와 같은 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다(중략) 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다"

=======================================================================

1-6 의존성(2) *********************************** 
 "테스트를 잘 하려면 의존성 주입과 의존성 역전을 잘 다룰 수 있어야 한다"
>> 의존성 주입 + 의존성 역전으로 해결 

User > ClockHolder(interface) // 전략 패턴을 사용하네 


Testability
- "얼마나 쉽게 input을 변경하고, output을 쉽게 검증할 수 있는가?"

다음 예들이 Testability가 낮다고 한다
어거지 테스트 ) 호출자는 모르는 입력이 존재한다. Mockito 활용 하더라도 에러 발생 
  >> 의존성 역전으로 해결해본다  (직접해보기)
하드 코딩) 파일이 존재하지 않을때
외부시스템) 하드 코딩된 외부 시스템과 연동이 되어 있는 경우  
감춰진결과)

=======================================================================

1-7.

13. Builder pattern 
생성자가 지나치게 많아지는 문제를 해결할 수 있는 유연한 해결책 
// 일부 파라미터 누락해서 에러가 발생가능 

그럼에도 builder 사용하는 이유 
14) 새 객체가 생성할 때 "문법적으로 지저분한 부분을 대부분 가려준다"
15) 기본적인 경우를 단순하게 하고 특별한 경우라도 그리 복합하게 만들지 않는다 
16) "테스트 객체의 구조적인 변화로부터 테스트를 다시 한 번 보호한다"
(중략)
마지막 이점은 읽기 쉽고 오류를 찾기 쉬운 테스트 코드를 작성할 수 있다는 것이다. 
각 빌더 메서드가 해당 매개변수의 용도를 밝히기 때문이다


장점) 
17. 생성자를 하나로 관리할 수 있다 
18. 긴 파라미터를 정리할 수 있다
단점)
19. 종종 필요한 파라미터를 누락하는데, 컴파일러가 이를 캐치하지 못할 수 있다


20. 엔티티 
"도메인 엔티티, 영속성 객체, .."
- 엔티티는 JPA랑 상관이 없다     // 마냥 틀린건 아니지만 혼합해서 설명 
- 도메인 엔티티와 DB엔티티는 다르다.
  "--"

21) 도메인 엔티티 : 비즈니스 영역을 해결하는 모델
22) 영속성 엔티티 : ORM(Object Relational (database) Mapping) 
// nosql에서는 ODM(Object Document Mapping)
23) DB엔티티: RDB에 저장되는 객체


기타 조언***********************


DRY : Dont Repeat Yourself 반복하지 않기 
DAMP : Descriptive And Meaningful Phrase 서술적이고 의미있는 문구

테스트에 논리를 넣지 말자 (for, if, ...)_

====================================================
섹션3. 방향성 탐색 

3-1. 
h2
- 설계가 잘못되었을 확률
- 지금 작성한 테스트가 실제로 테스트가 필요한 본질이 아닐 확률
// rdb는 h2라도 있지, 엘라스틱 서치와 같은 건 x

레이어드 아키텍처 
- 쉽다 
장점) 기능 개발을 할 때 가시적은 무언가를 만들기에 가장 쉬운 방법
단점1) 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다. (중략) 모든 것이 영속성 계층을 토대로 ㅁ나들어진다 - 톰 홈버그, 만들면서 배우는 클린 아키텍처 자바 코드 
단점2) 이러한 기대를 충족시키려면 아키텍처가 동시 작업을 지원해야 하지만 이렇게 하기란 쉽지 않다. 
그리고 계층형 아키텍처는 이런 측면에서 그다지 도움이 되지 x (중략)
계층형 아키텍처에서는 이렇게 작업할 수 없다. **모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 그 다음에 도메인 계층을, 그리고 마지막으로 웹 계층을 만들어야 한다. 
그렇기 때문에 특정 기능은 동시에 한 명의 개발자만 작업할 수 잇다. // 절차지향적 코드 작성이 된다 
단점3) 계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다. 
// getter, setter를 가진다 
// 사실상 service가 모든일을 다 처리하는 신과 같은 존재가 된다 (=fat service)

그외 단점
- DB 주도 설계를 유도한다 
- 의존성에 대한 고민을 유도하지 않는다 
- 도메인이 죽는다 
- 동시 작업이 불가하다
- 규모가 커질수록 확장성이 떨어진다 
  >> 절차지향적 사고를 유도 
  >> 낮은 Tesability & Bad SOLID 
       

개선된 아키텍처 
*1. 도메인에 비즈니스 로직을 위임 
*2. SOLID & 동시 작업
*3. 낮은 Testability

// 도식화 이해하기 

===============================================================

섹션4. 

4-2. 외부 연동을 다루는 방법 
** 서비스 레이어에서 의존성 관련 패키지 이동 (이해 안됨)

===============================================================

섹션5.

[1강]
테스트 하기 쉬운 코드가 좋은 코드일 확률이 높다 
테스크 코드가 잘 작성되있을 수록 디버깅을 적게 한다


아키텍처란 
> 어떤 비즈니스 문제를 해결하기 위해, "준수해야 하는 제약"을 넣는 과정
  // 문제 상황을 먼저 파악하고, 구성원이 공감해야함 >> 이유가 없다면 번거로움 
  // 종착지가 아니라 여정에 가깝다

아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 
더 가까움을 이해햐아 좋은 아키텍처가 만들어진다 - 케블린 헤니(Kevlin Henney)

아키텍처의 목표 
> 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 "인력을 최소화"하는데 있다 
> 아키텍터의 목표를 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 
무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다. 이를 통해 세부사항을 결정하는 일은 미루거나 연기 할 수 있다****
- 로버트 C. 마틴 

요약 
- 인적 자원 절감 >> 동시작업이 가능해야 한다 > 관심사가 분리해야 된다 > "경계"가 나눠져야 한다
- 정책을 만들고 세부사항을 미루는 시스템 개발 
  " 개발 초기에는 Oracle/MySQL/Mongo인지 선택할 필요가 없다 
       개발 초기에는 Nginx인지 Apache인지 선택할 필요가 없다 
       개발 초기에는 REST인지 GraphQL인지 선택할 필요가 없다 
       개발  초기에는 Spring을 적용할 필요가 없다
       
       도메인이 먼저 개발되어야 한다"
    
제일 중요한 도메인 고민을 마지막에 한다. 
이렇게 되면 안된다. 개발 초기에는 도메인 영역을 먼저 개발하고 
정책을 정하고 이에 대응하는 테스트가 짜여있어야 하죠. 
그리고 그 도메인에 jap, spring, rest 기술이 얹혀져야 한다
>> 기술에 의존적으로 했을때 지난 4년간 충분히 경험했다, 절차적, 하드코딩, 데이터 주도 설계 유지보수 하기 힘든 코드가 만들어지고 결국 고도화라는 이름의 프로젝트


*의존성 역전은 경계를 만드는 대표적인 방법이다 

"프레임워크와 결혼하지 말라!"
"도메인이야 말로 소프트웨어의 핵심이다. Spring/Jpa가 중요한게 아니다"

----
헥사고날 
- 의존성 역전 (포트-어댑터 패턴)
  - 관심사를 분리하고 싶다 
  - 고립시키고 싶다 
  - 서로에게 영향을 끼치고 싶지 않다

인터페이스라는 포트에 필요한 어답터를 끼워줄 뿐이다 
포트를 통해 기능을 제공할 뿐이지 무슨 어답터인지 실행객체가

도메인 접근까지 단방향성 유지되서 도메인은 순수해진다



*헥사고날이 클린아키텍처의 실천법으로 나온거다 
- 클린 아키텍처는 UseCase(port-in)와 GateWay(port-out)라 부른다 , 외부세계를 humble이라 함

=====================================================
2강 

레이어드 아키텍처
- DB 위주, Rest Controller 위주의 사고를 하게 함 = 상향식이든/하향식이든 프레임워크(기술)에 종속적인 사고를 하게 만든다.(세부사항에) >> 도메인은 제일 마지막


*헥사고날 
- 헥사고날의 접근법은 상향식일때 자연스럽다  // 이미지 참고******** 확실히 작업하는게 편했다 
  

험블객체 - 클린아키텍처, 로버트 C마틴 
"본질만 남기고 테스트하기 어려운 부분을 분리하자, 이때 분리된 "테스트하기 어려운 부분을 험블(Humble)이라고 부른다" 대표적으로 GUI, DB는 험블이다 // 테스트하기 어렵다 ***


험블 객체 패턴 
- 본질과 험블을 구분해야 하는 이유 
  : DB를 바꾼다고 계산 로직이 변경되면 안된다
  : 라이브러리를 바꾼다고 계산 로직이 변경되면 안된다
  : 더 나아가 언어를 바꾼다고 계산 로직이 변경되면 안된다
  //jpa든, 스프링이든  경각심을 가져야 한다
  
  "도메인을 설계하는 힘이 훨씬 중요하다"
  
*중요한건 정책이고, 문제를 파악하는 요구사항 명세인거다 

// 이미지 참고 

클린            헥사고날 
UseCase - Port in
Gateway - port out 


*유즈 케이스의 중요성 
- UseCase만으로 시스템이 인식되는데, Platform, Application 기술 스택만으로 무슨 시스템인지 인식 안됨 
> 새로운 언어/플랫폼이 나오면 매번 그걸 쫓아갈건가?


*모델
- 모델은 어디까지 세분화해야 하는가?
  "노골적으로 이 주제는 Domain entity 와 Jpa eneity를 분리해야 하나"라는 질문으로 시작한다
   
자료. 만들면서 배우는 클린 아키텍처 
      NHN FORWARD 22 클린아키텍처 애매한 부분 정해 드립니다 2023년 1월 4일 

// 나는 구분해야 한다고 주장한다 기술에 강결합되니 
 분리하지 않으면 도메인이 DB에 종속되고 ORM과 결합이 생긴다 
 >> 테이블/컬럼/jpa 설정이 들어가는게 부자연 스럽다 
 

// 하위 모델이 상위 모델을 의존한다 , 순환참조 발생 ex. 서비스 레이어에서 request dto 의존  

========================================================================

3강 .


JPA분리 
24. 서비스가 바로 JpaRepository 인터페이스 의존 하는 방식 
단점
> Fake가 불필요한 인터페이스를 구현해야 한다. 
> Service가 Repository의 불필요한 모든 메소드에 대해 알게된다 
> 서비스에서 Persistence Entity에 의존하게 된다 // 도메인 모델 toDomain을 서비스에서 호출
  >> Service는 jpa에 의존적이게 된다

25. JpaRepository 인터페이스를 인터페이스 구현한다
> Fake를 만들때 JpaRepository 선언한 메소드만 하면되서 불필요한걸 알 필요 없어진다 ?
> 결과적으로 서버스가 영속성 모델에 의존하는 동일한 문제가 발생

26. 구현체 
> 서비스가 영속성 모델에 독립, 구현체에서 도메인모델로 변환하여 전달 
> 서비스가 JpaRepository에 굳이 다 알필요 없이 필요한걸 구현체에 요청하면된다 



서비스는 추상화되어야 할까?
- 서비스 자체가 유스케이스여야 한다고 생각  
// 유스케이스의 장점을 못느끼면 필요없을수있따 
>> 단방향을 유지하고, 도메인을 독립시켜야 한다 

//정답은 존재하지 않으며 문제를 해결하는 과정이다
//따라서 원리를 이해하는게 중요하다
====================================

테스트에서 중요한건 가독성, 표현성


참고. Thread.sleep에 대한 대안 Awaitility 라이브러리


트로이 목마 
- 테스트를 전파하는 트로이 목마 
"우리는 테스크 코드가 없나요?"**************************


사람이 이해할 수 있는 코드는 명확해야 하고 
의도가 드러나는 설계가 가져야하고, 의도가 드러나는 테스트가 있으면 좋다
테스트 자체가 문서니깐

================================

헥사고날 아키텍처 (Hexagonal Architecture), 또는 포트와 어댑터 아키텍처 (Ports and Adapters Architecture)를 적용한 REST API 프로젝트의 장단점을 살펴보겠습니다.

장점
명확한 의존성 관리:

비즈니스 로직이 외부 시스템에 의존하지 않기 때문에 코드를 더 쉽게 이해하고 유지보수할 수 있습니다.
외부 시스템과의 상호작용을 인터페이스(포트)와 구현체(어댑터)로 분리하여 변경에 유연합니다.
테스트 용이성:

비즈니스 로직을 외부 의존성 없이 독립적으로 테스트할 수 있어 단위 테스트 작성이 쉽습니다.
모의 객체(mock)를 사용하여 외부 시스템과의 상호작용을 테스트할 수 있습니다.
유연한 교체 가능성:

데이터베이스, 메시지 큐, 웹 프레임워크 등을 쉽게 교체할 수 있습니다.
시스템의 일부를 대체하거나 확장할 때 최소한의 코드 변경으로 가능하게 합니다.
확장성과 유지보수성:

명확한 모듈화와 책임 분리를 통해 확장과 유지보수가 용이합니다.
새로운 기능 추가 시 기존 코드에 영향을 주지 않도록 분리된 모듈에서 개발할 수 있습니다.
단점
복잡한 패키지 구조:

여러 레이어와 모듈로 구성되기 때문에 초기 설정과 구조화가 복잡할 수 있습니다.
작은 프로젝트에서는 과도한 설계로 보일 수 있으며, 불필요한 복잡성을 초래할 수 있습니다.
클래스와 인터페이스의 증가:

각 역할을 명확히 하기 위해 클래스와 인터페이스의 수가 증가합니다.
이로 인해 코드베이스가 방대해지고, 개발자가 구조를 이해하는 데 시간이 더 걸릴 수 있습니다.
초기 개발 속도 저하:

초기 설계와 설정에 더 많은 시간이 소요될 수 있습니다.
헥사고날 아키텍처의 원리를 이해하고 적용하는 데 학습 곡선이 존재합니다.
추상화의 오버헤드:

인터페이스와 어댑터를 통해 시스템을 추상화하다 보면 약간의 성능 오버헤드가 발생할 수 있습니다.
그러나 대부분의 경우, 이는 현대적인 하드웨어와 최적화된 런타임 환경에서 큰 문제는 아닙니다.
결론
헥사고날 아키텍처는 큰 규모의 복잡한 시스템에서 특히 유용하며, 확장성과 유지보수성 측면에서 많은 장점을 제공합니다. 그러나 작은 프로젝트에서는 과도한 설계로 느껴질 수 있으며, 초기 설정과 학습에 더 많은 시간이 필요할 수 있습니다. 따라서 프로젝트의 규모와 복잡성을 고려하여 헥사고날 아키텍처를 적용하는 것이 좋습니다.
 