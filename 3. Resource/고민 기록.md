
### 트랜잭션 관련
- 쿠폰 발급 시스템 코드 예시

>[!warning] Call transactional methods via an injected dependency instead of directly via 'this'.

하나의 트랜잭션 내부에서 여러 메서드를 직접 호출할 경우, 트랜잭션 프록시가 아닌 this로 호출하게 되는 프록시 한계에 대한 소나규칙이었다

```java
@Service  
@RequiredArgsConstructor  
public class CouponIssueService {  
  
    private final CouponJpaRepository couponJpaRepository;  
    private final CouponIssueJpaRepository couponIssueJpaRepository;  
    private final CouponIssueRepository couponIssueRepository;  
    private final ApplicationEventPublisher applicationEventPublisher;  
  
    @Transactional  
    public void issueWithLock(long couponId, long userId) {  
        Coupon coupon = findCouponWithLock(couponId); // 💩
        coupon.issue();  
        saveCouponIssue(couponId, userId); // 💩
        publishCouponEvent(coupon);  
    }

	// ..

}
```


기능 상에 문제가 없었지만, 굳이 자기자신 (`CouponIssueService`) 주입받아 호출하거나, CQRS를 적용하는게 코드 복잡도만 올라가고 크게 성능개선할 것 까지는 없다는 생각이 들었다.

Chat-GPT에게 내 생각을 말했고, 아래와 같이 답변을 했다 
```text
맞습니다! 소나큐브 규칙에 대한 경고는 **물리적인 트랜잭션**을 하나로 관리하는 것보다는 **논리적으로 여러 트랜잭션을 분리하여 관리**하는 것이 이점이 있을 수 있다는 의미로 볼 수 있습니다. 하지만, **트랜잭션을 분리한다고 해서 반드시 성능이 개선되거나 코드 품질이 좋아지는 것은 아닙니다**. 복잡성만 증가하고 실제로 **문제가 되지 않는 상황에서는 굳이 분리할 필요가 없다**는 점을 고려하는 것이 중요합니다.

트랜잭션을 분리할 때의 주요 **이점**은 다음과 같습니다:

1. **단일 책임 원칙(SRP, Single Responsibility Principle)**을 충족시킬 수 있습니다. 각각의 서비스가 독립적으로 하나의 책임을 맡게 되어 테스트와 유지보수에서 유리할 수 있습니다.
2. 트랜잭션의 **전파**가 명확하게 적용되어, 예외가 발생했을 때 롤백 범위가 분리되어 안정적인 시스템을 구축할 수 있습니다.
3. 분리된 트랜잭션은 각각 독립적으로 롤백하거나 커밋할 수 있어 **에러 처리**를 좀 더 세밀하게 할 수 있습니다.

하지만 **트랜잭션을 분리하면 복잡도 증가**와 **추가적인 관리 오버헤드**가 있을 수 있고, **성능이 떨어질 수 있습니다**. 실제로 트랜잭션을 하나로 묶어 관리하는 것이 더 간단하고 직관적인 경우도 많습니다.

### **결론**

- **트랜잭션 분리의 장점**은 여러 개의 독립적인 트랜잭션을 통해 **에러 처리**나 **비즈니스 로직의 독립성**을 증가시킬 수 있지만, **복잡성**이 추가된다는 단점도 있습니다.
- 현재 **문제가 되지 않는 상황**에서는 굳이 트랜잭션을 분리할 필요가 없을 수 있으며, **단일 트랜잭션으로 관리**하는 방식도 충분히 좋습니다.
- 트랜잭션을 분리하는 것과 관련된 **소나큐브 경고**를 신경 쓸 때는, 그 경고가 실제로 **비즈니스 로직에 영향을 미치는 문제**인지, 아니면 단순히 코드 스타일에 대한 문제인지도 고려할 필요가 있습니다.
```


