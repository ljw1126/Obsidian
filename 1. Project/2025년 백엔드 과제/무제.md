
### '??' (Nullish coalescing operator)
>[!iinfo] 
>널 병합 연산자(`??`)는 왼쪽 피연산자가 null 또는 undefined일때 오른쪽 피연산자를 반환하는 연산자를 반환하는 논리 연산자이다.


```typescript 
private parseSeqEvent(log: string): { seq: string; tail: string } | null {
	const matched = log.match(/^(-?\d+)-(.*)$/) ?? [];
	return matched ? { seq: matched[1]!, tail: matched[2]! } : null;
}
```
- [MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing)

### '??=' (Nullish coalescing assignment)

>[!info]
>널 병합 할당 연산자(`??=`) 또는 논리적 널 할당은 왼쪽 피연산자가 nullish (null 또는 undefined) 일때, 오른쪽 피연산자를 평가하여 왼쪽에 할당합니다. 

```typescript 
// missingUpdateStrategy.ts
private groupBy<T>(arr: T[], keyFn: (t: T) => string): Record<string, T[]> {
	return arr.reduce<Record<string, T[]>>((acc, item) => {
		const key: string = keyFn(item);

		(acc[key] ??= []).push(item);

		return acc;
	}, {});
}
```

```typescript
const a = { duration: 50 };

a.speed ??= 25;
console.log(a.speed);
// Expected output: 25

a.duration ??= 10;
console.log(a.duration);
// Expected output: 50

```
- [MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment)


### record, map 

```typescript 
// sequenceDuplicateStrategy.ts
private getOrCreate<K, V>(map: Map<K, V>, key: K, create: () => V): V {
	if (!map.has(key)) {
		map.set(key, create());
	}

	return map.get(key)!;
}
```
- [DEV community](https://dev.to/lea_abraham_7a0232a6cd616/typescript-record-vs-map-whats-the-difference-and-when-to-use-each-50oj)

### `[]`, `{}` 할당 차이 

### for .. in, for .. of 차이

### `[[key]]`


### Map, Set, List 초기화 방법 

### interface better than type

### any 지양 

### non-null 지양
