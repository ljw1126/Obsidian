> 냄새 나면 당장 갈아라. - 켄트 백 할머니의 육아 원칙

'적용 방법'을 아는 것과 '제때적용'할 줄 아는 것은 다르다
리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지 않게 중요하다.

리택터링할 '시점'을 설명하는데 '냄새(smell)'란 표현을 사용

하지만 리팩터링을 언제 멈춰야 하는지를 판단하는 정확한 기준을 제시하지는 않을 것이다. 
우리 경험에 따르면 숙련된 사람의 직관만큼 정확한 기준은 없다. 
-> 종료 기준보다 리팩터링하면 해결할 수 있는 문제의 징후를 제시

## 3.1 기이한 이름(Mysterious Name)

함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경써서 이름을 지어야 한다.

**리팩터링 종류**
- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기

이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

## 3.2 중복 코드 (Duplicated Code)

- 함수 추출하기
- 문장 슬라이드하기
	- 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다
- 메서드 올리기
	- 같은 부모로부터 파생된 서브 클래스들에 코드 중복이 있다면, 각자 따로 호출되지 않도록 부모로 옮긴다

// 탬플릿 메소드 패턴이 생각난다 메서드 올리기는..

## 3.3 긴 함수 (Long Function)

간접 호출(indirection) 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.

함수가 길수록 이해하기 어렵다
- 요즘 언어 프로세스 안에서의 함수 호출 비용을 거의 없애 버렸다
- 하지만 읽는 사람 입장에서 함수가 하는 일을 파악하기 위해 스크롤 피로감 증가

짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 
함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다. 

예. 주석을 달아야 할 만한 부분은 무조건 함수로 만든다
- 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 의도(intention)가 드러나게 짓는다
- 이렇게 함수로 묶는 코드는 여러 줄일 수 있고 단 한 줄일 수도 있다.
- 심지어 원래 코드보다 길어지더라도 함수로 뽑는다.
- 단, **함수 이름에 코드의 목적을 드러낸다**
- 즉, <u>'무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다</u>

기본적으로 함수 추출하기가 99% 차지

매개변수와 임시 변수가 너무 많은 경우 
- **임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를 줄임
- **매개변수 객체 만들기**, **객체 통째로 넘기기**로 매개변수의 수를 줄임
- 여전히 많다면 **함수를 명령으로 바꾸기**를 고려       //?

추출할 코드 덩어리를 찾는 방법
- 좋은 방법은 주석을 참고하는 것
	- 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려있는 경우가 많다
	- 함수로 빼내고, 함수 이름을 주석 내용을 토대로 지음
- 조건문이나 반복문도 추출 대상의 실마리 제공
	- **조건문 분해하기**         // ?
	- **함수 추출하기** : switch문의 각 case 본문을 함수 호출문 하나로 바꾼다
	- **조건부 로직을 다형성으로 바꾸기** : 같은 조건을 기준으로 나뉘는 switch문이 여러 개인 경우
- 반복문
	- 반복문 자체를 추출해서 독립된 함수로 만든다
	- **반복문 쪼개기** : 추출할 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있을 수도 있다.


## 3.4 긴 매개변수 목록 (Long Parameter List)
종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 때
- **매개변수를 질의 함수로 바꾸기로 제거**할 수 있다 // ?

데이터 구조에서 값들을 뽑아 각각 별개의 매개변수로 전달하는 경우
- **객체 통째로 넘기기**로 원본 데이터 구조 그대로 전달

항상 함께 전달되는 매개변수들은 
- **매개변수 객체로 만들기**로 하나로 묶는다

함수의 동작 방식을 정하는 플래그 역할의 매개변수는 
- **플래그 인수 제거하기**로 없애준다  // ??

클래스는 매개변수 목록을 줄이는 데 효과적인 수단이다. 특히 여러 개의 함수가 특정 매개변수들의 값을 공통 사용할 때 유용하다
- 이 경우 **여러 함수를 클래스로 묶기** 이용하여 공통 값들을 클래스의 필드로 정의한다  // ?





---
- 부록B를 참고하여 코드가 풍기는 냄새(악취)가 무엇인지 찾자

