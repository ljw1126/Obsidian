
### 2.1 리팩터링 정의

>[!note] 리팩터링(명사)
>소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

ex. 함수 추출하기, 조건부 로직을 다형성으로 바꾸기

>[!note] 리팩터링(동사)
>소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩토링 기법을 적용해서 소프트웨어를 재구성하다


p80
리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.

리팩터링은 재구성 중 특수한 한 형태로 본다. 한 번에 바꿀 수 있는 작업을 수 많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 오히려 비효율적이라고 생각하기 쉽다. 하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다.
-> 목적에 따라 분리함으로써 가독성 향상, 테스트 용이 효과 생각된다

리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐이다. <u>리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.</u>
-> 좋은 단위 테스트를 만드는 것은 또 다른 영역이다

반면 성능 최적화는 오로지 속도 개선에만 신경쓴다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오해야 한다
-> 부하 테스트와 모니터링은 리팩토링과 다른 영역으로 생각된다

### 2.2 두 개의 모자
- 켄트벡은 소프트웨어를 개발할 때 목적을 **두 개의 모자**에 비유했다
- "기능 추가 모자"
	- 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다
- "리팩터링 모자"
	- 기능 추가는 절대 하지 않기도 다짐
	- 오로지 코드 재구성에만 전념한다


### 2.3 리팩터링하는 이유
리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다. 하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다. 
-> 결국 리팩터링도 **도구**이다

1. 리팩터링하면 소프트웨어 설계가 좋아진다
- 단순히 코드만 봐서는 설계를 파악하기 어렵다
- 같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다
	- 코드가 길수록 실수 없이 수정하기 어렵다
	- 이해해야 할 코드량이 늘어난다
	- 중복 코드가 발생하고 결국 유지보수 문제가 발생가능하다
- 리팩터링을 통해 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.

2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다
- 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다 
	- 보이스카웃 규칙이 생각난다
- 코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다
- 리팩터링은 코드가 더 잘 읽히게 도와준다

3. 리팩터링하면 버그를 쉽게 찾을 수 있다
- 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것은 곧바로 코드에 반영하게 된다.
- 리팩터링은 견고한 코드를 작성하는데 무척 효과적이다
>[!note] 켄트 벡
>"난 뛰어난 프로그래머가 아니에요 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요"


4. 리팩터링하면 프로그래밍 속도를 높일 수 있다
- 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 풀질 향상에 직결된다
- 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.
- 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다
- 코드가 명확하면 버그를 만들 가능성이 준다
- 버그를 만들더라도 디버깅이 쉽다
- 내부 품질이 뛰어난 코드 베이스는 새 기능 구축을 돕는 견고한 토대가 된다

// p84 이미지 추가

### 2.4 언제 리팩터링해야 할까?
>[!note] 3의 법칙, 돈 로버츠
>1. 처음에는 그냥 한다
>2. 비슷한 일을 두 번째로 하게 되면(중복 발생), 일단 계속 진행한다 
>3. 비슷한 일을 세 번째 하게 되면 리팩터링한다

**준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
리팩터링하기 가장 좋은 시점은 코드 베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서 구조를 살짝 바꾸면 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾는다.

버그를 잡을 때도 마찬가지다. 오류를 일으키는 코드가 세 곳에 복제되어 펴져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다. 또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다.


**이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
나는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. (ex. 조건부 로직, 함수 이름)

어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누기도한다. 그러면 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다.

<u>랄프 존슨은 이런 초기 단계의 리팩터링을 밖을 잘 내다보기 위한 창문 닦기에 비유한다. 코드를 분석할때 리팩터링을 해보면, 그렇지 않더라도 도달하지 못했을 더 깊은 수준까지 이해하게 된다</u>


**쓰레기 줍기 리팩터링**
간단히 수정할 수 잇는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 **쓰레기 줍기 리팩터링**이다

캠핑 규칙이 제안하듯, 항상 처음 왔을 때 보다 깔끔하게 정리하고 떠나자. 코드를 훓어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이다. 리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨드리지 않는다는 사실이다.


**계획된 리팩터링과 수시로 하는 리팩터링**
개발에 들어가지 전에 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 프로그래밍 과정에 자연스럽게 녹인 것이다.

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른 일을 하는 중에 처리한다.

<u>예컨대 매개변수화하거나 개별 함수로 나누는 기준을 정한다.</u> 어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다. 이렇게 상황이 변해 기준을 변경해야 할 때 코드가 이미 깔끔하다면 리팩터링 하기가 더 쉽다.

<u>오랫동안 사람들은 소프트웨어 개발이란 뭔가 "추가"하는 과정으로 여겼다. (..) 하지만 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 "수정"하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다. 소프트웨어 개발을 끝이 있는 작업으로 보면 안된다. 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다.</u>

버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을 들은 적이 있다. (p89)
-> 개인적으로도 기능 개발과 리팩토링을 분리하기도 어려웠고, 문맥상 흐름이 끊길 수 있기 때문에 같이 해왔다. 

리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고 여러분의 팀에 적합한 방식을 실험을 통해 찾아내야 한다


**오래 걸리는 리팩토링**
팀 전체가 대규모 리팩터링에 매달리는 데는 회의적이다. 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 떄가 많다.

<u>리팩터링이 코드를 깨뜨리지 않는다는 장점을 활용하는 것이다. 일부를 변경해도 모든 기능이 항상 올바르게 동작한다.</u>


**코드 리뷰에 리팩터링 활용하기**
코드 리뷰를 하면 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다

리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다. 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해 볼 수 있기 때문이다.
-> 테스트가 있고, 기존 기능은 유지하되 일부를 변경한다면 효과적일 듯하다


**관리자에게는 뭐라고 말해야 할까?**
기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이런 상황에 있는 이들에게는 "리팩터링한다고 말하지 말라"고 조언하겠다.

소프트웨어 개발자는 프로다. 프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 경험상 리팩터링하면 소프트웨어를 빠르게 만드는데 아주 효과적이다.
- 새 함수를 추가하려 하기 전
- 버그를 수정하기 위해 소프트웨어 작동 방식을 이해해야 할 때
이때도 리팩터링 부터 하는 편이 가장 빠르다. 일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 구체적인 방법은 개발자가 판단해야 한다.

<u>프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.</u>
-> 내가 진짜 힘든 직업을 선택했구나 싶다 


**리팩터링하지 말아야 할 때**
외부 API 다루듯 호출해서 쓰는 코드라면 지저분 해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링 해야 효과를 제대로 볼 수 있다.

리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.


### 2.5 리팩터링 시 고려할 문제

**새 기능 개발 속도 저하**
- 오해 : 리팩터링 때문에 새 기능을 개발 하는 속도가 느려진다

>[!note] 리팩터링의 궁긍적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

새 기능을 구현해 넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다.
반면 내가 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다면 판단되면 리팩터링하지 않는 편이다. 떄로는 어떻게 개선해야 할지 확실히 떠오르지 않아서 리팩터링을 미루기도 한다.

가장 빠지기 쉬운 위험한 오류는 리팩터링을 '클린 코드'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것이다. 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. <u>오로지 경제적인 이유로 하는 것이다.</u>  // **현실적이다**
- 기능 추가 시간을 줄인다
- 버그 수정 시간을 줄인다

이를 명확히 이해하는 개발자, 관리자, 고객이 많아질수록 앞에서 본 소프트웨어 개발 진행 그래프에서 '좋은 설계'곡선을 더 많이 볼 수 있다.


**코드 소유권**
//??


**브랜치**
- 켄트벡 : CI + 리팩터링 = 익스트림 프로그래밍


**테스팅**
- 테스트를 통해 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다.
- IDE 리팩터링만으로 테스트 없이 리팩터링 가능


**레거시 코드**
레거시 시스템을 파악할 때 리팩터링이 굉장히 도움이 된다. 
이러한 희망찬 스토리에 테스트가 없다는 사실이 찬물을 끼얹는 때가 많다. 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.

테스트를 갖추고 있더라도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다. 내가 선호하는 방식은 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이다. (..) 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 코드를 훓게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이니 당연히 이렇게 해야 한다.


**데이터베이스**
데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다

예로 필드 이름을 바꿀 때
- 첫 번쨰 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지 x
- 기존 필드와 새 필드를 동시에 업데이트 하도록 설정
- 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다
- 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업은 모두 끝낸다면, 예전 필드를 삭제한다

이렇게 데이터베이스를 변경하는 방식은 **병렬 수정(또는 팽창-수축**)의 일반적인 예다


### 2.6 리팩터링, 아키텍처, 애그니(YAGNI)
이 책의 부재처럼 리팩터링으로 기존 코드의 설계를 개선할 수 있다. 하지만 앞에서 말했듯이 레거시 코드는 변경하기 어려울 때가 많다. 특히 탄탄한 테스트가 뒷받침해주지 못하면 더더욱 어렵다.

리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다. 
-> 완벽한 설계는 존재하지 않고, 모든 요구사항을 사전에 파악하여 설계는 불가능하다

p101
리팩터링을 활용하면 다르게 접근할 수 있다. 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 단, 이 요구를 멋지게 해결하도록 설계한다.

예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움될 때가 많다. 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가한다. 

이런 식으로 설계하는 방식을 간결한 설계, 점진적 설계, YAGNI(you arent going to need it의 줄일말) 등으로 부른다
-> 결국에 경험에 의거해 미리 리팩터링하면 좋을지, 아니면 말지를 고려해야 한다는거 아닐까


### 2.7 리팩터링과 소프트웨어 개발 프로세스
- TDD (테스트 주도 개발) = 자가 테스트 코드 + 리팩터링

지속적 통합을 적극 권장하는 이유도 바로 이 때문이다. 지속적 통합을 적용하면 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다.

자가 테스트 코드 역시 지속적 통합의 핵심 요소다. 따라서 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘한다.

p103
지금까지의 설명이 다소 간단해 보일 수 있지만 실무에 적용하기는 만만치 않다. 어떤 방법으로 하든 소프트웨어 개발은 여러 사람과 기계가 복잡하게 엮여 상호작용하는 까다로운 일이다.
지금까지 소개한 접근법은 이 복잡도를 다루는 데 효과적이라고 검증된 것이다. 물론 어떠한 접근법이든지 충분한 연습과 실력이 뒷받침돼야 한다.


### 2.8 리팩터링과 성능
'직관적인 설계 vs 성능'은 중요한 주제다

리팩터링하면 소프트웨어가 느려질 수도 있는건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다. 하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.

p105
<u>성능에 대한 흥미로운 사실은 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다. </u>그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다. 속도를 높이기 위해 투자한 시간을 모두 날리는 행위다.

성능 개선을 위한 세번째 방법은 이 '90%의 시간은 낭비'라는 통계에서 착안한 것이다. 즉 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.

① 프로파일러로 프로그램을 분석하여 병목(시간, 공간) 지점 찾는다  
② 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은 노력으로 훨씬 큰 효과를 볼 수 있다.
③ 최적화할때 리팩터팅처럼 작은 단계로 나눠서 진행한다
④ 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다
⑤ 성능이 개선되지 않았다면 수정 내용을 롤백한다.

리팩터링을 잘 해두면 성능 최적화할 때 도움이 된다
① 성능 튜닝에 투입할 시간을 확보할 수 있다
② 리팩터링이 잘 되어 있는 프로그램은 프로파일러 통해 성능을 더 세밀하게 분석할 수 있다. 
-> 지적해주는 코드 범위가 더 좁아지고, 더 튜닝하기 쉬워진다.

결과적으로 
<u>리팩터링은 성능 좋은 소프트웨어를 만드는데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다</u>


---

**일부 내용 요약**

2.2 두 개의 모자를 읽고 습관이 좋지 않았구나라는 사실을 깨닫는다
- 기능 추가 모자와 리팩터링 모자를 둘다 쓰고 했었던거 같다
- TDD 사이클이라면 실패하는 테스트를 생성 > 기능 구현 > 리팩토링 분리해서 해야 하지만 실무에서는 기능 구현과 리팩토링을 동시에 하다보니 횡설수설한 느낌이 아니었나 싶다

p85
20년 전만 해도 설계를 잘하려면 코딩을 시작하기 전에 설게부터 완벽히 마쳐야 한다는 것이 정설이었다. 

인식하고 습관을 형성하는

리팩터링을 하게 되면 
- 소프트웨어 설계가 좋아진다
- 소프트웨어 이해가 쉬워진다
- 버그를 쉽게 찾을 수 있다
- 프로그래밍 속도를 높일 수 있다

리팩터링을 해야 할 시기
- 기회가 될 때
	- 코드 베이스에 **새로운 기능을 추가하기 직전**에 현재 구조를 바꿔 다른 작업을 하기 쉬워질 부분을 찾는다
	- 네이밍을 명확히 하거나, 함수를 잘게 나누거나
	- 간단히 수정할 수 있는건 즉시 고치고, 시간이 걸리는 건 메모만 남기고 이후 처리
		- 리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다
		- 그래서 작업을 나누어 몇 달에 걸쳐 진행하더라도 한 순간에 코드가 깨지지 x
- 수시로
	- 프로그래밍 과정에 자연스럽게 녹인다
	- 리팩터링 일정을 따로 잡지 않고, 기능을 추가하거나 버그를 잡는 동안 함께 수행한다
- 오래 걸리는 대규모의 경우
	- 몇 주에 걸쳐 조금씩 해결하는게 효과적일 때가 많다
	- 누군든지 리팩터링 해야 할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선한다
	- 이는 리팩터링이 코드를 꺠뜨지 않고 일부를 변경해도 모든 기능이 항상 올바르게 동작하기 때문에 가능하다

기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이런 상황에 있는 이들에게는 "리팩터링한다고 말하지 말라"고 조언하겠다.

이 부분에서 결국 프로 개발자는 기능을 구현을 빠르게 하는 것이고, 기능 구현을 가장 빨리 하기 위한 방법이 리팩터링이라는데.. 힘든 직업을 선택했다는 생각만 들었다. 그래도 어찌하겠는가.. 이번 기회에 잘 익혀두면 좋지 않겠는가


리팩터링을 하는 이유는 <u>오로지 경제적인 이유로 하는 것이다.</u> p93
- 클린 코드나 바람직한 엔지니어 습관으로 정당화해서는 위험
실무 상황에 있어 단 한번도 경험해본적이 없다. 내 부분 기간에 내에 기능 구현을 알아서 해주기만 바랄뿐 코드 베이스의 상태에 대해서는 신경쓰지 않았다. 오히려 거기서 다양한 시도를 해볼 수 도 있지 않았나 싶으면서도 나온게 다행이라 생각된다.




// 캠핑장 규칙 언급



p80
>[!note] 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했던"라고 한다면, 십중팔구 리팩터링한 것이 아니다
>

p88
>[!note] 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.


---
**참고**
- 레거시 코드 활용 전략(에이콘, 2018, p98)
	- 테스트 커버리지가 낮은 오래된 코드 베이스를 리팩터링하는 방법을 다루고 있다
- 리팩터링 워크북(인사이트, 2006, 윌리엄 웨이크) 
	- 리팩터링 연습에 주력한 책 추천
	- 리팩터링을 충분히 연습할 수 있도록 다양한 예제를 제공
- 패턴을 활용한 리팩터링(인사이트, 2011, 조슈아케리에프스키)
	- 핵심 디자인 패턴을 골라, 코드를 해당 패턴으로 재구성하기 위해 리팩터링하는 방법 다룸
- 깃허브 지원 페이지 
	- https://github.com/WegraLee/Refactoring
- https://refactoring.com/
