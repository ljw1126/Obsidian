
## 섹션4. 객체 지향 기본 원칙 
### 객체 지향 설계 원칙 
`설계(design)`
- 코드를 배치하는 방식
	- 수행하는 기능은 동일하지만 구조가 다른 
- 설계가 필요한 이유 
	- 요구사항이 변경될 때 코드를 쉽고 안전하게 수정하기 위해
		- 객체 지향 설계가 필요한 이유와 같다

✅ `객체 지향 설계 원칙(수정하기 위한 코드 설계를 만들 수 있는 원칙)`
- 1. 객체의 `행동`을 `먼저` 구현하고 행동에 필요한 `데이터`를 `나중에` 선택하다
	- 객체 사이의 협력이 설계 된다
- 2. 협력에 필요한 `행동`을 `먼저` 결정하고 행동에 적합한 `객체`를 `나중에` 선택하라
	- 클래스의 내부 구조가 완성된다
	- 협력하는 객체가 데이터에 의존하지 않도록 만든다.

절차적인 설계는 사용될 문맥과 독립적으로 데이터 설계
- 이 경우 getter/setter를 통해 데이터의 내부 구조가 그대로 외부에 노출
- 데이터가 변경이 되면 데이터를 사용하는 프로세스도 변경된다
	- 사이드 이팩트

개선방법
- 데이터를 책임지는 로직을 데이터로 이동
- 데이터, 로직을 한 모듈에 담는다
	- 변경의 영향을 지역화
	- 이를 `책임의 이동`이라 부른다

설계 개선 
- 코드를 배치하는 방식을 변경했다
- 왜? 코드를 더 쉽게 수정하기 위해서 

> 데이터 대신 행동에 의존

>외부 객체가 데이터가 아니라 행동에 의존하도록 만든다.
>데이터 보다 행동을 먼저 만든다는게 이런 의미

> 데이터가 아닌 행동에 초점 

외부 객체의 요청에 응답하기 위해 (객체의 행동이) 필요

고립된 상태에서 클래스의 행동을 결정하는 것은 불가능 
- 문맥을 고려하지 않고 설계한 고립된 상태는 절차적인 설계가 만들어진다 

> - 협력에 필요한 요청에서 행동을 결정
> - 행동을 수행하는데 적합한 객체를 결정

> ✅ 결론적으로 행동에 초점을 두고, 그 이후에 행동을 구현하는데 적합한 데이터를 결정한다

객체가 다른 객체에게 도움을 요청하도록 하는 과정을 `협력(Collaboration)`이라고 한다

>[!note] 진정한 객체 지향 설계는 제한된 문맥 안에서 설계 된다
- 절차지향은 문맥을 고려하지 않는다. 
- 코드의 품질에 영향을 미친다. 


> [!note] 객체들의 협력 관계를 기반으로 어플리케이션을 설계하는 것을 책임 주도 설계라고 부른다 (Responsibility0-Driven Design)


### 책임 주도 설계 

**객체지향 설계 흐름**
1. `협력`을 위한 문맥 결정
2. 필요한 `책임`을 식별
3. 책임을 수행할 `객체`를 선택
4. `책임(메서드)` 구현
5. `데이터(필드)` 결정

**책임(Responsibility)**
- 협력에 참여하기 위해 객체가 수행하는 행동
	- DiscountPolicy의 책임 : "할인 요금을 계산하라"
	- DiscountCondiition의 책임 : "할인 여부를 판단하라"

객체가 수행할 책임을 기반으로 객체 사이의 관계를 설계 하는 것을 `책임 주도 설계(Responsibility-Driven Design)`

책임은 `행동` 관점이다
- `하는 것 (Doing)`
	-   객체를 생성하거나 계산을 하는 등의 스스로 하는 것
	- 다른 객체(협력자)의 행동을 시작시키는 것
	- 다른 객체(협력자)의 활동을 제어하고 조절하는 것
- `아는 것 (Knowing)`
	- private로 캡슐화된 상태(데이터)에 관해 아는 것
	- 관련된 객체(협력자)에 관하여 아는 것
	- 자신이 유도하거나 계산할 수 있는 것(상태와 협력자)에 관하여 아는 것

> 정보에 대해 답할 수 있어야 한다


✅ 책임이 중요한 이유
- 객체 내부의 세부사항과 관련된 결정을 뒤로 미루고 (외부) 객체들의 협력 구조에 초점을 두게 됨
- 협력이 책임을 설계하는 문맥을 제공한다
	- 그럼 협력을 설계하는데 필요한 문맥은 어디서?
		- 결론은, 시스템 외부에 제공해야 하는 기능이 협력을 위한 문맥으로 제공 (`애플리케이)

영화 예매 기능을 객체 지향적으로 설계한다는 의미는 
영화 예매 기능을 객체들 사이의 협력으로 구현하고
협력에 필요한 행동을 수행하는데 필요한 객체들을 선택하는 것을 의미 

✅ 시스템이 제공해야 하는 기능을 시스템에 전달된 요청으로 간주한다
- 영화 예매 기능을 수행하는데 필요한 객체들의 협력을 설계한다
- 여기서 핵심은!
	- `애플리케이션 기능을 기반으로 객체의 협력을 설계 하는 것이다`


**책임주도 설계 살펴보기**
- 애플리케이션이 제공할 기능 파악 
- 애플리케이션의 기능 요구사항을 시스템의 책임으로 변환 
- 시스템의 책임을 객체의 책임으로 변환
- 책임을 담당할 적절한 객체 선택
- 객체의 책임 일부를 수행하기 위해 외부의 도움이 필요하다면 다른 객체에게 도움을 요청
- 이 요청을 또 다른 객체의 책임으로 변환
- 책임을 담당할 적절할 객체 선택


**핵심은 책임 할당(이게 어려움)**
- 어떤 객체에게 책임을 할당할 것인가?


**객체 지향 설계 순서**
- (런타임에 수행할) 객체 협력에서 (컴파일 타임의) 클래스 구조의 순서로 진행
	- 런타임에 객체의 책임과 협력을 설계


**책임 주도 설계의 문맥**
- 애플리케이션의 기능이 협력을 위한 문맥을 제공한다
- 협력이 책임을 위한 문맥 제공한다

> ✅ 문맥을 제한하면 수정하고 유지보수하기 쉬운 객체를 얻게 된다


### 표현적 차이 줄이기

**알고리즘과 절차적인 설계**
- 하나의 클래스에 비즈니스 로직이 전부 모여 있다

**알고리즘과 객체 지향 설계**
- 알고리즘의 각 단계를 책임 관점에서 여러 객체로 분배
	- 알고리즘을 배치하는 방식이 절차적인 방식과 다름 
		- `책임 할당` 방식으로 분배

> 협력 안에 책임이 있다.


`도메인 모델 (Domain Model)`
- 도메인에 중요한 개념과 관계의 집합 
- 객체지향 설계의 재료로 사용되는 도메인의 추상화
- 추상화에 대해 지하철 노선도 예시를 듦
	- 의도적으로 이해하는데 필요한 부분만 남겨두고(단순화)하고 나머지는 버린다

**도메인 모델의 용도**
- 후보 객체를 찾을 때 **가장 먼저 참고**하는 개념과 관계의 집합

> 이 부분 다시 듣기


도메인 모델을 참고하는 이유 
- 표현적 차이를 줄이기 위해서다
- `표현적 차이(Representational Gap)`
	- 도메인에 대한 개념적 모델과 소프트웨어 구현 사이의 거리
	- 도메인과 코드 구조가 다르다면 표현적 차이가 크다라고도 표현한다
	- 객체 지향적으로 작성된 코드는 표현적 차이가 작다✅ 

표현적 차이를 줄이는 이유는 
- 변경하기 쉬운 유연한 설계를 만들기 위해


안정적인 도메인
- 비즈니스 본질이 유지되면서 요구사항이 바뀐다면 세부적인 내용이 바뀔 수 있지만 도메인의 본질적인 개념과 기본 구조는 비즈니스가 바뀌지 않는 이상 그대로 유지
- 안정적인 도메인의 구조에 기반한 코드 구조 역시 변경에 안정적이다
	- 요구사항이 변경되더라도 코드의 전체적인 구조는 유지


은유를 통한 개념의 연상
- 표현적 차이를 줄이기 위해
- 은유는 책임을 수행하는 데 적합한 객체를 도메인 개념과 연결해준다

> 따라서 도메인 개념을  은유하도록 클래스를 만들면 도메인 개념과 관련된 요구사항이 변경되었을 때 수정할 코드를 찾기 쉬워진다.✅


명사의 가치
- 객체 지향은 명사를 이용해 동사를 묶을 수 있는 개념적 틀을 제공

명사를 이용해서 동사 묶기 
- 요구사항이 변경될 때 어떤 클래스를 수정할지 쉽게 찾을 수 있음

> 동사(책임) -> 명사(도메인 개념) = 클래스 (명사 + 동사)


**GRASP**
- General Responsibility Assignment Software Pattern
	- 일반적인 책임 할당을 위한 소프트웨어 패턴 
- 📚 `APPLYING UML AND PATTERNS`
- 9가지 패턴이 있고 6개를 먼저 살펴본다
	- CREATOR : 창조자
	- INFORMATION EXPERT : 정보 전문가
	- LOW COUPLING : 낮은 결합도
	- HIGH COHESION : 높은 응집도
	- POLYMPORPHISM : 다형성
	- PROTECTED VARIATIONS : 변경 보호

**CRC 카드**
- 켄트벡과 다른 한 사람이 만듦
- 책임과 협력을 표현하기 위한 객체 지향 설계 도구
- Candidate (후보, 역할 또는 객체)
- Responsibility (책임)
- Collaborator (협력자)

> CRC 클래스는 런타임에 동적인 객체를 의미
 

퀴즈 
Q. 강의에서 강조하는 객체지향 설계 원칙의 가장 주된 목표는 무엇일까요?
A. 요구사항 변경 시 코드 수정의 용이성 확보 

> 객체지향 설계 원칙은 요구사항 변화 시 코드를 쉽고 안전하게 수정하는 데 초점을 맞춥니다. 설계의 모든 원칙은 변화에 대응하기 위한 것이죠.


Q. 객체지향 설계 과정에서 객체의 '데이터'보다 먼저 고려하고 결정해야 할 것은 무엇일까요?
A. 객체가 외부에 제공할 행동 또는 책임 

> 객체지향 설계에서는 외부에서 필요한 행동/책임을 먼저 정의하고, 그 후에 행동을 지원하는 데이터를 결정합니다. 데이터 의존성을 줄여 수정이 쉬워집니다.


Q. 책임 주도 설계에서 객체 간 '협력'을 설계할 때 가장 초기 문맥(Context)을 제공하는 것은 무엇인가요?
A. 시스템이 외부에 제공하는 기능 

> 책임 주도 설계는 시스템이 외부에 제공하는 기능에서 시작하여, 이 기능을 수행하기 위한 객체들의 협력을 설계합니다. 기능이 협력 설계의 출발점입니다.


Q. 객체가 외부에 제공하는 책임은 크게 두 가지 범주로 나눌 수 있습니다. 이 두 가지는 무엇일까요?
A. 행위(Doing)와 정보 제공 (Knowing)

> 객체의 책임은 '무엇을 하는가(Doing)'와 '무엇을 아는가(Knowing)'의 두 가지로 나뉩니다. 외부에 정보를 제공하는 것도 중요한 책임입니다.


Q. 객체지향 설계에서 '표현적 차이(Expressive Difference)'란 무엇을 의미하는 것일까요?
A . 현실 도메인의 개념과 소프트웨어 코드 구조 간의 차이 

> 표현적 차이는 현실의 도메인 개념과 소프트웨어 코드 구조 사이의 간극을 말합니다. 이 차이를 줄이면 도메인 변화를 코드에 반영하기 쉬워집니다.


---

## 섹션5. 책임 할당하기

### 정보와 책임 할당 - 정보 전문가 

**상영 예매 협력 설계**
- 도메인의 구조를 기반으로 시스템 내의 상태 변경 가시화
- ex. 상영을 예매하라 (애플리케이션 기능)
- 애플리케이션의 실행 결과는 `예매`이다
- 애플리케이션 기능의 실행은 **도메인 개념의 상태나 구조를 변경**


> 시스템의 책임을 객체의 책임으로 변환한다.
> 어떤 객체에게 책임을 할당할지 결정 
> 책임을 맡아서 예매를 수행해야 한다

GRASP 패턴에서 
- 책임을 할당하기 가장 좋은 방법은 `INFORMATION EXPERT(정보 전문가)` 패턴이다
	- 반복적인 `문제`와 `해결방법`을 제공한다
		- **문제** : 책임을 객체에게 할당하는 일반적인 원칙은 무엇인가?
		- **해결 방법** : 책임을 수행하는데 필요한 정보를 가장 많이 알고 있는 객체에게 할당하라

정보(Information) // 개념 ?
- 정보는 데이터가 아니라 `행동` (외부에 제공해야 하는)
- 어떤 상태를 수정하거나 질문에 답하는 `책임`

> 데이터가 먼저가 아니라 행동이 먼저다


**정보 전문가 찾기**
- 어떤 상태를 수정하거나 질문에 답할 수 있는 객체에게 `책임 할당`
- ex. 저 학생은 몇 살인가요?
	- 가장 많은 정보를 알고 있는 `학생`이 대답하는 것이 자연스러움 
		- 나이를 대답할 책임을 학생에게 할당

>객체 지향은 다수가 동의하는 모델을 만드는 과정이다

> 객체 지향은 공통의 멘탈 모델(도메인 모델)을 만드는 과정이기도 하다


**정보 전문가에게 행동 할당하기**
- 정보는 `책임`의 관점에서 `행동`으로 선언

**데이터는 내부 구현**
- 행동을 정상적으로 실행할 수 있다면 어떤 방식으로 구현하든 무방

**다른 객체와 협력해서 나이를 제공**
- 생활기록부 객체를 이용해 나이 조회

**정보는 데이터가 아니다**
- 서로 다른 유형의 데이터를 이용해서 동일한 정보를 제공한다
	- 나이에 대한 정보를 3가지로 제공할 수 있다
		- 직접 값을 가지고 있다가 반환
		- 생년월일에서 빼기 연산 통해 구하거나
		- 다른 객체에게 요청하거나
	- 이 3가지 방식은 인터페이스는 동일하지만 구현을 다르다고 표현할 수 있다

✅ 객체는 내부 상태보다 행동(책임)이 중요하다

✅ 행동을 먼저 결정한 후 데이터를 결정하라
- 행동을 먼저 결정해서 외부의 객체가 인터페이스에 의존하도록 한다
- 그러면 객체 내부의 구현을 변경하더라도 외부에 영향을 미치지 않을 수 있다

> 상영 객체가 예매에 대한 책임을 가진다 

애매하다면 
- `목적어에 책임을 할당하라`
	- 상영(목적어)을 예매하다 
		- reserve(screening)
	- 상영(주어)이 예매하다 
		- screening.reserve()
- 목적어를 주어로 만들면 객체가 능동적으로 행동할 수 있다.

**상영을 예매할 책임 할당 (CRC 카드)**
- 영상 참고.

### 설계 트레이드 오프 - 창조자와 낮은 결합도 


### 설계 트레이드 오프 - 높은 응집도 


### 유연한 설계 - 다형성 


### 결합도 낮추기 - 변경 보호

