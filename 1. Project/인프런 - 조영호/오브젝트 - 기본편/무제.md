
## 섹션4. 객체 지향 기본 원칙 
### 객체 지향 설계 원칙 
`설계(design)`
- 코드를 배치하는 방식
	- 수행하는 기능은 동일하지만 구조가 다른 
- 설계가 필요한 이유 
	- 요구사항이 변경될 때 코드를 쉽고 안전하게 수정하기 위해
		- 객체 지향 설계가 필요한 이유와 같다

✅ `객체 지향 설계 원칙(수정하기 위한 코드 설계를 만들 수 있는 원칙)`
- 1. 객체의 `행동`을 `먼저` 구현하고 행동에 필요한 `데이터`를 `나중에` 선택하다
	- 객체 사이의 협력이 설계 된다
- 2. 협력에 필요한 `행동`을 `먼저` 결정하고 행동에 적합한 `객체`를 `나중에` 선택하라
	- 클래스의 내부 구조가 완성된다
	- 협력하는 객체가 데이터에 의존하지 않도록 만든다.

절차적인 설계는 사용될 문맥과 독립적으로 데이터 설계
- 이 경우 getter/setter를 통해 데이터의 내부 구조가 그대로 외부에 노출
- 데이터가 변경이 되면 데이터를 사용하는 프로세스도 변경된다
	- 사이드 이팩트

개선방법
- 데이터를 책임지는 로직을 데이터로 이동
- 데이터, 로직을 한 모듈에 담는다
	- 변경의 영향을 지역화
	- 이를 `책임의 이동`이라 부른다

설계 개선 
- 코드를 배치하는 방식을 변경했다
- 왜? 코드를 더 쉽게 수정하기 위해서 

> 데이터 대신 행동에 의존

>외부 객체가 데이터가 아니라 행동에 의존하도록 만든다.
>데이터 보다 행동을 먼저 만든다는게 이런 의미

> 데이터가 아닌 행동에 초점 

외부 객체의 요청에 응답하기 위해 (객체의 행동이) 필요

고립된 상태에서 클래스의 행동을 결정하는 것은 불가능 
- 문맥을 고려하지 않고 설계한 고립된 상태는 절차적인 설계가 만들어진다 

> - 협력에 필요한 요청에서 행동을 결정
> - 행동을 수행하는데 적합한 객체를 결정

> ✅ 결론적으로 행동에 초점을 두고, 그 이후에 행동을 구현하는데 적합한 데이터를 결정한다

객체가 다른 객체에게 도움을 요청하도록 하는 과정을 `협력(Collaboration)`이라고 한다

>[!note] 진정한 객체 지향 설계는 제한된 문맥 안에서 설계 된다
- 절차지향은 문맥을 고려하지 않는다. 
- 코드의 품질에 영향을 미친다. 


> [!note] 객체들의 협력 관계를 기반으로 어플리케이션을 설계하는 것을 책임 주도 설계라고 부른다 (Responsibility0-Driven Design)


### 책임 주도 설계 

**객체지향 설계 흐름**
1. `협력`을 위한 문맥 결정
2. 필요한 `책임`을 식별
3. 책임을 수행할 `객체`를 선택
4. `책임(메서드)` 구현
5. `데이터(필드)` 결정

**책임(Responsibility)**
- 협력에 참여하기 위해 객체가 수행하는 행동
	- DiscountPolicy의 책임 : "할인 요금을 계산하라"
	- DiscountCondiition의 책임 : "할인 여부를 판단하라"

객체가 수행할 책임을 기반으로 객체 사이의 관계를 설계 하는 것을 `책임 주도 설계(Responsibility-Driven Design)`

책임은 `행동` 관점이다
- `하는 것 (Doing)`
	-   객체를 생성하거나 계산을 하는 등의 스스로 하는 것
	- 다른 객체(협력자)의 행동을 시작시키는 것
	- 다른 객체(협력자)의 활동을 제어하고 조절하는 것
- `아는 것 (Knowing)`
	- private로 캡슐화된 상태(데이터)에 관해 아는 것
	- 관련된 객체(협력자)에 관하여 아는 것
	- 자신이 유도하거나 계산할 수 있는 것(상태와 협력자)에 관하여 아는 것

> 정보에 대해 답할 수 있어야 한다


✅ 책임이 중요한 이유
- 객체 내부의 세부사항과 관련된 결정을 뒤로 미루고 (외부) 객체들의 협력 구조에 초점을 두게 됨
- 협력이 책임을 설계하는 문맥을 제공한다
	- 그럼 협력을 설계하는데 필요한 문맥은 어디서?
		- 결론은, 시스템 외부에 제공해야 하는 기능이 협력을 위한 문맥으로 제공 (`애플리케이)

영화 예매 기능을 객체 지향적으로 설계한다는 의미는 
영화 예매 기능을 객체들 사이의 협력으로 구현하고
협력에 필요한 행동을 수행하는데 필요한 객체들을 선택하는 것을 의미 

✅ 시스템이 제공해야 하는 기능을 시스템에 전달된 요청으로 간주한다
- 영화 예매 기능을 수행하는데 필요한 객체들의 협력을 설계한다
- 여기서 핵심은!
	- `애플리케이션 기능을 기반으로 객체의 협력을 설계 하는 것이다`


**책임주도 설계 살펴보기**
- 애플리케이션이 제공할 기능 파악 
- 애플리케이션의 기능 요구사항을 시스템의 책임으로 변환 
- 시스템의 책임을 객체의 책임으로 변환
- 책임을 담당할 적절한 객체 선택
- 객체의 책임 일부를 수행하기 위해 외부의 도움이 필요하다면 다른 객체에게 도움을 요청
- 이 요청을 또 다른 객체의 책임으로 변환
- 책임을 담당할 적절할 객체 선택


**핵심은 책임 할당(이게 어려움)**
- 어떤 객체에게 책임을 할당할 것인가?


**객체 지향 설계 순서**
- (런타임에 수행할) 객체 협력에서 (컴파일 타임의) 클래스 구조의 순서로 진행
	- 런타임에 객체의 책임과 협력을 설계


**책임 주도 설계의 문맥**
- 애플리케이션의 기능이 협력을 위한 문맥을 제공한다
- 협력이 책임을 위한 문맥 제공한다

> ✅ 문맥을 제한하면 수정하고 유지보수하기 쉬운 객체를 얻게 된다


### 표현적 차이 줄이기

**알고리즘과 절차적인 설계**
- 하나의 클래스에 비즈니스 로직이 전부 모여 있다

**알고리즘과 객체 지향 설계**
- 알고리즘의 각 단계를 책임 관점에서 여러 객체로 분배
	- 알고리즘을 배치하는 방식이 절차적인 방식과 다름 
		- `책임 할당` 방식으로 분배

> 협력 안에 책임이 있다.


`도메인 모델 (Domain Model)`
- 도메인에 중요한 개념과 관계의 집합 
- 객체지향 설계의 재료로 사용되는 도메인의 추상화
- 추상화에 대해 지하철 노선도 예시를 듦
	- 의도적으로 이해하는데 필요한 부분만 남겨두고(단순화)하고 나머지는 버린다

**도메인 모델의 용도**
- 후보 객체를 찾을 때 **가장 먼저 참고**하는 개념과 관계의 집합

> 이 부분 다시 듣기


도메인 모델을 참고하는 이유 
- 표현적 차이를 줄이기 위해서다
- `표현적 차이(Representational Gap)`
	- 도메인에 대한 개념적 모델과 소프트웨어 구현 사이의 거리
	- 도메인과 코드 구조가 다르다면 표현적 차이가 크다라고도 표현한다
	- 객체 지향적으로 작성된 코드는 표현적 차이가 작다✅ 

표현적 차이를 줄이는 이유는 
- 변경하기 쉬운 유연한 설계를 만들기 위해


안정적인 도메인
- 비즈니스 본질이 유지되면서 요구사항이 바뀐다면 세부적인 내용이 바뀔 수 있지만 도메인의 본질적인 개념과 기본 구조는 비즈니스가 바뀌지 않는 이상 그대로 유지
- 안정적인 도메인의 구조에 기반한 코드 구조 역시 변경에 안정적이다
	- 요구사항이 변경되더라도 코드의 전체적인 구조는 유지


은유를 통한 개념의 연상
- 표현적 차이를 줄이기 위해
- 은유는 책임을 수행하는 데 적합한 객체를 도메인 개념과 연결해준다

> 따라서 도메인 개념을  은유하도록 클래스를 만들면 도메인 개념과 관련된 요구사항이 변경되었을 때 수정할 코드를 찾기 쉬워진다.✅


명사의 가치
- 객체 지향은 명사를 이용해 동사를 묶을 수 있는 개념적 틀을 제공

명사를 이용해서 동사 묶기 
- 요구사항이 변경될 때 어떤 클래스를 수정할지 쉽게 찾을 수 있음

> 동사(책임) -> 명사(도메인 개념) = 클래스 (명사 + 동사)


**GRASP**
- General Responsibility Assignment Software Pattern
	- 일반적인 책임 할당을 위한 소프트웨어 패턴 
- 📚 `APPLYING UML AND PATTERNS`
- 9가지 패턴이 있고 6개를 먼저 살펴본다
	- CREATOR : 창조자
	- INFORMATION EXPERT : 정보 전문가
	- LOW COUPLING : 낮은 결합도
	- HIGH COHESION : 높은 응집도
	- POLYMPORPHISM : 다형성
	- PROTECTED VARIATIONS : 변경 보호

**CRC 카드**
- 켄트벡과 다른 한 사람이 만듦
- 책임과 협력을 표현하기 위한 객체 지향 설계 도구
- Candidate (후보, 역할 또는 객체)
- Responsibility (책임)
- Collaborator (협력자)

> CRC 클래스는 런타임에 동적인 객체를 의미
 

퀴즈 
Q. 강의에서 강조하는 객체지향 설계 원칙의 가장 주된 목표는 무엇일까요?
A. 요구사항 변경 시 코드 수정의 용이성 확보 

> 객체지향 설계 원칙은 요구사항 변화 시 코드를 쉽고 안전하게 수정하는 데 초점을 맞춥니다. 설계의 모든 원칙은 변화에 대응하기 위한 것이죠.


Q. 객체지향 설계 과정에서 객체의 '데이터'보다 먼저 고려하고 결정해야 할 것은 무엇일까요?
A. 객체가 외부에 제공할 행동 또는 책임 

> 객체지향 설계에서는 외부에서 필요한 행동/책임을 먼저 정의하고, 그 후에 행동을 지원하는 데이터를 결정합니다. 데이터 의존성을 줄여 수정이 쉬워집니다.


Q. 책임 주도 설계에서 객체 간 '협력'을 설계할 때 가장 초기 문맥(Context)을 제공하는 것은 무엇인가요?
A. 시스템이 외부에 제공하는 기능 

> 책임 주도 설계는 시스템이 외부에 제공하는 기능에서 시작하여, 이 기능을 수행하기 위한 객체들의 협력을 설계합니다. 기능이 협력 설계의 출발점입니다.


Q. 객체가 외부에 제공하는 책임은 크게 두 가지 범주로 나눌 수 있습니다. 이 두 가지는 무엇일까요?
A. 행위(Doing)와 정보 제공 (Knowing)

> 객체의 책임은 '무엇을 하는가(Doing)'와 '무엇을 아는가(Knowing)'의 두 가지로 나뉩니다. 외부에 정보를 제공하는 것도 중요한 책임입니다.


Q. 객체지향 설계에서 '표현적 차이(Expressive Difference)'란 무엇을 의미하는 것일까요?
A . 현실 도메인의 개념과 소프트웨어 코드 구조 간의 차이 

> 표현적 차이는 현실의 도메인 개념과 소프트웨어 코드 구조 사이의 간극을 말합니다. 이 차이를 줄이면 도메인 변화를 코드에 반영하기 쉬워집니다.


---

## 섹션5. 책임 할당하기

### 정보와 책임 할당 - 정보 전문가 

**상영 예매 협력 설계**
- 도메인의 구조를 기반으로 시스템 내의 상태 변경 가시화
- ex. 상영을 예매하라 (애플리케이션 기능)
- 애플리케이션의 실행 결과는 `예매`이다
- 애플리케이션 기능의 실행은 **도메인 개념의 상태나 구조를 변경**


> 시스템의 책임을 객체의 책임으로 변환한다.
> 어떤 객체에게 책임을 할당할지 결정 
> 책임을 맡아서 예매를 수행해야 한다

GRASP 패턴에서 
- 책임을 할당하기 가장 좋은 방법은 `INFORMATION EXPERT(정보 전문가)` 패턴이다
	- 반복적인 `문제`와 `해결방법`을 제공한다
		- **문제** : 책임을 객체에게 할당하는 일반적인 원칙은 무엇인가?
		- **해결 방법** : 책임을 수행하는데 필요한 정보를 가장 많이 알고 있는 객체에게 할당하라

정보(Information) // 개념 ?
- 정보는 데이터가 아니라 `행동` (외부에 제공해야 하는)
- 어떤 상태를 수정하거나 질문에 답하는 `책임`

> 데이터가 먼저가 아니라 행동이 먼저다


**정보 전문가 찾기**
- 어떤 상태를 수정하거나 질문에 답할 수 있는 객체에게 `책임 할당`
- ex. 저 학생은 몇 살인가요?
	- 가장 많은 정보를 알고 있는 `학생`이 대답하는 것이 자연스러움 
		- 나이를 대답할 책임을 학생에게 할당

>객체 지향은 다수가 동의하는 모델을 만드는 과정이다

> 객체 지향은 공통의 멘탈 모델(도메인 모델)을 만드는 과정이기도 하다


**정보 전문가에게 행동 할당하기**
- 정보는 `책임`의 관점에서 `행동`으로 선언

**데이터는 내부 구현**
- 행동을 정상적으로 실행할 수 있다면 어떤 방식으로 구현하든 무방

**다른 객체와 협력해서 나이를 제공**
- 생활기록부 객체를 이용해 나이 조회

**정보는 데이터가 아니다**
- 서로 다른 유형의 데이터를 이용해서 동일한 정보를 제공한다
	- 나이에 대한 정보를 3가지로 제공할 수 있다
		- 직접 값을 가지고 있다가 반환
		- 생년월일에서 빼기 연산 통해 구하거나
		- 다른 객체에게 요청하거나
	- 이 3가지 방식은 인터페이스는 동일하지만 구현을 다르다고 표현할 수 있다

✅ 객체는 내부 상태보다 행동(책임)이 중요하다

✅ 행동을 먼저 결정한 후 데이터를 결정하라
- 행동을 먼저 결정해서 외부의 객체가 인터페이스에 의존하도록 한다
- 그러면 객체 내부의 구현을 변경하더라도 외부에 영향을 미치지 않을 수 있다

> 상영 객체가 예매에 대한 책임을 가진다 

애매하다면 
- `목적어에 책임을 할당하라`
	- 상영(목적어)을 예매하다 
		- reserve(screening)
	- 상영(주어)이 예매하다 
		- screening.reserve()
- 목적어를 주어로 만들면 객체가 능동적으로 행동할 수 있다.

**상영을 예매할 책임 할당 (CRC 카드)**
- 영상 참고.

### 설계 트레이드 오프 - 창조자와 낮은 결합도 

**CREATOR (창조자) 패턴**
- 문제 
	- 새로운 인스턴스를 생성하는 책임을 어떤 객체에게 할당할 것인가
- 해결 방법
	- 다음 중 한 가지라도 만족할 경우 A의 인스턴스를 생성할 책임을 B에게 할당하라 
		- 1. B가 A를 포함하거나 참조한다
		- 2. B가 A를 기록한다
		- 3. B가 A를 긴밀하게 사용한다
		- 4. B가 A를 초기화하는 데 필요한 정보를 알고 있다

> 상영과 영화 두 개 중 누가 더 많이 해당하는가를 비교 

> 생성이라는 문맥에 특화된 INFORMATION EXPERT(정보 전문가) 패턴
- CREATOR 패턴의 다른 측면 
	- 밀접한 관계를 가지는 객체에 생성 책임을 할당하라 


`결합도`
- 객체들이 서로 연관되어 있는 정도 

**LOW COUPLING(낮은 결합도)**
- 문제 
	- 어떻게 낮은 의존성을 유지하고, 변경에 따른 영향을 줄이면서 재사용성을 높일 수 있을까?
- 해결방법 
	- 설계의 전체적인 결합도를 낮게 유지할 수 있도록 책임을 할당하라 

> 창조자 패턴의 해결방법 1,2,3은 낮은 결합도, 4.는 정보 전문가 패턴을 나타냄

>[!note] 낮은 결합도가 중요한 이유 
>수정하기 쉬운 설계를 만들기 위해 


영화에 책임을 할당할 경우
- 상영과 예메 둘다 수정이 발생할 수 있다 (결합도가 높으니)

>[!note] 결합도는 설계 결정을 평가하기 위한 기준
>결합도가 낮은 설계를 선택하라 


### 설계 트레이드 오프 - 높은 응집도

**HIGH COHESION (높은 응집도) 패턴**
- 문제 
	- 어떻게 낮은 결합도를 유지하고, 변경에 따른 영향을 줄이면서, 재사용성을 높일 수 있을까?
- 해결방법
	- 높은 응집도를 유지하도록 책임을 할당하라 

**높은 응집도의 의미** 
- 한 요소의 책임들이 얼마나 강력하게 관련되고 집중되어 있는가 
- `연광성 높은 책임`들을 가지면서 너무 많은 일을 하지 않는 객체에 책임 할당 
	- 반대 의미는 **LOW COHESION(낮은 응집도)**


**가격 계산 책임 할당**
- 영화 가격을 계산할 책임을 담당할 객체는 ?
	- 상영은 아닌거 같다.

> 책임 할당을 위한 가장 기본 패턴은 INFORMATION EXPERT(정보 전문가) 패턴 사용


**INFORMATION EXPERT(정보 전문가)**
- 문제 
	- 책임을 객체에게 할당하는 일반적인 원칙은 무엇인가?
- 해결방법
	- 책임을 수행하는데 필요한 정보를 가장 많이 알고 있는 객체에게 할당해라

영화의 정가에 대해 알고 있는 후보는 ? 
- `영화` 가 적합
	- 영화는 `할인 정책`과 `할인 조건`을 참조하고 있으므로 

> 가격 계산을 위한 정보 전문가는 `영화`이다. (CRC 카드)

> [!note] 높은 응집도가 중요한 이유 
> 수정하기 쉬운 설계를 만들기 위해
- 높은 응집도와 낮은 결합도는 설계의 평가 기준📌
	- 따라서 `정보 전문가 패턴`에 따라 책임을 할당할 때 마다 높은 응집도와 낮은 결합도라는 목표를 달성할 수 있는지. 더 좋은 대안은 없는지 확인하면서 진행하길 바람 
- 설계의 본질
	- **트레이드 오프 (Trade-off) 활동**이다




### 유연한 설계 - 다형성 
- 영화 (`Movie`)
- 할인 정책 (`Discount Policy`)

**응집도 관점에서 설계 트레이드 오프 하기**
- 한 요소의 책임들이 얼마나 강력하게 관련되고 집중되어 있는가
- 연관성 높은 책임들을 가지면서 너무 많은 일을 하지 않는 객체에 책임 할당

> 응집도가 낮으면 코드를 이해하고 수정하기가 어려워진다
- DiscountPolicy가 금액/비율 할인 모두를 책임질 때 (계산 메서드)
	- 할인 정책이라는 공통점은 같지만, 두 메서드가 사용하는 변수가 상이하다
	- 서로 상관이 없는 두 로직을 포함하고 있어서 응집도가 낮다고 할 수 있다. 

> 새로운 중복 할인 정책을 추가하게 된다면 응집도가 낮을 때 어떤 문제가 발생할까?
- 중복 할인 정책을 추가하는 가장 간단한 방법은 DiscountPolicy에 메서드를 추가한다
	- 응집도가 낮기 때문에 발생하는 현상✅
- 또한, 할인 정책을 사용하는 클라이언트 코드 (Movie)에서는 중복 할인 정책을 처리하기 위해 조건 분기가 늘어 날 수 밖에 없다.💩 (변경의 여파)
	- 할인 정책을 추가할때 Movie도 변경 
		- 낮은 응집도와 높은 결합도 문제의 결과 

**변경에 취약한 설계**
- Ripple Effect : 파급 효과 

> GRASP에서는 이러한 문제에 적합한 패턴을 제공한다. 바로 `다형성(POLYMORPHISM)` 패턴이다. 
- **문제** : 
	- 타입을 기반으로 유사하지만 서로 다르게 행동할 때 (ex. 할인 정책)
		- 금액/비율 할인 정책은 서로 다른 타입이다
		- 할인 요금을 타입에 따라 다른 방식으로 계산
	- 조건문을 사용하지 않고 변하는 행동을 어떻게 처리할 것인가?
		- before. 타입 추가를 통해 행동을 확장하기 위한 기존 코드 수정이 필요
			- 다형성 패턴이 해결하는 문제가 이것이다.
- **해결방법** :
	- **다형적인 메시지를 이용**해서 `행동이 변하는 타입들에게 각 행동을 다루기 위한 책임을 할당`하라
		- 서로 다른 책임이 하나의 후보 안에 함께 뭉쳐있다면(DiscountPolicy), 유사해보이지만 서로 다른 책임을 서로 다른 타입의 객체에 할당하라
			- 1. **금액으로 할인**하는데 필요한 정보를 알고 있는 **금액 할인 정책**에 할당
			- 2. **비율로 할인**하는데 필요한 정보를 알고 있는 **비율 할인 정책**에 할당
	- 타입별 할인 정책 객체를 분리했는데 Movie는 여전히 조건문을 사용해서 분기 처리
		- DI를 사용하지 않고, 구현 객체를 직접 선언하는 예제 설명 중
		- 중복 할인 정책 추가시 결합도 상승 및 코드 내부 수정이 발생
		- **다형적인 메시지를 이용**해서 높은 결합도 문제를 해결할 수 있다. (다음 강의에 계속)


### 결합도 낮추기 - 변경 보호

**메시지(Message)**
- 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단 
- 객체는 다른 객체에게 협력을 요청하기 위해 메시지를 전송
	- ex. Movie객체가 DiscountPolicy에서 `할인을 계산하라`는 **메시지 전송 (Message Sending)**
		- 비율 할인을 계산하라 , 금액 할인을 계산하라
- 책임을 수행하는 **방법**은 다르지만 두 객체는 영화의 입장에서 동일한 **책임**을 수행한다
	- 타입이 뭔지 신경 쓸 필요가 없다.
	- <u>책임이 동일하면 메시지를 통일하는게 좋다</u>
- **다형적인 메시지** : 동일한 요청, 타입에 따라 다른 행동, 동일한 결과


**PROTECTED VARIATIONS(변경 보호 패턴 - GRASP)**
- 문제 : 
	- 요소들의 변화나 불안정한 요소가 다른 요소에 해로운 영향을 미치지 않도록 할 수 있을까?
- 해결방법:
	- 변화가 예상되거나 불안정한 지점을 식별하고, 그 주위에 안정적인 인터페이스 또는 추상화를 형성하도록 책임을 할당하라


변하는 부분은 할인 정책 타입
영화를 타입 변화에 대해 보호한다. 
할인정책 (인터페이스) 추가 한다 (안정적인 추상화, 일반적인 추상화)
안정적인 추상화 뒤로 변하는 타입을 숨긴다.


**다형성 Polymorphism**
> `메시지가 동일`하더라도 수신한 `객체의 타입에 따라` 실제로 수행하는 `행동이 달라지는` 능력
- 다형성은 다른 타입에 의한 대체 가능성을 의미 (`런타임에 대체`)

**역할 Role**
- 다른 것으로 **대체**할 수 있는 **책임의 집합**
	- Discount Policy 할인 정책 인터페이스 == **역할**로 표기

**객체와 역할**
- 같을 수도 있고 다를 수도 있다
- 한 종류의 객체만 요청에 응답하면 객체와 역할은 동일하다
- 만약 여러 종류의 객체가 대체할 수 있다면 객체와 역할은 동일하지 않다. 
	- 역할은 객체를 대체할 수 있는 추상화를 의미한다.
		- ex. DiscountPolicy 인터페이스 

✅ **책임 주도 설계 구성 요소**
> 역할(Role), 책임(Responsibility), 협력 (Collaboration)
- Movie 와 Discount 간의 협력
- DiscountPolicy 인터페이스 == 역할 
	- 할인을 계산하라  == 책임 

> 할인 여부를 판단하기 위한 객체를 분리한다.
- 할인 조건(Discount Condition)
	- 순서 조건(Sequence Condition) : **조조** 상영인 경우, **10회** 상영인 경우
	- 기간 조건 (Period Condition) : **월요일 10 ~ 12시** 상영인 경우, **목요일 18 ~ 21시 상영**인 경우
- Movie가 할인 조건 두 객체에 의존하고 있어 결합도가 높다 
- 따러서 GRASP 적용 
	- POLYMORPHISM(다형성)과 PROTECTED VARIATIONS(보호된 변형) 적용 
	- 추상화, 메시지, 역할, 책임, 협력 등

> [!info] 정보 전문가 패턴에서 말하는 '정보'는 주로 무엇을 의미할까요?
> - 답) 객체가 외부에 제공하는 행동/기능
> - 정보 전문가 패턴에서 정보는 객체가 제공하는 행동을 의미해요. 내부 데이터 자체보다는 '무엇을 할 수 있는지'에 집중하며 책임을 할당하죠.



---

## 섹션6. 객체 지향 구현 

### 객체 구현하기 

✅ **객체 지향 설계 순서 (크게 2가지)**
- 1. 협력에 필요한 **행동**을 **먼저** 결정하고 행동에 적합한 **객체**를 **나중에** 선택하라
- 2. 객체의 **행동**을 **먼저** 구현하고 행동에 필요한 **데이터**를 **나중에** 할당하라
	- `1차 과제(node.js, ts, jest)가 생각난다. 행동을 먼저 구현하고 행동에 적합한 객체를 나중에 선택했었다.`

다형성 패턴 적용하기 (할인 정책)

역할(ex. 추상화된 인터페이스, DiscountPolicy 할인 정책) 구현하기 
	구체 클래스(오직 하나), 추상 클래스(여러 객체 + 코드 공유), 인터페이스 (코드 공유x 명세만 필요하다면) **(✅ 중요한 부분인거 같다.)** 

강의에서는 <u>추상 클래스로 DiscountPolicy를 구현</u>한다

절차적인 방식과 객체지향 방식의 차이 (Movie 객체 예시로)
- 절차적인 방식은 사용되는 문맥을 모르는 상태에서 추측에 기반해 getter/setter 추가
- 객체지향 방식은 협력을 설계하면서 꼭 필요한 경우에만 메서드 추가
	- 절차 보다 객체 지향이 변경에 유리하다

다형성 패턴 적용하기 (할인 조건)

클래스 다이어그램 

도메인 구조 

✅ 표현적 차이 줄이기 
- 두 구조가 유사하다는 것을 확인 
- 도메인 모델에 포함된 개념과 관계에 기반해 책임을 할당할 객체를 선택했기 때문이다
- 표현적 차이를 줄임으로써 요구사항 변경시 수정할 부분을 찾기가 쉽다.📌

✅ 객체 지향의 위임식(delegated) / 분산식(dispersed) 제어 스타일 
- 모든 제어가 프로세스를 구현한 코드로 집중되는 절차지향적인 방식과 달리 
- 객체지향 설계는 제어가 여러 객체 사이로 분배가 됩니다. 
- OOP 어플리케이션은 스스로가 책임지는 자율적인 객체들로 구성되기 때문에 어느 한 객체가 제어를 독점할 수 없습니다. 
- 객체는 자신이 할 수 없는 일이 있으면 그 일을 더 잘할 수 있는 객체에게 위임합니다.
- 이렇게 제어를 분산 시키면 수정하기 쉽고 더 유연한 설계를 얻을 수 있다. 
- 그리고 더 유연한 설계를 만들기 위해서는 메시지와 메서드의 차이점을 이해하는게 중요하다

### 예제. 객체 구현하기 

✅ **객체 지향 설계 순서 2가지)**
- 1. 협력에 필요한 **행동**을 **먼저** 결정하고 행동에 적합한 **객체**를 **나중에** 선택하라
- 2. 객체의 **행동**을 **먼저** 구현하고 행동에 필요한 **데이터**를 **나중에** 할당하라


### 메시지와 메서드의 분리 

할인 정책과 할인 조건 협력을 통해 살펴본다 

**메시지 message**
- 객체 사이의 의사소통 수단 
	- 다른 객체에게 책임 수행을 요청하는 커뮤니케이션 수단
	- ex. `할인 여부를 판단하라`

**메서드 method**
- 메시지를 처리하는 방법
	- 메시지를 수신한 타입별로(ex. 할인조건) 책임을 수행하는 방식
	- ex. `기간 할인 여부를 판단한다` 

**메시지와 메서드의 분리는 다형성의 기반**
다형성은 메시지와 메서드를 분리하고 런타임에 조합해서 다양한 종류의 객체들이 협력할 수 있도록 지원하는 OOP 매커니즘 

**메시지와 메서드를 분리하는 이유는?**
> 수정하기 쉬운 코드를 작성하기 위해 

**협력하는 객체 타입을 쉽게 변경**
- 협력하는 두 객체는 메시지에 대해서만 의존
- 메시지를 책임질 수 있는 어떤 타입의 객체라도 대체 가능

변경하기 쉬운 설계를 만들기 위해서는 
> 메시지를 먼저 결정하고 메시지를 수신할 객체를 나중에 선택한다.
- 객체 지향 설계 원칙 
	- 1. 협력에 필요한 **행동**을 **먼저** 결정하고 행동에 적합한 **객체**를 **나중에** 선택하라

작업에 필요한 메시지를 먼저 결정 

협력에 참여할 수 있는 객체 슬롯 개념
- 협력에 참여할 수 있는 **객체가 플러그인 되는 슬롯**
- 객체 타입을 미리 고정하지 않고 메시지에 맞춰서 타입을 결정

메시지에 맞춰서 인터페이스 선언 
- DiscountCondition 인터페이스를 구현한 객체는 협력에 참여할 수 있다
	- 구현체 : **인터페이스를 구현한 클래스 플러그인**

> 새로운 할인 조건이 추가되더라도 DiscountPolicy를 수정할 필요없다. 왜냐하면 할인 정책은 할인 조건의 인터페이스(메시지)만 의존하고 있기 때문이다.

변경하고 확장하기 쉬운 설계 
- 메시지 기반의 플러그인 가능한 설계 (유연한 설계)

메시지에 대한 의존 
- 협력을 요청하는 객체는 `메시지에만 의존`한다 
- DiscountPolicy는 `메시지`만 알고 객체의 타입은 알지 못한다. 
	- DiscountCondition 슬롯에는 `메시지`에 응답할 수 있는 어떤 객체라도 협력 가능하다

런타임에 메서드 결정 
- 요청을 수신한 객체는 타입에 따라 적절한 메서드 실행

동적 바인딩 Dynamic Binding
- 런타임에 메시지를 처리할 적절한 클래스와 메서드 탐색 
- 다형성이 실행될 수 있는 기술적인 메커니즘을 제공한다 

객체지향의 기반은 자율적인 객체 
- 객체는 `자신만의 방법`으로 책임을 수행 

> [!info] 자율적 autonomous
> 자기 스스로의 원칙에 따라 어떤 일을 하거나 자기 스스로를 통제하여 절제하는 것


메시지와 메서드 분리의 목적 
- 변경하고 확장하기 쉬운 설계
- 다음 시간에는 메시지와 메서드를 분리하기 위한 기법 몇가지를 살펴본다


### 유연하고 일관적인 협력 


### 예제. 유연하고 일관적인 협력 


### 애플리케이션 객체 추가하기 


### 예제. 애플리케이션 객체 추가하기




---




