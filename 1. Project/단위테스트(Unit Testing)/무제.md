
**예제 코드** 
- https://www.manning.com/books/unit-testing
- https://github.com/AcornPublishing/unit-testing

**xUnit documentation** 
- https://xunit.net/docs/getting-started/v3/getting-started


## 2장. 단위 테스트란 무엇인가
- Listing1과 Listing2의 차이
	- Listing1 : 인터페이스 사용하지 x, `고전 스타일`, 두 객체간 실제 동작 확인
	- Listing2 : 인터페이스 사용 o, `런던 스타일` , 두 객체간 상호작용 검사
### Dictionary 자료구조
🔖 [Dictionary<TKey,TValue> 클래스 (System.Collections.Generic) | Microsoft Learn](https://learn.microsoft.com/ko-kr/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0)

```c#
private readonly Dictionary<Product, int> _inventory = new Dictionary<Product, int>();

public int GetInventory(Product product)
{
	bool productExists = _inventory.TryGetValue(product, out int remaining);
	return productExists ? remaining : 0;
}

public void AddInventory(Product product, int quantity)
{
	if (_inventory.ContainsKey(product))
	{
		_inventory[product] += quantity;
	}
	else
	{
		_inventory.Add(product, quantity);
	}
}
```
- GetInventory에서 
	- product가 없으면 false에 remaining = 0이 할당
	- product가 있으면 true에 remaining에 value 값이 할당

> [!info] 테스트 대상 메서드(MUT, Method Under Test)는 테스트에서 호출한 SUT의 메서드다. MUT와 SUT는 흔히 동의어로 사용하지만, 일반적으로 MUT는 메서드를 가리키는 데 반해 SUT는 클래스 전체를 가리킨다 (p57)

>[!info] 목은 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역이다.


**테스트 대역과 목의 차이**
- `테스트 대역`은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어다.
- `목`은 그러한 의존성의 한 종류일 뿐이다.


**2.2 단위 테스트의 런던파와 고전파** (p64)

.. 불변 객체를 값 객체(value object) 또는 값(value)이라고 한다. 주요 특징은 각각의 정체성이 없다는 것이다. 즉, 내용에 의해서만 식별된다. 그 결과, 두 객체가 동일한 내용을 갖고 있다면 어떤 객체를 사용하든 상관없다. 즉, 이러한 인스턴스는 서로 바꿔 사용할 수 있다. 
(ex. 예제의 `enum Product`)


📚 [Entity vs Value Object: the ultimate list of differences · Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)

🧐 (p66) 모든 공유 의존성은 변경 가능하지만, 변경 가능한 의존성을 공유하려면 여러 테스트에서 재사용 돼야 한다 (?????)


## 3장. 단위 테스트 구조

### 3.1 단위 테스트를 구성하는 방법

**3.1.1 AAA 패턴 사용**
- `Arrange (준비)` : 테스트에 필요한 데이터 생성/준비, 객체 초기화, 상태/조건 설정
- `Act (실행)` : 테스트 대상 코드 (sut)를 호출하거나 실행
- `Assert (단언)` : 실행한 코드의 결과를 검증하고, 예상한 대로 동작하는지 확인

> ✅ BDD의 경우 `given` / `when` / `then`

🔖 [Unit test의 AAA 패턴(Arrange/Act/Assert)](https://codechacha.com/ko/unittest-aaa-pattern/)


**3.1.2 여러 개의 준비, 실행, 검증 구절 피하기**

**3.1.3 테스트 내 if 문 피하기**

**3.1.4 각 구절은 얼마나 커야 하는가?**
- `준비 구절이 가장 큰 경우`
	- ▶️ 같은 테스트 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출하는 것이 좋다
	- 🔖준비 구절에서 코드 재사용에 도움이 되는 두 가지 패턴으로 `오브젝트 마더(Object Mother) 패턴`과 `테스트 데이터 빌더 (Test Data Builder)`가 있다.
- `실행 구절이 한 줄 이상인 경우를 경계해라`
	- **실행 구절이 보통 코드 한 줄**이다
	- 실행 구절이 두 줄 이상인 경우 SUT의 공개 API에 문제가 있을 수 있다.
	- 이때 잠재적 모순으로부터 코드를 보호하는 행위를 `캡슐화(encapsulation)`라고 한다.

**3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가**
- SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버(equality member)를 정의하는 것이 좋다. ▶️ 그러면 단일 검증문으로 객체를 기대값과 비교 가능

**3.1.6 종료 단계는 어떤가**
- 대부분의 단위 테스트는 종료 구절이 필요x
- 단위 테스트는 프로세스 외부에 종속적이지 않으므로 처리해야 할 사이드 이펙트를 남기지 x
- 종료는 통합 테스트의 영역이다 ▶️ 3부에서 다룰 예정

**3.1.7 테스트 대상 시스템 구별하기**


### 3.2 xUnit 테스트 프레임워크 살펴보기
.NET에서 [xUnit](https://xunit.net/?tabs=cs) 대안으로 [NUnit](https://nunit.org/)이나 기본으로 제공하는 Microsoft MSTest 등을 선택할 수 있다. 
- xUnit을 선호하지만, NUnit을 사용할 수도 있다. 
- 이 두 프레임워크는 기능면에서 거의 비슷하다 
- 그러나 💩MSTest는 권장하지 않는다. 앞에 두 개보다 유연하지 않기 때문이다. 
	- 그리고 확실치 않지만, 마소 직원들조차 사용 x
	- ASP.NET Core 팀은 xUnit을 사용한다.
		- 이유는 NUnit보다 더 깨끗하고 간결해서.

### 3.3 테스트 간 테스트 픽스처 재사용
- 준비구절에서 코드를 재사용하는 것이 테스트를 줄이면서 단순화하기 좋은 방법이다

>[!info] 테스트 픽스처
>다음과 같이 두 가지 공통된 의미가 있다. 
>1. 테스트 실행 대상 객체다. 이 객체는 정규 의존성, 즉 SUT로 전달되는 인수다. DB에 있는 데이터나 하드 디스크의 파일일 수도 있다. 이러한 객체는 각 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다. 따라서 픽스처라는 단어가 나왔다.
>2. 다른 정의는 NUnit 테스트 프레임워크에서 비롯된다. NUnit에서 `[TextFixture]`는 테스트가 포함된 클래스를 표시하는 특성이다.


3.3.1 테스트 간의 높은 결합도는 안티 패턴이다. 

> 초기화 코드에 두 테스트가 결합도 높아진다는 내용

> 결론은 `테스트 클래스에 공유 상태를 두지 말아야 한다`


3.3.2 테스트 가독성을 떨어뜨리는 생성자 사용
- 준비 코드를 생성자로 추출할 때 단점은 테스트 가독성을 떨어뜨린다는 것이다.
	- 테스트만 보고 전체 그림을 볼 수 없다.
- 준비 로직이 별로 없더라도 테스트 메서드로 바로 옮기는 것이 좋다.
	- 그렇지 않으면 단순히 인스턴스를 만드는 것일까?
	- 아니면 다른 무언가가 환경 설정을 하는 것일까?
	- 독립적인 테스트는 이러한 불확실성을 두지 않는다.


3.3.3 더 나은 테스트 픽스처 재사용법
- 테스트 픽스처를 재사용할 때 생성자 사용이 최선의 방법은 아니다
	- `비공개 팩토리 메서드(private factory method)`를 고려하라!


### 3.4 단위 테스트 명명법 

**💩 저자 기준 도움이 되지 않는 명명법 중 하나**
> `[테스트 대상 메서드]_[시나리오]_[예상 결과]`
- 테스트 대상 메서드: 테스트 중인 메서드의 이름
- 시나리오 : 메서드를 테스트하는 조건
- 예상 결과 : 현재 시나리오에서 테스트 대상 메서드에 기대하는 것


p98
수수께끼 같은 이름은 .. 모두가 이해하는 데 부담이 된다. 테스트가 정확히 무엇을 검증하는지, 비즈니스 요구사항과 어떤 관련이 있는지 파악하려면 머리를 더 써야 한다. 별것 아닌 것처럼 뵐지도 모르지만, 시간이 지날수록 정신적으로 부담이 가중된다. 전체 테스트 스위트의 유지비가 천천히 늘어난다. 기능의 구체적인 내용을 잊어버린 채 테스트를 작성하거나 동료가 작성한 테스트를 이해하려고 할 때 특히 그렇다. 

다른 사람의 코드를 읽는 것은 이미 충분히 어렵다. 따라서 어떤 것이든 이해하는 데 도움이 된다면 상당히 유용할 것이다

```text
public void Sum_of_two_numbers() { } // ✅

publci void Sum_TwoNumbers_RetrunsSum() { } // 💩
```

> 저자 기준, 쉬운 영어로 작성한 위의 이름이 읽기 훨씬 간편하다고 느낌


3.4.1 단위 테스트 명명 지침
- 엄격한 명명 정책을 따르지 않는다. 
	- 복잡한 동작에 대한 높은 수준의 설명을 이러한 정책의 좁은 상자 안에 넣을 수 없다
	- 표현의 자유를 허용하자
- 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자
	- 도메인 전문가나 비즈니스 분석가가 좋은 예다
- 단어를 밑줄(undersocre, `_`) 표시로 구분한다 
	- 그러면 특히 긴 이름에서 가독성을 향상 시키는 데 도움이 된다

> [!info] 테스트 클래스 이름을 지정할 때, `[클래스명]Tests`
- 단위 테스트에서 단위는 동작의 단위지, 클래스의 단위가 아닌 것을 명심하자
- `[클래스명]Tests`에서 클래스는 동작 단위로 검증할 수 있는 진입점 또는 API로 여기자


3.4.2 예제: 지침에 따른 테스트 이름 변경

>[!info] 테스트명내에 sut를 포함하지 말라
>코드를 테스트하는 것이 아니라 애플리케이션 동작을 테스트하는 것이라는 점을 명심하자(p100)

`should be` 문구는 또 다른 일반적인 안티 패턴이다 ➡️ `is` 로 바꿔보자

마지막으로 기초 영문법을 지켜야 한다 (ex. 관사 추가)

> 최종적으로 테스트 대상인 애플리케이션 동작의 관점 중 하나를 설명한다


### 3.5 매개변수화된 테스트 리팩터링하기
- `parameterized test`

> [!info] C# .NET에서 `[InlineData(..)]`를 사용 + 그리고 `[Fact]` 대신 `[Theory]`를 사용


3.5.1 매개변수화된 테스트를 위한 데이터 생성
- C#에서는 모든 특성의 내용을 컴파일할 때 평가한다. 
	- 이때 컴파일러가 이해할 수 있는 값만 사용해야 한다. 
	- 즉, 다음과 같다 
		- 상수
		- 리터럴(literal)
		- `typeof()` 표현식
	- `[InlineData(DateTime.Now, false)]`와 같이 DateTime은 닷넷 런타임에 의존하고 있어 허용되지 않는다
	- 이를 해결하는 방법은 static provider 메서드를 사용한다
		- `[MemberData(nameof(공급자 static 메서드명))]`


### 3.6 검증문 라이브러리를 사용한 테스트 가독성 향상
- 저자는 `Fluent Assertions`를 선호한다 함
	- 숫자, 문자열, 컬렉션, 날짜 및 시간 등에 대해 검증할 수 있는 수많은 헬퍼 메서드를 제공함
	- 유일한 단점은 프로젝트에 의존성을 추가 해야 한다는 것이다

>[!note] 이러한 가독성의 이점으로 인해 OOP 패러다임은 일부 성공했다. OOP를 쓰면 이야기처럼 읽을 수 있는 방식으로 코드를 구성할 수 있다.


p108 요약📌


---

## 4장. 좋은 단위 테스트의 4대 요소


---
## 5장. 목과 테스트 취약성

---
## 6장. 단위 테스트 스타일
> 복잡한 도메인 로직을 어플리케이션 서비스에 위임하고, 거지서 더 나아가 함수형으로 리팩터링 하는게 인상 깊다


---
## 7장. 가치 있는 단위 테스트를 위한 리팩터링 


---
## 8장. 통합 테스트를 하는 이유

**📌 통합 테스트하기 위해 MSSQL이 필요하나 Mac m1에서는 설치 불가한 것으로 확인**
- docker container 중 mssql 2022 latest로도 설치 불가 
- 공식적으로 `Azure-sql-edge`를 설치하는 방식을 권장하여 이를 사용 
	- https://www.youtube.com/watch?v=9c7Ti2OcLZg

---
## 9장. 목 처리에 대한 모범 사례

✅ mock은 가장 끝 depth에 위치한 의존성에 적용하는 거다


---
### 용어
- 구체 클래스(concrete class) 🔖p59
- 공유 의존성, 비공개 의존성, 프로세스 외부 의존성 🔖p61
- 엔드 투 엔드 테스트(end-to-end-test) 🔖p75
- AAA 패턴 🔖p80
- SUT (System Under Test, 테스트 대상 시스템) 🔖p81
- 불변 위반 (invariant violation) 🔖 p86
- c# 키워드 
	- `internal`
	-  `params`(spread operator 같은), `out`(딕셔너리 자료구조에서 사용)
	- `struct` 
- 6장 예제에 메서드 시그니처를 풀어서 선언 가능하네
	-  `public (FileUpdate update, Error error) AddRecord(..) { .. }`
- 8장 
	- 앰비언트 컨텍스트(안티패턴, p308)
- 화이트 박스/ 블랙 박스 테스트 (p142)
- 런던파/고전파
- 코드오염(p193)
- 참조투명성 (p198)
- CanExecute/Execute 패턴 사용(p254)
- 험블 객체 패턴 (p266)
- 엠비언트 컨텍스트(p308)
- NHibernate (p346)
### 추천 자료
- 📚 [Entity vs Value Object: the ultimate list of differences · Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)
- TDD (p72)
	- 📗 테스트 주도 개발 (Test-Driven Development : By Example)
	- 📗 [Growing Object-Oriented Software Guided by Tests: About the Book](http://www.growing-object-oriented-software.com/)
- [저자 운영 사이트](https://enterprisecraftsmanship.com/)
	- https://unittestingcourse.com/
- Moq
- NSubstitute
- xUnit, NUnt, MSTest
- Fluent Assertions
- [함수형 프로그래밍](https://fsharpforfunandprofit.com/)
	- 스콧 블라신의 웹 사이트와 책을 참조 
- [발송전 도메인 이벤트 병합](https://enterprisecraftsmanship.com/posts/merging-domain-events-dispatching/)
	- 저자 글
- [OCP와 YAGNI](https://enterprisecraftsmanship.com/posts/ocp-vs-yagni)
- Growing Object-Oriented Software Guided by Tests
	- 스티브 프리먼, 냇 프라이스 도서 
	- 로깅 관련 : 지원로깅/진단로깅(p300)
- Dependency Injection:Priniciples, Practices, Patterns
	- 스티븐 반 듀르센, 마크 시먼 
	- 엠비언트 컨텍스트
- 마이그레이션 관련 
	- SQL 스크립트 : Flyway, Liquibase
	- FluentMigrator 라이브러리






