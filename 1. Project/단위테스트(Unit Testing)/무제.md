
**예제 코드** 
- https://www.manning.com/books/unit-testing
- https://github.com/AcornPublishing/unit-testing

**xUnit documentation** 
- https://xunit.net/docs/getting-started/v3/getting-started


## 2장. 단위 테스트란 무엇인가
- Listing1과 Listing2의 차이
	- Listing1 : 인터페이스 사용하지 x, `고전 스타일`, 두 객체간 실제 동작 확인
	- Listing2 : 인터페이스 사용 o, `런던 스타일` , 두 객체간 상호작용 검사
### Dictionary 자료구조
🔖 [Dictionary<TKey,TValue> 클래스 (System.Collections.Generic) | Microsoft Learn](https://learn.microsoft.com/ko-kr/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0)

```c#
private readonly Dictionary<Product, int> _inventory = new Dictionary<Product, int>();

public int GetInventory(Product product)
{
	bool productExists = _inventory.TryGetValue(product, out int remaining);
	return productExists ? remaining : 0;
}

public void AddInventory(Product product, int quantity)
{
	if (_inventory.ContainsKey(product))
	{
		_inventory[product] += quantity;
	}
	else
	{
		_inventory.Add(product, quantity);
	}
}
```
- GetInventory에서 
	- product가 없으면 false에 remaining = 0이 할당
	- product가 있으면 true에 remaining에 value 값이 할당

> [!info] 테스트 대상 메서드(MUT, Method Under Test)는 테스트에서 호출한 SUT의 메서드다. MUT와 SUT는 흔히 동의어로 사용하지만, 일반적으로 MUT는 메서드를 가리키는 데 반해 SUT는 클래스 전체를 가리킨다 (p57)

>[!info] 목은 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역이다.


**테스트 대역과 목의 차이**
- `테스트 대역`은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어다.
- `목`은 그러한 의존성의 한 종류일 뿐이다.


**2.2 단위 테스트의 런던파와 고전파** (p64)

.. 불변 객체를 값 객체(value object) 또는 값(value)이라고 한다. 주요 특징은 각각의 정체성이 없다는 것이다. 즉, 내용에 의해서만 식별된다. 그 결과, 두 객체가 동일한 내용을 갖고 있다면 어떤 객체를 사용하든 상관없다. 즉, 이러한 인스턴스는 서로 바꿔 사용할 수 있다. 
(ex. 예제의 `enum Product`)


📚 [Entity vs Value Object: the ultimate list of differences · Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)

🧐 (p66) 모든 공유 의존성은 변경 가능하지만, 변경 가능한 의존성을 공유하려면 여러 테스트에서 재사용 돼야 한다 (?????)


## 3장. 단위 테스트 구조

### 3.1 단위 테스트를 구성하는 방법

**3.1.1 AAA 패턴 사용**
- `Arrange (준비)` : 테스트에 필요한 데이터 생성/준비, 객체 초기화, 상태/조건 설정
- `Act (실행)` : 테스트 대상 코드 (sut)를 호출하거나 실행
- `Assert (단언)` : 실행한 코드의 결과를 검증하고, 예상한 대로 동작하는지 확인

> ✅ BDD의 경우 `given` / `when` / `then`

🔖 [Unit test의 AAA 패턴(Arrange/Act/Assert)](https://codechacha.com/ko/unittest-aaa-pattern/)


**3.1.2 여러 개의 준비, 실행, 검증 구절 피하기**

**3.1.3 테스트 내 if 문 피하기**

**3.1.4 각 구절은 얼마나 커야 하는가?**
- `준비 구절이 가장 큰 경우`
	- ▶️ 같은 테스트 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출하는 것이 좋다
	- 🔖준비 구절에서 코드 재사용에 도움이 되는 두 가지 패턴으로 `오브젝트 마더(Object Mother) 패턴`과 `테스트 데이터 빌더 (Test Data Builder)`가 있다.
- `실행 구절이 한 줄 이상인 경우를 경계해라`
	- **실행 구절이 보통 코드 한 줄**이다
	- 실행 구절이 두 줄 이상인 경우 SUT의 공개 API에 문제가 있을 수 있다.
	- 이때 잠재적 모순으로부터 코드를 보호하는 행위를 `캡슐화(encapsulation)`라고 한다.

**3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가**
- SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버(equality member)를 정의하는 것이 좋다. ▶️ 그러면 단일 검증문으로 객체를 기대값과 비교 가능

**3.1.6 종료 단계는 어떤가**
- 대부분의 단위 테스트는 종료 구절이 필요x
- 단위 테스트는 프로세스 외부에 종속적이지 않으므로 처리해야 할 사이드 이펙트를 남기지 x
- 종료는 통합 테스트의 영역이다 ▶️ 3부에서 다룰 예정

**3.1.7 테스트 대상 시스템 구별하기**


### 3.2 xUnit 테스트 프레임워크 살펴보기
.NET에서 [xUnit](https://xunit.net/?tabs=cs) 대안으로 [NUnit](https://nunit.org/)이나 기본으로 제공하는 Microsoft MSTest 등을 선택할 수 있다. 
- xUnit을 선호하지만, NUnit을 사용할 수도 있다. 
- 이 두 프레임워크는 기능면에서 거의 비슷하다 
- 그러나 💩MSTest는 권장하지 않는다. 앞에 두 개보다 유연하지 않기 때문이다. 
	- 그리고 확실치 않지만, 마소 직원들조차 사용 x
	- ASP.NET Core 팀은 xUnit을 사용한다.
		- 이유는 NUnit보다 더 깨끗하고 간결해서.

### 3.3 테스트 간 테스트 픽스처 재사용
- 준비구절에서 코드를 재사용하는 것이 테스트를 줄이면서 단순화하기 좋은 방법이다

>[!info] 테스트 픽스처
>다음과 같이 두 가지 공통된 의미가 있다. 
>1. 테스트 실행 대상 객체다. 이 객체는 정규 의존성, 즉 SUT로 전달되는 인수다. DB에 있는 데이터나 하드 디스크의 파일일 수도 있다. 이러한 객체는 각 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다. 따라서 픽스처라는 단어가 나왔다.
>2. 다른 정의는 NUnit 테스트 프레임워크에서 비롯된다. NUnit에서 `[TextFixture]`는 테스트가 포함된 클래스를 표시하는 특성이다.

---
### 용어
- 구체 클래스(concrete class) 🔖p59
- 공유 의존성, 비공개 의존성, 프로세스 외부 의존성 🔖p61
- 엔드 투 엔드 테스트(end-to-end-test) 🔖p75
- AAA 패턴 🔖p80
- SUT (System Under Test, 테스트 대상 시스템) 🔖p81
- 불변 위반 (invariant violation) 🔖 p86

### 추천 자료
- 📚 [Entity vs Value Object: the ultimate list of differences · Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)
- TDD (p72)
	- 📗 테스트 주도 개발 (Test-Driven Development : By Example)
	- 📗 [Growing Object-Oriented Software Guided by Tests: About the Book](http://www.growing-object-oriented-software.com/)

