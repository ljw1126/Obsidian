- [저장소](https://github.com/dream-coding-academy/typescript_motion) 
- npm 으로 tsc , live-server 설치

**14.6 DOM을 잘 모르는 ..**
- HTML DOM은 `tag`
- JavaScript에서는 `node`라고 부름
- `Node -> EventTarget`을 상속 받음
	- Node 하위에는 Document, Element, Text가 있고, 상속 받음



```typescript 
export class ImageComponent {

	private element: HTMLElement;
	
	constructor(title: string, url: string) {
		const template = document.createElement('template');
		
		template.innerHTML = `
			<section class="image">
				<div class="image__holder">
					<img class="image__thumbnail">
				</div>
				<p class="image__title"></p>
			</section>
		`;
		
		this.element = template.content.firstElementChild! as HTMLElement;
		
		const imageElement = this.element.querySelector('.image__thumbnail')! as HTMLImageElement;
	
		imageElement.src = url;
		imageElement.alt = title;
		
		const titleElement = this.element.querySelector('.image__title')! as HTMLParagraphElement;
		
		titleElement.textContent = title;
	
	}
	
	  
	
	attachTo(parent: HTMLElement, position: InsertPosition = 'afterbegin') {
		parent.insertAdjacentElement(position, this.element);
	}

}
```
- `<template>` 태그를 사용하는 이유?
- `app.ts`에 추가

```typescript 
import { PageComponent } from './components/page.js';

import { ImageComponent } from './components/page/item/image.js';

  

class App {
	private readonly page: PageComponent;
	
	constructor(appRoot: HTMLElement) {
		this.page = new PageComponent();
		this.page.attachTo(appRoot);
	
		const image = new ImageComponent('Image Title', 'https://picsum.photos/600/300');
		image.attachTo(appRoot, 'beforeend');
	}

}

new App(document.querySelector('.document')! as HTMLElement);
```

```shell
$ tsc -w 
```
- 타입스크립트 파일을 컴파일해서 `dist`  디렉터리에 생성
- `dist/*.js` 파일을 index.html에서 호출하여 사용


컴포넌트 리팩터링 
- image와 page에 중복되는 로직이 존재 
```typescript 
export interface Component {
	attachTo(parent: HTMLElement, position?: InsertPosition): void;
}


class BaseComponent<T extends HTMLElement> {

	protected readonly element: T;
	
	constructor(htmlString: string) {
		const template = document.createElement('template');
		template.innerHTML = htmlString;
		this.element = template.content.firstElementChild! as T;
	}

	attachTo(parent: HTMLElement, position: InsertPosition = 'afterbegin') {
		parent.insertAdjacentElement(position, this.element);
	}

}
```
- `image.ts` , `page.ts`를 리팩터링한다 
- 제네릭 클래스를 상속받는다


**모든 섹션 구현하기** 
- Image component
- note component
- video component
- todo component

> [!info]
> **HTMLHeadElement**: HTML의 head 태그를 대표하는 요소
> **HTMLHeadingElement**: h1과 같은 heading 태그를 대표하는 요소


**app.ts 생성 순서**

`PageComponent` 생성하게 되면 .document 하위에 ul 태그 추가됨
```html
<main class="document">
	<ul class="page"></ul>
</main>
```

`ImageComponent` 생성
```html
 <section class="image">
	<div class="image__holder">
		<img class="image__thumbnail">
	</div>
	<h2 class="image__title"></p>
</section>
```

PageComponent의 addChild(image) 호출 
```typescript
// PageComponent
addChild(section: Component) {
	const item = new PageItemComponent();
	item.addChild(section); 
	item.attachTo(this.element, 'beforeend');
	item.setOnCloseListener(() => {
		item.removeFrom(this.element);
	});
}
```

PageItemComponent 생성 후 addChilld 호출하게 되면 .page-item__body에 section 추가됨
```html
<li class="page-item">
	<section class="page-item__body">
		// 여기 추가
	</section>
	<div class="page-item__controls">
	  <button class="close">&times;</button>
	</div>
</li>
```

```html
<li class="page-item">
	<section class="page-item__body">
	    <section class="image"> // 여기 추가
		<div class="image__holder">
		    <img class="image__thumbnail">
		</div>
		<h2 class="image__title"></p>
	    </section>
	</section>
	<div class="page-item__controls">
              <button class="close">&times;</button>
	</div>
</li>   
```

PageItemComponent 생성한 것을 PageComponent의 `this.element`에 추가 
- `item.attachTo(this.element, 'beforeend');` 

✅ 이미지 컴포넌트가 추가된 결과
- 결국 PageComponent의 this.element가 ul 태그이므로 그 안에 계속 쌓임

```html
<main class="document">
	<ul class="page"> // PageComponent의 this.element 해당
		<li class="page-item"> // ImageComponent 결과
			<section class="page-item__body">
			    <section class="image"> // 여기 추가
				<div class="image__holder">
				    <img class="image__thumbnail">
				</div>
				<h2 class="image__title"></p>
			    </section>
			</section>
			<div class="page-item__controls">
			      <button class="close">&times;</button>
			</div>
		</li>
	</ul>
</main>
```


**14.20 DI 리팩토링**
```typescript
// PageComponent
addChild(section: Component) {  
    const item = new PageItemComponent();  
    item.addChild(section);  
    item.attachTo(this.element, 'beforeend');  
    item.setOnCloseListener(() => {  
        item.removeFrom(this.element);  
    });
}
```

규격 정의
```typescript 
interface SectionContainer extends Component, Composable {  
    setOnCloseListener(listener: OnCloseListener): void;  
}
```


```typescript
import { BaseComponent, Component } from "./component.js";  
  
export interface Composable {  
    addChild(child: Component): void;  
}  
  
type OnCloseListener = () => void;  

// ✨ 신규 정의
interface SectionContainer extends Component, Composable {  
    setOnCloseListener(listener: OnCloseListener): void;  
}  

// ✨ 신규 정의
type SectionContainerConstructor = {  
    new (): SectionContainer;  
}  
  
export class PageItemComponent extends BaseComponent<HTMLElement> implements SectionContainer {  
    private closeListener?: OnCloseListener;  
  
    constructor() {  
        super(`<li class="page-item">  
            <section class="page-item__body"></section>            
            <div class="page-item__controls">              
	            <button class="close">&times;</button>            
			</div>          
			</li>`);  
  
          const closeBtn = this.element.querySelector('.close')! as HTMLButtonElement;  
          closeBtn.onclick = () => {  
            this.closeListener && this.closeListener(); // null이 아니라면 호출  
          }  
    }  
    addChild(child: Component) {  
        const container = this.element.querySelector('.page-item__body')! as HTMLElement;  
        child.attachTo(container);  
    }  
    setOnCloseListener(listener:OnCloseListener) {  
        this.closeListener = listener;  
    }}  
  
export class PageComponent extends BaseComponent<HTMLUListElement> implements Composable {  
	// DI 주입 받음
	constructor(private pageItemConstructor: SectionContainerConstructor) {  
        super('<ul class="page"></ul>');  
    }  
    
    addChild(section: Component) {  
        const item = new this.pageItemConstructor();  
        item.addChild(section);  
        item.attachTo(this.element, 'beforeend');  
        item.setOnCloseListener(() => {  
            item.removeFrom(this.element);  
        });    
	}
}
```



**🤖 Gemini**
`SectionContainerConstructor`의 타입 표기법이 어색하게 느껴질 수 있습니다. 이는 TypeScript에서 **생성자 함수(Constructor Function)의 타입**을 정의하는 방식입니다.

`new (): SectionContainer`는 다음과 같은 의미를 가집니다:
- **`new`**: 이 타입이 **`new` 키워드를 사용하여 호출될 수 있는 생성자**임을 나타냅니다.
- **`()`**: 생성자가 **인자 없이 호출**됨을 의미합니다. 만약 인자가 있다면 `new (name: string): SectionContainer` 와 같이 표현했을 겁니다.
- **`: SectionContainer`**: 이 생성자가 **`SectionContainer` 타입의 인스턴스를 반환**한다는 것을 의미합니다.
    
따라서 `SectionContainerConstructor` 타입은 **`SectionContainer` 인터페이스의 규격을 지키는 인스턴스를 생성하는 생성자 함수**를 가리킵니다. 좀 더 풀어서 설명하면, 이 타입은 "인자 없이 호출하면 `SectionContainer` 타입의 객체를 만들어내는 생성자"를 의미합니다.
```typescript
class MySectionContainer implements SectionContainer {
    setOnCloseListener(listener: OnCloseListener): void {
        // 리스너 설정 로직
    }

    // Componenent, Composable 인터페이스의 멤버 구현 가정
    // ..
}

// MySectionContainer는 SectionContainerConstructor 타입으로 할당될 수 있습니다.
const SectionContainerFactory: SectionContainerConstructor = MySectionContainer;

// 이제 SectionContainerFactory를 사용하여 SectionContainer 인스턴스를 생성할 수 있습니다.
const sectionInstance: SectionContainer = new SectionContainerFactory();
```


>[!info] 기존에 PageComponent는 PageItemComponent에 커플링이 강하게 되어 있었다. 그래서 수정하기 위해서는 클라이언트 코드를 직접 수정하고 컴파일을 다시 해야 했다. 생성자 주입 방식으로 변경한 이후에는 PageComponent 마다 서로 다른 SectionContainer 구현체를 주입하여 사용할 수 있게 되었다. (loose coupling)


---

**14.22 다이얼로그 만들기**
- Image, Video, Note, Todo 버튼 클릭시 다이얼로그 추가
- `BaseComponent` 이용


> onclick과 addEventListener 차이를 설명하는데 모르겠음 (14.23)
> - addEventListener는 이벤트가 쌓이는데 
> - onclick은 여러 이벤트를 하더라도 덮어씌워져 마지막꺼만 동작한다



```typescript 
import { Component } from './components/component.js';  
import { Composable, PageItemComponent, PageComponent } from './components/page.js';  
import { ImageComponent } from './components/page/item/image.js';  
import { NoteComponent } from './components/page/item/note.js';  
import { TodoComponent } from './components/page/item/todo.js';  
import { VideoComponent } from './components/page/item/video.js';  
import {InputDialog} from "./components/dialog/dialog.js";  
import {MediaSectionInput} from "./components/dialog/input/media-input.js";  
import {TextSectionInput} from "./components/dialog/input/text-input.js";  
  
export interface MediaData {  
    readonly title: string;  
    readonly url: string;  
}  
  
export interface TextData {  
    readonly title: string;  
    readonly body: string;  
}  
  
type InputComponentConstructor<T = (MediaData | TextData) & Component> = {  
    new () : T;  
}  
  
class App {  
    private readonly page: Component & Composable;  
    constructor(appRoot: HTMLElement, private dialogRoot: HTMLElement) {  
        this.page = new PageComponent(PageItemComponent);  
        this.page.attachTo(appRoot);  
  
        this.bindElementToDialog<MediaSectionInput>('#new-image',  
            MediaSectionInput,  
            (input: MediaSectionInput) => new ImageComponent(input.title, input.url));  
  
        this.bindElementToDialog<MediaSectionInput>('#new-video',  
            MediaSectionInput,  
            (input: MediaSectionInput) => new VideoComponent(input.title, input.url))  
  
        this.bindElementToDialog<TextSectionInput>('#new-note',  
            TextSectionInput,  
            (input: TextSectionInput) => new NoteComponent(input.title, input.body));  
  
        this.bindElementToDialog<TextSectionInput>('#new-todo',  
            TextSectionInput,  
            (input: TextSectionInput) => new TodoComponent(input.title, input.body));  
    }  
    private bindElementToDialog<T extends (MediaData | TextData) & Component>(  
        selector: string,  
        InputComponent: InputComponentConstructor<T>,  
        makeSection: (input: T) => Component  
    ) {  
        const element = document.querySelector(selector)! as HTMLButtonElement;  
        element.addEventListener('click', () => {  
            const dialog = new InputDialog();  
            const input = new InputComponent();  
            dialog.addChild(input);  
            dialog.attachTo(this.dialogRoot);  
  
            dialog.setOnCloseListener(() => {  
                dialog.removeFrom(this.dialogRoot);  
            });  
            dialog.setOnSubmitListener(() => {  
                const section = makeSection(input);  
                this.page.addChild(section);  
                dialog.removeFrom(this.dialogRoot);  
            });        
		})   
	 }
 }  
  
new App(document.querySelector('.document')! as HTMLElement, document.body);
```