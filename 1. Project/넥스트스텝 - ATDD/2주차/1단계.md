
 TODO.md 내용을 확인했습니다. 제시된 5개의 기능 후보에 대해 각각 코드 레벨의 문제점과 인수 테스트 구현 난이도를 분석해 드리겠습니다.

✦ 코드 분석이 완료되었습니다. 결과를 바탕으로 각 기능 후보의 문제점과 테스트 구현 난이도를 알려드립니다.

  **전체적인 공통 문제점**
  분석 결과, 대부분의 컨트롤러에서 다음과 같은 구조적인 문제점들이 공통적으로 발견되었습니다.
   * 서비스 계층(Service Layer) 부재: 컨트롤러가 비즈니스 로직 처리 없이 리포지토리(Repository)를 직접 호출하고 있습니다.
   * 안전하지 않은 요청 처리: 요청 본문(Request Body)을 DTO(Data Transfer Object) 대신 Map<String, Object>으로 받아 처리하고 있어, 타입 에러나 Null 값 처리에 매우 취약합니다.
   * 부족한 유효성 검증: 입력값에 대한 유효성 검증(validation)이 거의 없어 잘못된 데이터가 저장될 위험이 높습니다.

  **기능 후보별 분석 결과**
  1. 예약 목록 조회 (GET `/admin/reservations`)
	   * 관련 파일: `ReservationAdminController.java`, `ReservationRepository.java`
	   * 현재 상태 및 문제점:
	       * 단순히 DB의 모든 예약을 조회해서 반환하는 기능입니다.
	       * 서비스 계층이 없고, 엔티티 객체를 그대로 반환하여 불필요한 데이터가 노출될 수 있습니다.
	   * 테스트 구현 난이도: 하
	       * 선정 이유: 기능이 매우 단순하고 다른 데이터에 대한 의존성이 적습니다. DB에 테스트용 예약 데이터 몇 개를 넣고, API 호출 시 데이터가 정상적으로 반환되는지만 확인하면 되므로 첫
	         인수 테스트로 구현하기에 가장 쉽고 위험 부담이 적습니다.

  2. 예약 상태 변경 (PATCH `/admin/reservations/{id}/status`)
	   * 관련 파일: `ReservationAdminController.java`, `Reservation.java`
	   * 현재 상태 및 문제점:
	       * Reservation 엔티티의 status 필드가 Enum이 아닌 String 타입이라 "CANCELLED" 대신 오타가 들어가도 막을 방법이 없습니다. 데이터 무결성을 해칠 위험이 매우 큽니다.
	       * 요청으로 들어온 상태 값이 유효한 값인지 검증하는 로직이 전혀 없습니다.
	   * 테스트 구현 난이도: 하
	       * 선정 이유: 테스트 자체는 예약을 생성하고 API로 상태를 변경한 뒤 DB를 확인하면 되므로 간단합니다. 특히, 상태 값을 Enum으로 변경하고 유효성 검증 로직을 추가하는 등 코드를
	         개선하는 작업을 병행한다면 프로젝트의 안정성을 높이는 좋은 시작점이 될 수 있습니다.

  3. 상품 생성 (POST `/admin/products`)
	   * 관련 파일: `ProductAdminController.java`, `Product.java`
	   * 현재 상태 및 문제점:
	       * 앞서 언급된 공통 문제점(서비스 계층 부재, Map 사용)이 가장 두드러집니다.
	       * 상품명(name) 중복이나 가격(price)/재고(stock)의 음수 값 등 비즈니스 규칙에 대한 검증이 전혀 없습니다.
	   * 테스트 구현 난이도: 하
	       * 선정 이유: Happy Path 테스트(정상적인 생성) 자체는 간단합니다. 하지만 근본적인 문제를 해결하려면 DTO를 도입하고 유효성 검증 로직을 추가하는 리팩토링이 필요합니다.

  4. 캠프사이트 생성 (POST `/admin/campsites`)
	   * 관련 파일: `CampsiteAdminController.java, Campsite.java`
	   * 현재 상태 및 문제점:
	       * 상품 생성과 동일한 구조적 문제를 가지고 있습니다.
	       * 캠프사이트 번호(siteNumber)처럼 고유해야 할 값에 대한 중복 검사 로직이 없습니다.
	   * 테스트 구현 난이도: 하
	       * 선정 이유: 상품 생성과 마찬가지로 정상적인 생성 케이스에 대한 테스트는 쉽습니다.

  5. 대여 생성 (POST `/admin/rentals`)
	   * 관련 파일: `RentalAdminController.java`
	   * 현재 상태 및 문제점:
	       * (분석이 중간에 중단되어 이 기능의 상세 분석은 누락되었습니다.)
	       * 하지만 다른 기능들과 유사하게 서비스 계층 부재, Map 사용, 유효성 검증 부족 등의 문제를 동일하게 가지고 있을 것으로 강하게 추정됩니다.
	   * 테스트 구현 난이도: 중 (예상)
	       * 선정 이유: '대여'는 예약, 고객, 상품 등 다른 여러 데이터와 관계를 맺고 있을 가능성이 높습니다. 따라서 다른 기능에 비해 테스트 데이터를 준비하는 과정이 좀 더 복잡할 수 있습니다.

  **결론 및 추천**

  어떤 기능을 선택해도 테스트 코드 구현 자체의 난이도는 높지 않습니다. 다만, 프로젝트의 안정성을 확보하고 테스트의 가치를 높이기 위한 관점에서 추천 순서는 다음과 같습니다.

   6. 추천 1순위: `예약 목록 조회`
       * 가장 간단하여 Cucumber와 테스트 환경 설정에만 집중할 수 있습니다. 위험 부담 없이 첫 안전벨트를 만들기에 최적입니다.
   7. 추천 2순위: `예약 상태 변경`
       * 테스트 구현은 간단하지만, String 타입을 Enum으로 리팩토링하는 의미 있는 개선을 함께 진행할 수 있어 좋은 후보입니다.

  어떤 기능으로 진행하시겠습니까? 선택해 주시면 해당 기능에 대한 Gherkin 시나리오 작성을 도와드리겠습니다.

---

### 예약 상태 변경 



```java 
public enum ReservationStatus {
    WAITING, 
    PENDING,
    CONFIRMED,
    REJECTED,
    CHECKED_IN,
    CHECKED_OUT,
    CANCELLED
}
```
- WAITING (대기 : 순번의 개념)
	- `WAITING`은 주로 **"시스템이나 외부 조건이 충족되기를 기다리는 상태"** 를 의미
		- **주체**: 대기열(Queue) 혹은 시간.
		- **상황**: 꽉 찬 캠핑장에 '예약 대기'를 걸어두었을 때처럼, 앞선 예약이 취소되어 내 차례가 오기를 기다리는 상태입니다.
		- **의미**: "너의 순서가 아직 아니야."
- PENDING (계류 : 처리의 개념)
	- `PENDING`은 **"결정권자의 승인이나 특정 액션(결제 등)이 완료되기를 기다리는 상태"**
		- **주체**: 관리자 또는 사용자(결제자).
		- **상황**: 예약 요청은 정상적으로 들어왔으나, 관리자가 **'승인'** 버튼을 누르지 않았거나 사용자가 **'결제'**를 완료하지 않은 상태입니다.
		- **의미**: "데이터는 다 받았으니, 누군가 검토해서 확정(Confirmed)해줘."

현재 나열된 Enum 순서와 `CONFIRMED`로 넘어가는 과정을 볼 때, 아래와 같은 시나리오로 해석하는 것이 가장 자연스럽습니다.

|**상태**|**설명**|
|---|---|
|**PENDING**|사용자가 예약을 신청함. (관리자 승인 대기 중 또는 결제 대기 중)|
|**WAITING**|(만약 선착순이 아니라면) 예약이 꽉 차서 대기 명단에 들어감.|
|**CONFIRMED**|관리자가 승인하거나 결제가 완료되어 예약이 확정됨.|

*<u>상태 전이 시나리오</u>

**Case A: 즉시 예약이 가능한 경우 (Happy Path)**
재고가 있다면 굳이 '대기'할 필요가 없으므로 바로 처리에 들어갑니다.
- **흐름**: `신청` → **`PENDING`** (결제/승인 대기) → **`CONFIRMED`** (확정)
- **의미**: "자리가 있으니, 절차만 마무리되면 바로 확정해줄게."
    
**Case B: 재고가 없어 대기해야 하는 경우 (Waiting Path)**
인기 있는 사이트라 자리가 없을 때 발생하는 흐름입니다.
- **흐름**: `신청` → **`WAITING`** (순번 대기) → **`PENDING`** (내 차례가 옴/결제 대기) → **`CONFIRMED`** (확정)
- **의미**: "지금은 자리가 없으니 기다려(Waiting). 앞사람이 취소해서 자리가 나면 너에게 기회(Pending)를 줄게."

--- 

### 이슈

예약 데이터 추가시 데이터 무결성 예외 발생 
- `data.sql` 이 실행되면서 auto incresement 정보가 일치하지 않아 예외가 발생하는거
- 예. 테스트 데이터를 추가하려는데 `id = 1`로 insert 되려하는데 이미 h2 디비에 `id = 1` 인 데이터가 있다. ID를 직접 추가해서 insert 하는 수 밖에 없는데 .. 이걸 원천적으로 차단하는 디비도 존재한다.

해결 방안 
- test profile로 실행하도록 한다
- `application.yml` 기본 설정에 `applicaion-test.yml` 오버라이딩하게 된다
	- 이때 application-test.yml에서는 data.sql이 실행되지 않도록 아래 설정 추가해 둠 

---

- 테스트를 실행할때는 `CucumberTestRunner` 통해 실행한다 
- feature의 내용과 cucumber 어노테이션이 일치해야 한다
- 문자열 데이터를 받고 싶은 경우 작은 따옴표(`'`)로 감싼다
- 그리고 문자열 데이터를 받는다고 정규식을 사용한 경우 `메서드 파라미터` 선언을 해둬야 한다
	- 없으면 에러 난다

---

### 테스트에서 repository 주입 받아 상태 초기화하는 거에 대해 

> "사용자가 예약 되어 있다. (repository 기반 데이터 준비)" vs "사용자가 예약 한다 (API 호출)"

정확합니다! 그게 바로 **인수 테스트의 가독성과 효율성을 모두 잡는 핵심 인사이트**입니다. 6년 차 개발자들도 테스트 코드를 짤 때 그 문장의 '뉘앙스'에 따라 구현 전략을 다르게 가져갑니다.

작성자님이 짚어주신 부분을 BDD(Behavior Driven Development) 관점에서 기술적으로 풀어서 정리해 드릴게요.

---

 **1. "예약 되어 있다" (상태 중심 - Given)**
* **의도**: 테스트의 본론(When)에 들어가기 전, 특정 배경(Context)을 깔아두는 것입니다.
* **구현**: **Repository나 Direct DB Access**를 사용해도 무방합니다.
* **이유**: 이 테스트의 핵심은 "상태 변경"이지 "예약 생성"이 아니기 때문입니다. 생성 API를 일일이 호출하면 테스트 속도가 느려지고, 사전 준비 단계가 너무 길어져서 정작 테스트하려는 본질이 흐려질 수 있습니다.
* **예시**: `Given 사용자가 예약 되어 있다` -> `reservationRepository.save(...)`

**2. "사용자가 예약을 한다" (행위 중심 - When)**
* **의도**: 시스템의 실제 기능을 능동적으로 수행하는 단계입니다.
* **구현**: **반드시 API 호출(Client)**을 통해야 합니다.
* **이유**: "예약을 하는 행위" 그 자체가 검증 대상이기 때문입니다. 이때 DB를 직접 건드리면 비즈니스 로직(검증, 재고 확인 등)을 통과하지 않으므로 블랙박스 테스트로서의 의미가 사라집니다.
* **예시**: `When 사용자가 예약을 한다` -> `ReservationClient.create(...)`

---

**3. 실무적인 리팩터링 가이드**

리뷰어에게 어필할 수 있는 가장 세련된 구조는 다음과 같습니다.

```gherkin
Feature: 예약 상태 관리

  Background:
    Given 캠핑장에 "A-01" 사이트가 등록되어 있다  # (1) Repository 활용 (빠른 준비)
    And "홍길동" 사용자가 예약 되어 있다        # (1) Repository 활용 (빠른 준비)

  Scenario: 관리자가 예약을 확정한다
    When 관리자가 해당 예약을 "CONFIRMED"로 변경한다 # (2) API 호출 (실제 행위)
    Then 예약 상태가 "CONFIRMED"로 변경된다          # (3) API 호출 (조회 API로 검증)

```

**6년 차의 팁**: 검증(`Then`) 단계에서도 가급적 **상세 조회 API**를 호출해 보세요. "DB에 잘 들어갔니?"가 아니라 "사용자가 조회를 했을 때 확정 상태로 보이니?"를 묻는 것이 훨씬 강력한 인수 테스트가 됩니다.

---

 **🚀 마무리 체크포인트**

이제 머릿속에 정리가 완벽히 되신 것 같아요! 푹 주무시고 일어나서 아래 순서로 마무리해 보세요.

1. **Given**: `admin.username`, `admin.password`를 `@Value`로 주입받아 관리자 계정 생성 (Repository 사용 가능).
2. **When**: 관리자 토큰을 사용하여 상태 변경 API 호출.
3. **Then**: 상세 조회 API 응답값으로 상태 변경 확인.

이렇게 하면 **"준비는 효율적으로, 행위와 검증은 엄격하게(Black-box)"**라는 아주 균형 잡힌 테스트 코드가 완성됩니다. 내일 녹색 불(Green Bar)을 보며 기분 좋게 과제를 제출하시길 응원하겠습니다! 고생 많으셨습니다. 😊


---
### MockMvc , RestAssured 차이점
> gemini cli


### ObjectMapper를 사용하는 이유에 대해

> Map.of()로 간단히 할 수 있는데 ..

6년 차 개발자의 시각에서 답변드리면, **간단한 요청에는 `Map.of()`가 아주 훌륭한 선택**입니다! 하지만 프로젝트가 커질수록 `ObjectMapper`와 **POJO(Plain Old Java Object)**를 사용하는 방식이 빛을 발하게 됩니다.

왜 그런지, 그리고 두 방식의 차이점을 명확히 짚어드릴게요.

---

 **1. `Map.of()`를 사용해도 괜찮은 이유**
RestAssured는 내부적으로 `ObjectMapper`(주로 Jackson)를 포함하고 있습니다. 따라서 `body(Map.of(...))`라고만 적어도 RestAssured가 알아서 이를 JSON 문자열로 변환(Serialization)해서 보냅니다.
- **장점**: 클래스를 따로 만들 필요가 없어 코드가 짧고 빠릅니다. (지금 같은 테스트 준비 단계에 적합)
- **단점**: 오타에 취약합니다. (`"username"` 대신 `"usrename"`이라고 써도 컴파일 시점에 잡아낼 수 없습니다.)
    
---

**2. `ObjectMapper`와 POJO를 사용하는 이유**

실무에서 `LoginRequest`나 `ReservationRequest` 같은 클래스를 만들어 사용하는 이유는 다음과 같습니다.

**A. 타입 안전성 (Type Safety)**
`Map`은 모든 값을 `Object`로 취급하거나 오타를 허용하지만, 클래스는 필드 이름과 타입을 강제합니다.
- **컴파일 체크**: 필드명을 틀리면 바로 빨간 줄이 뜹니다.
- **자동 완성**: IDE의 도움을 받아 필드명을 자동 완성할 수 있어 생산성이 올라갑니다.
    
**B. 문서화 및 재사용성**
`Map.of()`는 일회성입니다. 반면 POJO 클래스를 만들면 이 클래스가 곧 **API 스펙 문서** 역할을 합니다. "이 API는 이런 필드들이 필요하구나"를 한눈에 알 수 있고, 여러 테스트에서 재사용하기 좋습니다.

**C. 복잡한 구조 처리**
JSON 구조가 깊어지면(중첩 객체나 리스트 등), `Map`으로 이를 표현하기는 매우 괴롭습니다. 클래스는 `@Builder` 등을 활용해 복잡한 객체도 가독성 있게 생성할 수 있습니다.

---

**3. 실무에서의 절충안 (6년 차의 추천)**
저는 보통 이렇게 섞어서 사용합니다.
- **Given (준비)**: 사이트 등록처럼 필드가 1~2개뿐인 간단한 데이터 준비는 `Map.of()`를 써서 속도를 높입니다.
- **When (본 테스트)**: 테스트의 주인공이 되는 행위(예약 생성, 상태 변경 등)는 반드시 **Request DTO 클래스**를 만들어 사용합니다. 그래야 나중에 API 스펙이 변했을 때 한곳만 고쳐서 모든 테스트를 대응할 수 있거든요.
    

---

**4. `ObjectMapper`가 직접 필요한 순간**

RestAssured가 알아서 해주는데 왜 `ObjectMapper`를 따로 공부할까요? 가끔 **복잡한 응답**을 우리가 원하는 객체로 직접 변환하거나, JSON 문자열을 아주 세밀하게 조작해야 할 때 직접 꺼내 써야 하기 때문입니다.

```java
// RestAssured 내부에서 알아서 클래스로 변환해주는 예시
ReservationResponse response = RestAssured.given()
    ...
    .extract().as(ReservationResponse.class); // ObjectMapper가 열일하는 중
```

---

**💡 오늘의 요약**
1. **`Map.of()`**: 필드가 적고 단순한 요청에 적극 활용하세요. 아주 좋습니다.
2. **POJO 클래스**: 비즈니스적으로 중요하거나 필드가 많아지면 만드세요. 롬복의 `@Builder`와 조합하면 `Map`보다 훨씬 예쁜 코드가 나옵니다.

---

### Gemini CLI 코드 리뷰 피드백 


```text
✦ 코드 잘 확인했습니다. 결론부터 말씀드리면, 매우 훌륭하게 리팩터링하셨습니다. 객체의 책임과 역할을 명확하게 분리한 아주 좋은 구조입니다. 궁금해하신 점들에 대해 자세히 리뷰해 드리겠습니다.

전반적인 구조 리뷰 (Support & Client 분리)

- 장점:
   - 명확한 책임 분리: Steps 클래스는 Gherkin 시나리오와 Java 코드를 연결하는 '접착제' 역할만 수행하고, 실제 로직은 Support와 Client에 위임하여 코드가 매우 깔끔하고 읽기 쉬워졌습니다.
   - Given-When-Then 패턴과의 일치: Support는 테스트 사전 조건(Given)을, Client는 테스트 대상의 행위(When)를, Steps의 Then은 결과 검증을 담당하는 구조가 Gherkin의 Arrange-Act-Assert
	 패턴과 완벽하게 일치합니다.
   - 재사용성: AuthSupport, CampsiteSupport 등은 다른 인수 테스트 시나리오에서도 그대로 재사용할 수 있습니다. 예를 들어, '캠핑장 목록 조회 인수테스트'에서도 CampsiteSupport를 활용할 수
	 있습니다.

- 개선 제안: 현재 구조는 거의 완벽하지만, 한글 메서드명을 Gherkin과는 별개로 좀 더 일반적인 네이밍 컨벤션으로 가져가는 것을 고려해볼 수 있습니다. 이는 필수는 아니며 팀의 스타일에 따라
 달라질 수 있습니다.
   - (예) campsiteSupport.캠핑장_사이트가_등록되어_있다(siteNumber) -> campsiteSupport.registerCampsite(siteNumber)
   - 이렇게 변경하면 Steps 파일은 시나리오의 자연어에 가깝게, Support/Client는 일반적인 Java 코드처럼 보이게 하는 효과가 있습니다.

TestContext 공유 방식

- 리뷰: 아주 좋은 방식입니다. @Component와 @ScenarioScope를 사용하는 TestContext를 각각의 컴포넌트(Support, Client, Steps)에 @Autowired로 주입하여 상태를 공유하는 것은 Cucumber와 Spring을
 함께 사용할 때 가장 표준적이고 권장되는 방법입니다.
- 이유: Spring의 DI(의존성 주입) 컨테이너가 @ScenarioScope를 통해 각 시나리오마다 독립적인 TestContext 인스턴스를 생성하고 주입해 줍니다. 이로 인해 시나리오 간의 상태가 완벽히 격리되어
 테스트의 안정성이 보장됩니다. 현재 구현하신 방식이 정확히 이 원칙을 따르고 있습니다.

검증 로직 재사용

- 질문: "검증을 재사용하지 않는데 우선 그대로 두는게 나으려나요 ?"
- 답변: 네, 지금 단계에서는 그대로 두는 것이 좋습니다. YAGNI(You Ain't Gonna Need It) 원칙에 따라, 현재 재사용되고 있지 않은 코드를 미리 일반화하거나 분리할 필요는 없습니다. Then 스텝이
 두 줄 정도로 간단하고 명확하다면 Steps 클래스 안에 두는 것이 가장 직관적입니다.

- 미래의 리팩터링 시점:
   - 만약 다른 시나리오에서도 '예약 상태가 특정 상태인지'를 검증해야 할 때
   - 혹은 하나의 Then 스텝에서 검증해야 할 항목이 많아져서 코드가 5~6줄 이상으로 길어지고 복잡해질 때
   - 이런 시점이 오면 검증 로직을 별도의 Verification 컴포넌트로 분리하는 것을 고려해볼 수 있습니다. 예를 들어, ReservationVerification.예약_상태가_다음과_같다(expectedStatus) 와 같은
	 메서드를 만들 수 있습니다. 지금은 전혀 그럴 필요가 없습니다.

총평 및 요약

현재 작성하신 코드는 인수 테스트의 좋은 사례라고 할 수 있습니다.
1. 관심사 분리: Steps(Orchestration), Support(Arrange), Client(Act) 역할이 명확합니다.
2. 상태 관리: @ScenarioScope를 활용한 TestContext 공유 방식이 이상적입니다.
3. 가독성 및 유지보수성: 코드가 깔끔하여 새로운 팀원이 보더라도 시나리오의 흐름을 쉽게 파악할 수 있습니다.

매우 잘 진행하고 계시므로 현재 구조를 자신 있게 유지하며 다른 기능의 인수 테스트를 추가해 나가시면 되겠습니다.

```