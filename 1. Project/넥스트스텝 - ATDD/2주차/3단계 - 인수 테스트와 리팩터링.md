
## 요구사항

### 1. 레거시 코드 리팩터링

- **테스트 실행:** Step 2에서 완성한 전체 인수 테스트를 실행해 모두 녹색인지 확인합니다.
- **애플리케이션 코드 리팩터링:** 계층과 객체의 책임과 역할을 기반으로 유지보수하기 좋은 코드로 리팩터링합니다.
- **테스트 보충:** 기존 인수 테스트가 리팩터링 할 코드를 충분히 검증하지 못하고 있는 경우 테스트를 보충합니다. 이 때 Step 2에서 진행한 구조화된 테스트를 기반으로 작성합니다.

### 2. 신규 기능 빠르게 개발하기

1. **신규 기능 설계:** 기존 기능들 중에 보완하면 좋을 부분을 찾습니다. (AI의 도움을 받아도 좋아요 🤖)
2. **인수 테스트 조립:** feature파일에 신규 기능에 대한 시나리오를 작성하고 테스트를 구축합니다.
3. **핵심:** 모든 내용을 새로 만들기보다 Step 2에서 구축한 것을 **재활용**하여 테스트를 조립하세요.

### 3. 경험 공유하기

- 인수 테스트 기반으로 리팩터링을 하면서 어떤 점을 체감했는지 작성하기
- 리팩터링 과정에서 테스트를 수정했는지, 했다면 왜 했는지를 작성하기
- AI 도구를 활용하는 경우 방법과 느낀점을 작성하기

## 체크포인트

- [ ] 컨트롤러와 서비스의 스파게티 로직이 서비스 계층으로 이관되었는가?
- [ ] 애플리케이션 코드 리팩터링 후에도 모든 인수 테스트가 통과하는가?
- [ ] 신규 기능의 인수 테스트가 모두 구현되었는가?
- [ ] 신규 기능 테스트 작성 시, 기존 Step Definition을 재활용했는가?

---

### 글로벌 예외 처리 

6년 차 개발자의 시각에서 이 패키지 구조 고민은 **'도메인 경계'**와 **'공통 관심사'**를 어떻게 분리할 것인가에 대한 아주 좋은 고민입니다.

결론부터 말씀드리면, **`handler`가 `exception`의 하위 패키지에 있는 구조는 스프링에서 매우 흔하고 자연스러운 구조**입니다. 하지만 프로젝트의 성격에 따라 더 나은 대안이 있을 수 있습니다. 상황별로 가이드를 드릴게요.

---

**1. 현재 구조 (하위 패키지 방식) : "예약 도메인 전용"**

작성하신 구조는 **"이 핸들러는 이 패키지에 정의된 예외들만 전문적으로 처리한다"**는 강한 응집력을 보여줍니다.

Plaintext

```
exception
├── handler (패키지)
│   └── GlobalExceptionHandler.java
└── CustomException.java
```

- **장점**: 예외 클래스와 그 예외를 처리하는 핸들러가 물리적으로 가까워 찾기 쉽습니다.
    
- **단점**: 나중에 다른 도메인(예: 캠핑장, 회원)이 추가되었을 때, 이 핸들러가 '전역(Global)'인지 '특정 도메인용'인지 모호해질 수 있습니다.
    

---

**2. 추천 대안 (수평적 구성) : "전역 공통 처리 방식"**

많은 시니어 개발자들이 선호하는 방식은 `handler`와 `exception`을 **동등한 레벨(Sibling)**로 두거나, 아예 공통 패키지로 묶는 방식입니다.

Plaintext

```
common (또는 global)
├── exception
│   ├── CustomException.java
│   └── ReservationNotFoundException.java
└── handler (또는 advice)
    └── GlobalExceptionHandler.java
```

- **장점**: 계층 구조가 명확합니다. `exception`은 **데이터(예외 객체)**를, `handler`는 **로직(처리 행위)**을 담당하는 형제 관계가 됩니다.
    
- **구조적 직관성**: "예외 상황이 터지면(`exception`), 이를 가로채서 처리하는 곳(`handler`)이 옆에 있구나"라고 직관적으로 이해됩니다.
    

---

**3. 패키지 설계의 핵심 규칙: "의존성 방향"**

패키지 깊이보다 더 중요한 것은 **import의 방향**입니다.

1. **Handler는 Exception을 알아야 합니다.** (예외를 인자로 받아야 하니까요.)
    
2. **Exception은 Handler를 몰라야 합니다.**
    

만약 `handler`가 `exception`보다 상위에 있거나 같은 레벨에 있다면 의존성이 **`Handler -> Exception`**으로 자연스럽게 흐릅니다. 하지만 `handler`가 `exception`의 자식 패키지라면, 부모 패키지의 클래스를 자식이 참조하게 되는데 이것도 스프링에서는 허용되는 범위입니다.

---

**💡 6년 차의 최종 권장안**

지금은 과제 단계이므로 **같은 레벨(수평적 구조)** 로 구성하는 것을 가장 추천합니다.

```
com.camping.admin
└── exception
    ├── handler
    │   └── GlobalExceptionHandler.java  (여기에 둬도 무방!)
    ├── ReservationException.java
    └── AlreadyCancelledException.java
```

만약 `handler`가 `exception`의 부모가 되면, 나중에 예외 클래스가 20~30개로 늘어났을 때 핸들러 파일이 예외 파일들 사이에 파묻혀 찾기 힘들어질 수 있습니다. 그래서 **`exception`이라는 큰 바구니 안에 `handler`라는 작은 서랍을 만드는 지금의 방식**이 오히려 관리 면에서는 더 편하실 거예요.

---

**메모**

예약 팩토리 만들기 .. 

상수 Fixture

리팩터링 과정에서 테스트를 수정했다면 왜 했는지 
- 예약 조회가 안됨
IllegalArgumentException (500)
잘못된 요청이라서 400 BAD Request


해줘 라고 하는게 편하긴 하겠지만 
