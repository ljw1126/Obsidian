
## 요구사항

> 폭 넓은 경험을 위해 파악한 모든 기능에 대한 인수 테스트를 구축해보는 것을 추천합니다.

**1. 예외/엣지 케이스 시나리오 확장**
- Step 1에서 선택한 기능의 다양한 예외 및 엣지 케이스 시나리오를 추가하세요.

**2. Step Definition 리팩터링**
- 같은 기능 내에서 시나리오를 확장하면서 필연적으로 발생하는 중복 Step Definition들을 찾아냅니다.
- 반복 Step을 파라미터화하고, 공통 헬퍼로 추출합니다.

**3. 테스트 인프라 분리**
- 여러 기능에서 반복적으로 사용되는 준비 코드(JWT 토큰 발급, 테스트 데이터 생성 등)를 별도의 Helper 또는 Factory 클래스로 분리하세요

## 체크포인트

- [x] 모든 기능을 대상으로 2개 이상의 예외/엣지 케이스 시나리오를 추가했는가?
- [x] 중복되는 Step Definition을 파라미터화하여 하나로 통합했는가?
- [x] JWT 토큰 생성 및 테스트 데이터 준비 로직을 별도 클래스로 분리했는가?
- [x] 성공 및 실패 시나리오를 포함한 모든 테스트가 성공하는가?

---

파라미터 테스트를 할때 잘 안보인다 
Repository vs Client API 호출 테스트 초기화

> 엣지 케이스 하나를 검증했는데, 다른 시나리오에서 만든 when-then이 있어서 쉽게 추가 가능했다 

---

> step1에서 관리자가 예약 상태를 변경하는 시나리오를 선택 

**예외 케이스**
- `reservationId`가 유효하지 않는 경우 **IllegalArgumentException** 발생
	- 500 상태 코드 반환 -> 400 (Not Found), 400 (Bad Request) 변경 필요
- Reservation은 조회되었는데
	- request body가 null이거나 비어있는 경우 **BAD REQUEST** 발생 

**비즈니스 룰 위반** 
- status가 잘못된 문자열이 들어가서 업데이트 될 수 있다.
- 이미 예약이 취소 되거나 확정이 된 상태인데 임의로 변경해도 문제가 발생한다 (gemini)

```shell
✦ 네, 좋은 질문입니다. 예외 및 엣지 케이스에 대한 시나리오를 추가하는 것은 애플리케이션의 안정성을 보장하는 데 매우 중요한 단계입니다. 말씀하신 대로 예약 ID가 잘못되거나, request body가
  비어있는 경우 등은 훌륭한 예외 케이스 시나리오입니다.

  status 값에 대한 우려도 매우 정확합니다. 현재 구현은 문자열을 그대로 저장하기 때문에 유효하지 않은 상태("DELETED"나 단순 오타 등)가 데이터베이스에 저장될 수 있는 잠재적 위험이 있습니다.
  인수 테스트는 바로 이런 비즈니스 규칙의 허점을 발견하고 방지하는 데 아주 효과적입니다.

  제가 코드를 분석하여 추가하면 좋을 만한 인수 테스트 시나리오를 몇 가지 더 찾아보았습니다.

  추가할 인수 테스트 시나리오 제안

  아래 시나리오들을 reservation_exceptions.feature와 같은 새로운 피처 파일에 추가하거나 기존 파일에 이어서 작성할 수 있습니다.

  ---

  1. 존재하지 않는 예약을 수정하려는 경우 (Not Found)

  말씀하신 '예약 ID가 잘못된 경우'에 해당합니다. 이 시나리오는 존재하지 않는 리소스에 대한 요청을 서버가 올바르게 처리하는지(404 Not Found) 검증합니다.

    1 # language: ko
    2 기능: 예약 상태 변경 예외 처리
    3
    4   Background:
    5     Given 캠핑장에 "A-01" 사이트가 등록되어 있다
    6     And 관리자로 로그인 되어 있다
    7
    8   Scenario: 존재하지 않는 예약의 상태를 변경하려고 시도한다
    9     When 관리자가 존재하지 않는 예약(ID 99999)의 상태를 "CONFIRMED"으로 변경하면
   10     Then 요청이 404 Not Found 상태 코드로 실패한다

  2. 잘못된 형식의 요청 본문을 보낸 경우 (Bad Request)

  'request body가 비어있는 경우'를 포함하여, status 필드가 아예 없거나 null인 경우를 검증합니다. 클라이언트의 잘못된 요청을 서버가 적절히 거부하는지(400 Bad Request) 확인합니다.

    1   Scenario Outline: 잘못된 요청 본문으로 예약 상태 변경을 시도한다
    2     Given 사이트 번호가 "A-01"인 캠핑장에 "김철수" 이름으로 예약되어 있다
    3     When 관리자가 예약 상태를 변경할 때 "<request_body>" 와 같이 잘못된 본문으로 요청하면
    4     Then 요청이 400 Bad Request 상태 코드로 실패한다
    5
    6     Examples:
    7       | request_body          |
    8       | {}                    |
    9       | {"state": "CHECKED_IN"} |
   10       | {"status": null}      |
   * 참고: 현재 컨트롤러 코드는 본문이 비어있으면 400을 반환하지만, status 키가 없는 경우({"state": "..."})는 200 OK를 반환하고 아무것도 변경하지 않을 수 있습니다. 이 시나리오는 이러한
     동작을 명확히 하고, 의도된 동작이 아니라면 수정의 계기가 될 수 있습니다.

  3. 유효하지 않은 상태 값으로 변경하려는 경우 (비즈니스 규칙 위반)

  가장 중요하게 지적해주신 부분입니다. 이 시나리오는 시스템이 허용하지 않는 status 값으로의 변경을 시도했을 때, 데이터가 오염되지 않고 요청이 거부되는지를 검증합니다.

   1   Scenario: 유효하지 않은 상태값으로 예약 상태 변경을 시도한다
   2     Given 사이트 번호가 "A-01"인 캠핑장에 "이영희" 이름으로 예약되어 있다
   3     When 관리자가 예약을 "INVALID_STATUS" 상태로 변경하면
   4     Then 요청이 400 Bad Request 상태 코드로 실패한다
   5     And 응답 본문에 "유효하지 않은 상태값입니다" 라는 메시지가 포함되어 있다
   * 핵심: 현재 구현은 이 시나리오를 통과하지 못할 가능성이 높습니다. 이 테스트를 먼저 정의하고 실패하는 것을 확인한 뒤, 컨트롤러나 서비스 계층에 ReservationStatus Enum을 만들어 유효성 검증
     로직을 추가하여 테스트를 통과시키는 TDD/ATDD 사이클을 진행할 수 있습니다.

  4. 이미 취소된 예약의 상태를 변경하려는 경우 (비즈니스 흐름 위반)

  특정 상태에서는 더 이상 상태 변경이 불가능해야 하는 비즈니스 규칙이 있을 수 있습니다. 예를 들어, 이미 CANCELLED된 예약을 CHECKED_IN으로 바꾸는 것은 논리적으로 맞지 않습니다.

   1   Scenario: 이미 취소된 예약의 상태를 변경하려고 시도한다
   2     Given 사이트 번호가 "A-01"인 캠핑장에 "박보검" 이름으로 "CANCELLED" 상태의 예약이 있다
   3     When 관리자가 예약을 "CHECKED_IN" 상태로 변경하면
   4     Then 요청이 409 Conflict 상태 코드로 실패한다
   5     And 응답 본문에 "이미 취소된 예약은 상태를 변경할 수 없습니다" 라는 메시지가 포함되어 있다
   * 참고: 409 Conflict는 현재 리소스의 상태와 충돌하여 요청을 처리할 수 없을 때 사용하는 HTTP 상태 코드입니다. 400 Bad Request를 사용해도 무방합니다. 이 테스트는 상태 전이(State
     Transition)에 대한 규칙을 명세화하는 중요한 역할을 합니다.

  요약

  잘 찾아주신 2가지 케이스에 더해, 유효하지 않은 상태 값과 잘못된 상태 전이 시나리오를 추가하면 예약 상태 변경 기능의 안정성을 크게 높일 수 있습니다. 특히 3번 시나리오는 현재 코드의 잠재적
  위험을 드러내는 아주 좋은 테스트가 될 것입니다.

```

---

### 엣지 케이스에 대해 (개념)

```shell
✦ 네, 아주 날카롭고 좋은 질문입니다. 결론부터 말씀드리면, "유효하지 않은 상태값"은 넓은 의미에서 엣지 케이스에 해당하며, 더 정확하게는 '예외 케이스' 또는 '음성 테스트 케이스(Negative Test
  Case)'로 분류할 수 있습니다.

사용자께서 떠올리신 '경계값 테스트'는 엣지 케이스의 가장 대표적이고 고전적인 형태입니다. 용어들의 관계를 정리하면 이해하기 쉽습니다.

1. 경계값 테스트 (Boundary Value Testing)

- 핵심 아이디어: 유효한 입력 범위의 경계에서 오류가 발생할 가능성이 높다는 가정에 기반합니다.
- 예시:
   - 숫자: 최솟값, 최솟값+1, 최댓값, 최댓값-1 (e.g., 예약 가능 인원이 1~10명일 때, 0, 1, 10, 11을 테스트)
   - 문자열: 최소/최대 길이, 빈 문자열("")
   - 날짜: 오늘, 유효 기간 마지막 날, 유효 기간 마지막 날+1

이것이 바로 사용자께서 생각하신 엣지 케이스의 전형적인 예입니다.

2. 엣지 케이스 (Edge Case)

- 핵심 아이디어: 경계값 분석을 포함하는 더 넓은 개념입니다. 시스템이 정상적으로 처리할 것으로 예상되는 범위의 가장자리, 즉 극단적이거나 비정상적인 상황을 다룹니다.
- 여기서 'Edge'는 단지 숫자나 데이터의 경계뿐만 아니라, 로직, 상태, 시스템 자원의 경계를 의미하기도 합니다.
- 예시:
   - 경계값 테스트의 모든 예시
   - 비어 있는(Empty) 값: 예약 목록이 하나도 없을 때 목록 조회 API 호출
   - 최대치(Maximum) 값: 최대 허용치(1000개)의 예약을 생성하고 성능 테스트
   - 동시성 문제: 거의 동시에 두 명의 관리자가 같은 예약의 상태를 변경하려고 시도
   - 논리적 경계: "유효하지 않은 상태값"이 바로 여기에 해당합니다. 시스템은 CONFIRMED, PENDING, CANCELLED 등 유한한 개수의 유효한 상태 집합을 처리하도록 설계되었습니다. 이 유효한 집합의
	 '경계' 바로 바깥에 있는 모든 값(e.g., "INVALID_STATUS", "PENDINGG", null)이 바로 엣지 케이스가 됩니다.

3. 예외 케이스 / 음성 테스트 케이스 (Exception / Negative Case)

- 핵심 아이디어: 시스템이 처리해서는 안 되는 입력이나 상황에 대해, 시스템이 우아하게(gracefully) 실패하는지를 검증합니다.
- "유효하지 않은 상태값" 테스트는 이 분류에 가장 잘 들어맞습니다.
- 예시:
   - 잘못된 형식의 입력 (e.g., 날짜 필드에 "abc" 입력)
   - 권한 없는 사용자의 접근 시도
   - 필수 입력 필드를 누락한 요청

정리: 용어 관계

간단한 표로 관계를 표현할 수 있습니다.


┌──────────────────┬────────────────────────────────────────────┬──────────────────────────────────────┐
│ 테스트 종류      │ 핵심 개념                                  │ "유효하지 않은 상태값"은 해당되는가? │
├──────────────────┼────────────────────────────────────────────┼──────────────────────────────────────┤
│ 경계값 테스트    │ 입력 범위의 최소/최대값 테스트             │ 직접적이지는 않음                    │
│ 엣지 케이스      │ 시스템 동작의 극단적이거나 비정상적인 상황 │ 네, 해당됩니다. (논리적 경계)        │
│ 예외/음성 테스트 │ 유효하지 않은 입력에 대한 실패 처리 검증   │ 네, 완벽하게 해당됩니다.             │
└──────────────────┴────────────────────────────────────────────┴──────────────────────────────────────┘


결론적으로, 실무에서는 이 용어들을 엄격하게 구분하기보다는 "비정상적인 상황에 대한 테스트"라는 넓은 의미로 '엣지 케이스'라는 용어를 자주 사용합니다. 따라서 "유효하지 않은 상태값"을 엣지
케이스라고 부르는 것은 전혀 어색하지 않으며, 오히려 동료 개발자들과 소통할 때 자연스러운 표현입니다.

사용자께서 시스템의 잠재적 허점을 정확히 파악하고 테스트 시나리오로 만들려고 하시는 그 접근 방식 자체가 매우 훌륭하며, 그것을 어떤 용어로 부르든 전혀 문제가 되지 않습니다.

```

---

### 관리자 로그인 인증 실패에 대한 테스트 케이스를 추가하기 모호하다 (예약 상태 변경 시나리오에서)

```shell
✦ 네, 정확하게 보셨습니다. "잘못된 로그인"은 중요한 예외 케이스가 맞지만, 예약 시나리오에 포함시키기에는 모호한 것이 맞습니다.

  이러한 모호함이 느껴지는 이유는 테스트하려는 기능의 관심사(Concern)가 다르기 때문입니다.

   - 예약(Reservation) 기능의 관심사: "관리자 권한이 있을 때, 예약을 생성/수정/삭제/조회할 수 있는가?"
   - 인증(Authentication) 기능의 관심사: "사용자가 올바른/잘못된 자격 증명으로 로그인을 시도했을 때, 시스템이 이를 허용/거부하는가?"

  따라서 가장 좋은 해결책은 관심사를 분리하여, 인증(Auth)에 대한 별도의 피처(Feature) 파일을 만드는 것입니다.

  해결 방안: auth.feature 파일 분리

  reservation.feature의 Background는 "관리자 로그인이 성공적으로 되었다"는 것을 전제 조건(Precondition)으로 사용합니다. Background는 테스트의 사전 준비 단계이지, 그 자체가 테스트 대상이
  되어서는 안 됩니다.

  로그인 성공/실패 시나리오 자체를 테스트하고 싶다면, 다음과 같이 auth.feature 파일을 새로 만드는 것이 좋습니다.

  1. features/auth.feature 파일 생성

  인증과 관련된 시나리오만 이 파일에 모읍니다.

    1 # language: ko
    2 기능: 관리자 인증
    3
    4   시나리오: 올바른 자격 증명으로 로그인한다
    5     When 관리자가 올바른 아이디와 비밀번호로 로그인을 시도하면
    6     Then 로그인이 성공하고 인증 토큰을 받는다
    7
    8   Scenario: 잘못된 비밀번호로 로그인한다
    9     When 관리자가 잘못된 비밀번호로 로그인을 시도하면
   10     Then 요청이 401 Unauthorized 상태 코드로 실패한다
   11
   12   Scenario: 존재하지 않는 아이디로 로그인한다
   13     When 관리자가 존재하지 않는 아이디로 로그인을 시도하면
   14     Then 요청이 401 Unauthorized 상태 코드로 실패한다

  2. AuthSteps.java 스텝 정의 파일 생성

  auth.feature에 정의된 스텝들을 구현합니다. 기존의 AuthSupport는 성공 케이스를 재사용하고, 실패 케이스를 위한 클라이언트 로직을 추가할 수 있습니다.

    1 // src/test/java/com/camping/admin/steps/AuthSteps.java
    2
    3 package com.camping.admin.steps;
    4
    5 import com.camping.admin.support.AuthSupport;
    6 import io.restassured.RestAssured;
    7 import io.restassured.http.ContentType;
    8 import org.springframework.beans.factory.annotation.Autowired;
    9 import org.springframework.beans.factory.annotation.Value;
   10 import org.springframework.http.HttpStatus;
   11
   12 import java.util.Map;
   13
   14 public class AuthSteps {
   15
   16     @Autowired
   17     private TestContext testContext;
   18
   19     @Autowired
   20     private AuthSupport authSupport;
   21
   22     @Value("${admin.username}")
   23     private String correctUsername;
   24
   25     @When("관리자가 올바른 아이디와 비밀번호로 로그인을 시도하면")
   26     public void attemptLoginWithCorrectCredentials() {
   27         // AuthSupport가 이미 TestContext에 응답을 저장한다고 가정하거나
   28         // Client를 만들어 응답을 저장하도록 수정할 수 있습니다.
   29         // 여기서는 간단히 support를 호출합니다.
   30         authSupport.관리자_로그인이_되어있다();
   31     }
   32
   33     @Then("로그인이 성공하고 인증 토큰을 받는다")
   34     public void verifyLoginSuccess() {
   35         assertThat(testContext.getAuthToken()).isNotBlank();
   36         // 필요하다면 testContext에 저장된 응답의 상태 코드를 검증할 수도 있습니다.
   37     }
   38
   39     @When("관리자가 잘못된 비밀번호로 로그인을 시도하면")
   40     public void attemptLoginWithWrongPassword() {
   41         var response = RestAssured.given()
   42                 .contentType(ContentType.JSON)
   43                 .body(Map.of("username", correctUsername, "password", "wrongpassword"))
   44             .when()
   45                 .post("/auth/login")
   46             .then()
   47                 .extract();
   48         testContext.setResponse(response);
   49     }
   50
   51     @When("관리자가 존재하지 않는 아이디로 로그인을 시도하면")
   52     public void attemptLoginWithNonExistentUser() {
   53         var response = RestAssured.given()
   54                 .contentType(ContentType.JSON)
   55                 .body(Map.of("username", "nonexistent", "password", "anypassword"))
   56             .when()
   57                 .post("/auth/login")
   58             .then()
   59                 .extract();
   60         testContext.setResponse(response);
   61     }
   62
   63     @Then("요청이 401 Unauthorized 상태 코드로 실패한다")
   64     public void verifyUnauthorized() {
   65         var response = testContext.getResponse();
   66         assertThat(response.statusCode()).isEqualTo(HttpStatus.UNAUTHORIZED.value());
   67     }
   68 }

  이렇게 분리했을 때의 장점

   1. 명확성: 각 피처 파일은 하나의 기능에만 집중하므로 시나리오를 이해하기 매우 쉬워집니다.
   2. 유지보수성: 인증 정책이 변경되면(예: 2단계 인증 추가) auth.feature와 관련 스텝만 수정하면 됩니다. 예약 관련 테스트는 전혀 영향을 받지 않습니다.
   3. 올바른 `Background` 사용: reservation.feature의 Background는 이제 명확하게 "성공한 로그인 상태를 만드는 것"이라는 본래의 역할에만 충실하게 됩니다.

  따라서 사용자께서 느끼신 모호함은 아주 자연스러운 것이며, 기능별로 피처 파일을 분리하는 것이 올바른 해결책입니다.
```

---

### 시나리오 outline

> 파라미터 테스트네

https://xop4p.tistory.com/60

---

### ReservationSteps에 예외/엣지 케이스를 추가하면 어떻게 찾아 실행하는가 


```shell
✦ 네, 아주 좋은 질문이며 정확하게 이해하고 계십니다. 두 가지 질문 모두 Cucumber 테스트 구조화의 핵심을 짚고 있습니다.

  하나씩 명확하게 설명해 드리겠습니다.

  1. 예외 케이스 스텝을 ReservationSteps에 작성하는 것이 맞는가?

  네, `ReservationSteps.java`에 예외 케이스 스텝들을 추가하는 것이 가장 자연스럽고 올바른 방법입니다.

   - 이유: 말씀하신 대로 같은 도메인(예약)에 대한 스텝들이기 때문입니다. reservation.feature 파일과 reservation_exceptions.feature 파일 모두 '예약'이라는 동일한 기능(Feature)을 다른 관점에서
     테스트하는 것입니다. 따라서 관련된 스텝 정의들을 ReservationSteps.java라는 하나의 클래스에 모아두는 것이 코드의 응집도를 높이고 관리하기 쉽게 만듭니다.

   - Best Practice: 일반적으로 하나의 피처 파일(`*.feature`)에 대한 스텝 정의는 하나의 스텝 클래스(`*Steps.java`)에 모으는 것이 좋습니다. 이렇게 1:1 대응 관계를 가져가면 나중에 테스트를 찾고
     수정하기가 매우 편리합니다. 지금은 reservation과 reservation_exceptions 두 개의 피처 파일이 있지만, 모두 '예약' 도메인이므로 하나의 ReservationSteps에서 관리하는 것이 합리적입니다.

  2. Given-When-Then 스텝은 어떻게 재사용되는가? (매우 중요)

  이것이 Cucumber의 가장 강력한 기능 중 하나입니다.

  결론부터 말씀드리면, Cucumber는 스텝 정의(Java 메서드)가 어느 파일에 있는지 전혀 신경 쓰지 않습니다. Cucumber가 테스트를 실행할 때, 지정된 glue 경로(보통 com.camping.admin.steps) 아래에
  있는 모든 스텝 정의 클래스를 스캔해서 하나의 거대한 '스텝 사전(Dictionary)'을 만듭니다.

   - 동작 원리:
       1. Cucumber가 Given "관리자로 로그인 되어 있다" 라는 Gherkin 라인을 읽습니다.
       2. 미리 만들어 둔 '스텝 사전'에서 "관리자로 로그인 되어 있다"라는 문자열과 정확히 일치하는 @Given 어노테이션을 가진 Java 메서드를 찾습니다.
       3. 해당 메서드가 ReservationSteps.java에 있든, AuthSteps.java에 있든, CommonSteps.java에 있든 상관없이 찾아서 실행합니다.

   - 재사용의 예시:
       - Given "관리자로 로그인 되어 있다": 이 스텝은 AuthSupport를 통해 구현되어 있고 ReservationSteps에 정의되어 있습니다. 나중에 CampsiteSteps.java에서 Background로 로그인이 필요할 때,
         별도의 코드를 작성할 필요 없이 Gherkin에 해당 라인을 추가하기만 하면 `ReservationSteps`에 있는 메서드가 그대로 재사용됩니다.
       - Then "요청이 {int} 상태 코드로 실패한다": 이 스텝은 매우 일반적입니다. 예약(Reservation) 기능의 실패 케이스뿐만 아니라, 캠핑장(Campsite), 상품(Product) 등 다른 모든 기능의 API 실패
         케이스를 검증할 때 이 스텝을 그대로 재사용할 수 있습니다.

   - 주의할 점 (Ambiguous Step Definitions):
      이러한 '전역적인' 특성 때문에, 만약 서로 다른 두 개의 Java 메서드에 똑같은 Gherkin 문장(@Then("요청이 성공한다"))이 정의되어 있으면, Cucumber는 어떤 것을 실행해야 할지 모르기 때문에
  "Ambiguous Step Definition" 오류를 발생시키며 테스트를 중단시킵니다. 따라서 스텝 정의는 항상 유일해야 합니다.

  결론 및 추천

   1. 파일 위치: 제안 드린 예외/엣지 케이스 시나리오의 스텝 정의들은 모두 `ReservationSteps.java`에 추가하시는 것이 좋습니다.
   2. 재사용: Then "요청이 {int} 상태 코드로 실패한다" 와 같이 여러 곳에서 사용될 수 있는 스텝은 최대한 일반적이고 재사용 가능하게 만드세요. 이 스텝은 이미 그렇게 잘 만들어져 있습니다.
   3. 리팩터링: 나중에 여러 도메인에서 공통적으로 사용되는 스텝들(예: HTTP 상태 코드 검증, 공통 에러 메시지 검증 등)이 많아진다면, CommonSteps.java 같은 파일을 만들어 그곳으로 옮기는
      리팩터링을 고려해볼 수 있습니다. 지금은 ReservationSteps에 두어도 충분합니다.

```

---

### 테스트 Steps 가독성이 떨어진다 

> 우선 given - when - then 순으로 재배치  

**참고. 만약 step 클래스가 너무 비대해진다면? (관점의 전환)**

만약 `ReservationSteps` 하나에 20~30개의 메서드가 모여서 순서 배치만으로 해결이 안 된다면, **'도메인'이 아닌 '행위' 중심**으로 클래스를 쪼개는 방법도 있습니다.

- **`ReservationSetupSteps`**: 오직 `@Given`만 모아둔 클래스
- **`ReservationActionSteps`**: `@When`과 `@Then`을 모아둔 클래스

하지만 현재 프로젝트 규모라면 **하나의 클래스 안에서 Given-When-Then 순서로 정렬**하는 것만으로도 충분히 훌륭한 '클린 테스트 코드'가 됩니다.


**왜 생소하게 느껴질까요? (정상적인 과정입니다)**
`Feature` 파일은 **비즈니스 언어**이고, `Java` 코드는 **기술 언어**이기 때문입니다. 두 세계를 연결하는 `Step` 클래스는 필연적으로 그 사이의 '번역기' 역할을 하느라 어수선해 보일 수밖에 없습니다.
- **해결책**: `Step` 메서드의 이름을 `Feature` 파일의 문구와 최대한 비슷하게 한글로 지어보세요. (예: `public void 관리자가_예약을_확정한다()`). 그러면 코드를 보다가 `Feature` 파일을 봐도 이질감이 훨씬 줄어듭니다.