api client에서 method return 타입을 지정한다 
- test context와 같은 의존성을 제거하고 
  - steps에서만 의존하도록 한다
  // 분산되어 있으면 찾기 힘드니깐 .. 

Steps 에서만 TestContext를 사용하고 공통 모듈에서는 반환된 값을 받아 처리하는 형태로 구현한다


PICO 컨테이너란??
- 큐컴버에서 사용되는 컨텍스트다
- 메서드를 아우르는 공간 

3주차
wire mock
e2e 테스트 

4주차
테스트 전략 문서 만듦

---

### hook
- 전후 


테스트 컨텍스트를 어디서 쓰는지 
- 스텝에서만 사용하면 관리가 편하다
- 테스트 구성의 단일성을 가지도록 한다

static 대신 `poco container`
- cucumber에서 사용되는 컨텍스트
- 특정 메서드, 객체가 접근할 수 있도록 해준다
	- 스프링 컨테이너가 객체관리를 해주는 것처럼 
	- 스프링 보다는 가볍다

테스트 환경을 구축하는 것과 
테스트에서 사용할 객체를 공유하는것은 분리되어야 한다
- 객체 관리용으로 사용한다는 것을 명시 해주는게 좋다 

cucmber 객체의 라이프 사이클 알ㅇ보기
- 다른 시나리오로 넘어갔을때 컨텍스트가 분리되는지 확인해보기


### 시나리오 정보 공유 방법
- static 
- pico container
- cucumber-spriong
- cucumber only

### context
- 스텝간 공유 상태 컨테이너
- 로그인 토큰, 최근 응답, 식별자 등을 저장
- DI/스레드 - 로컬로 시나리오 격리

```java
public class TestContext {
	public Map<String, String> token;
	public Map<String, Object> store;
	public Response lastResponse;
}
```


### data initailize


### id를 지정해주는게 좋을까요?
- API 를 통해 생성된 엔티티를 context에 저장하는 것도 용이
- API로 특정 아이디로 사용할 수 있게 끔 해준다

> setter도 테스트 가독성을 올릴 수 있으니 처음에 쓰고 리팩터링시 바꾸도록 한다. 처음부터 제거하기 보다는 효과적인 테스트 구축이 필요하다 

---

### 인수 테스트 환경 with MSA
> cucumber로 배민에서는 넘어갔다고 한다

**학습 목표**
- 모놀리식 vs MSA 인수 테스트 환경 차이 이해
- Docker/Compose/네트워크/헬스체크/자동화의 필수 개념 습득
- 미션 수행시 필요한 설정 방법 이해

<img src="./모놀리식 MSA 방식 비교.png"/>

> 외부 API 레벨의 테스트를 구축 후 리팩터링 하는게 안전하다 


### 테스트 전략의 어려움 
- 모든 서비스를 한 번에 띄우기 어렵다 
- 리소스/속도/조정 비용의 한계가 분명함 
- 데이터 시드 / 마이그레이션 / 버전 호환성 복잡도 높음 


### 현실적인 테스트 전략 - 경계 
- 동일 팀 내부 서비스는 통합 기동해 흐름 검증 
- 타 팀 서비스는 WireMock / 계약 테스트로 대체 


### 추후 : 라이프 사이클 단위로 끊기
- 주요 라이프사이클로 시나리오 분할 
- 각 라이프사이클마다 필요한 최소 구성만 기동
- 이후 필요시 시나리오를 합쳐 단일 흐름으로 확대 
	- 📌 단, 이번 과정에서는 다루지 않음

### 추후 : 점진적 적용 
- 처음엔 한 서비스만, 그 다음 필수 의존 하나씩 추가
- 실패를 빠르게 피드백 받아 구성/데이터를 다듬기
- 안정화되면 CI에 통합, 운영 유사성 점차 높이기
	- 📌 단, 이번 과정에서는 다루지 않음

### 주요 내용 
- dockeer와 docker compose, network : 환경 구축 
- gradle task or script 
- wriemock

### 점진적 적용 


### 서비스 실행 방법

### Compose 내부 네트워크 
- scripte에 컨테이너 서비스명이  Compose 내부 네트워크 통신시 사용된다 
	- `http://admin:8080`
	- `http://kiosk:8080`
- 호스트에서 접근은 포트 매핑 사용 
	- `http://localhost:18081` 등
- 테스트 앱 공통 베이스 URL 환경 변수 
	- KIOSK_BASE_URL
	- ADMIN_BASE_URL
	- PAYMENTS_BASE_URL

> [!info] Gradle 자동화 (Exec)
> - up > 대기 > 테스트 > down

### 외부 결제 모킹 (WireMock)
- 계약 고정 : 
	- 외부 결제 API 요청 / 응답을 스키마 / 예상 값으로 고정해 회구 방지 
- 시나리오 다양ㅇ화 
	- happy / sad-path (4xx/5xx/타임아웃/지연/부분 실패) 까지 커버
- 검증/관찰 
	- 요청 매칭/검증
	- 호출 횟수/순서 확인으로 리그레션 탐지
- 소스 제어
	- `mappings/*.json`을 저장소에 두어 재현성 확보, CI에서 동잏하게 사용 


### 인증 흐름 (예)
- `admin` 로그인 > 토큰/쿠키 획득 > kiosk 호출 시 포함 
- 테스트 / 헬퍼로 공통화하여 재사용


### 전체 테스트 플로우 
- 1. 빌드 / 이미지 준비 
	- 각 서비스 JAR 빌드 > 도커 이미지 빌드/캐시 활용
- 2. 인프라 compose up 
	- DB 등 공용 인프라 기동 (외부 네트워크 atdd-net)
- 3. 앱 compose up
	- 각 서비스 기동 (헬스 체크는 Compose에 위임)
- 4. WrieMock 준비
	- 정적 매핑 마운트 또는 Admin API로 스텁 등록
- 5. 데이터 초기화 
	- 데이터 정리 및 테스트에 필요한 최소 데이터/픽스처 주입 
- 6. 스모크 / E2E 실행
	- 핵심 사용자 흐름만 검증 (로그 / 지표 수집)
- 7. 리포트 / 아티팩트 보관 
	- 실패시 컨테이너 로그 / 덤프 / 스크린샷 보관
- 8. 종료 / 정리 
	- compose down -v로 볼륨 포함 정리

### Step1. 단일 앱 스모크 테스트 확보 
> 정상적으로 돌아가는지 확인하는 테스트를 스모크 테스트라 한다


### Step2


### Step3 : 결제 연동 모킹 

### Step4 : 시나리오 인수 테스트 보강

### 트러블 슈팅 빠른 체크 
- 포트 충돌 > 
- 준비 대기 실패 > 
- 내부 통신 실패 > 
- DB 초기화 실패 > 

### Summary

