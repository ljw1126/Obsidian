
**학습 목표**
 - 시스템 레벨 인수 테스트를 AI로 생성, 운영
	 - 대상 프로젝트 : `reservation`, `admin`, `kiosk`, `payments (WireMock)`
 - 정상/경계/예외 시나리오를 포괄하는 Gherkin 기반 시나리오를 작성한다

**배경 및 범위**
- 기반 환경 
	- `kiosk > reservation > admin`
	- `kiosk > payments(WireMock)` 연결
- 기능 신규 개발이 아니라, 시나리오 기반의 인수 테스트 포트폴리오 구축이 목표

> kiosk에서 reservation으로 요청하는 api는 없다
> - `kiosk -> admin`와 `kisok -> payments` 요청만 존재한다
> // reservation이 들어가는 형태로 하면 좋지 않을가 싶네 (개인 의견)
- AdminAuthClient, AdminClient, PaymentClient가 존재한다
- ProductController에서는 상품 목록 조회 api 1개만 존재한다
	- `/admin/products`
- PaymentController에서는 `결제 생성, 승인`에 대한 api 2개가 존재한다
	- 결제 생성 : PaymentClient 통해 생성
	- 결제 승인 : 성공시 AdminClient 통해 `/api/sales`를 호출한다
		- payments의 경우 wiremock으로 대체
		- 세부적으로 알 필요 없이 response dto (inner class)만 알면 stub하기 쉽다

> reservation -> admin도 없다
> 1주차 과제였는데 h2 db에 저장하는 걸로 끝이였던거 같다
- 예약 생성, 조회, 수정, 취소 등등
- 사이트 목록/상세 조회, 사이트 검색(날짜/기간별)

> admin의 경우 전체 API가 아닌 사용 예상 되는 API 대상으로만 작성하도록 한다

>[!note] kiosk > reservation > admin에 대한 api 가 명확히 없다. 고로 기능 구현이 목적이 아닌 인수 테스트 가이드 문서 구축을 목적으로 접근을 해야 할듯하다

>[!info] "기능 신규 개발이 아니라, 시나리오 기반의 인수 테스트 포트폴리오 구축이 목표." 의미에 대해
>선택 과제 요구사항을 보면 **"AI로 생성·운영한다"**는 문구가 핵심입니다. 이는 "지금 코드가 돌아가느냐"보다 **"나중에 기능을 개발했을 때, AI가 즉시 이 테스트를 만들어낼 수 있도록 '설계 도면(Context)'을 얼마나 잘 닦아놓았는가"**를 평가하겠다는 뜻입니다.


**해야 하는 것**
- [ ] 테스트 작성 가이드 문서화 : `atdd-tests/docs/acceptance-test-guide.md`
- [ ] 인증/실행 가이드 문서화 : `atdd-tests/docs/auth-setup.md`
- [ ] `@ai-candidate` 태그 등 태그를 활용하여 AI 생성 인수 테스트 추가


### 요구사항 
**1) AI 입력 컨텍스트 표준화**
- 포함 : 시스템 개요, 엔드포인트 요약, 사용자 여정, 인증/시드 데이터 규칙, 좋은/나쁜 예시, 품질 기준 등
- 이떄 AI 도구를 활용하여 문서 작성 추천 

**2) 검토 게이트**
..


**3) 태깅/실행 규칙**

...

---

### memo
프로젝트 rest api 재분석 정리 
- **kiosk**
- **reservation**
- **admin**
- **payments(WireMock으로 대체)**
	- WireMock url을 "기타"로 기재 하는것도 좋을듯하다

아스키아트 
- https://monodraw.helftone.com/
- https://asciiflow.com/#/

> mermaid로 대체 가능 

> reference가 없구나 
- https://cucumber.io/docs
- https://wiremock.org/docs/


현재 상태에서 cucumber의 태그 기능을 활용하지 않고 있다. 
wiremock stub 방식을 사용할 때 tip도 있으면 좋지 않을까?
- json과 코드레벨 방식의 장단점 .. (가이드 문서에는 없어도 괜찮을 듯하다)

docker `.env`를 활용하는 방식을 내가 안썼네 
- `.gitignore`에 설정도 필요할 듯 하다.

---

```text
내가 여태까지 질문한 컨텍스트에 대해 기억하고 있나요? kiosk, admin,
reservation, payments(WireMock) 서비스 연계에 대한 인수 테스트 가이드 문서를
작성하려고 합니다. AI와 협업하기 위한 컨텍스트를 만들려고 하고, 이에 앞서
질문을 드려요. 어떤 정보를 줘야 테스트 작성 가이드 문서와 인증/실행 가이드
문서를 잘 작성할 수 있을까요?
```


```text
✦ 네, 이전에 나눈 대화와 현재 컨텍스트를 기억하고 있습니다. kiosk, admin,
  reservation, payments (WireMock) 서비스 연계를 위한 인수 테스트 가이드 문서를
  작성하는 데 필요한 정보를 제공해주시면 제가 더 정확하고 유용한 가이드를 작성할
  수 있습니다.

  테스트 작성 가이드 문서와 인증/실행 가이드 문서를 효과적으로 작성하기 위해
  다음 정보들이 필요합니다.


   1. 프로젝트 및 서비스 개요:
       * 각 서비스(kiosk, admin, reservation, payments)의 주요 역할과 비즈니스
         목적을 간략하게 설명해주세요.
       * 각 서비스가 서로 어떻게 연동되는지, 데이터 흐름은 어떻게 되는지
         고수준에서 설명해주시면 좋습니다. (예: kiosk -> reservation -> payments
         순으로 호출)
       * 각 서비스에서 사용되는 주요 기술 스택(예: Spring Boot, Node.js 등)을
         알려주세요.


   2. 인수 테스트 관련 상세 정보:
       * 현재 인수 테스트는 어떤 시나리오를 중점적으로 다루고 있나요? (예: 제품
         조회 및 예약, 예약 확인, 결제 연동 등)
       * 각 서비스 연동 과정에서 성공 및 실패 시나리오에 대한 기대 결과는
         무엇인가요?
       * payments 서비스의 WireMock은 어떤 결제 시나리오를 모킹하고 있으며, 어떤
         응답을 반환하도록 설정되어 있는지 알려주세요.
         (infra/wiremock/mappings/payment-health.json 외에 다른 매핑 파일도
         있다면 알려주세요.)


   3. 인증/권한 부여 관련 정보:
       * kiosk, admin, reservation 서비스 간 또는 외부 클라이언트와의 인증
         방식은 무엇인가요? (예: JWT, OAuth2, API Key, 세션 등)
       * 테스트를 실행하기 위해 필요한 인증 토큰 또는 자격 증명을 어떻게 획득할
         수 있나요? (예: 특정 API 호출, 개발자용 토큰 등)
       * 각 서비스별로 다른 사용자 역할(Role)이나 권한(Permission)이 있다면
         설명해주세요.


   4. 실행 환경 및 구성:
       * 테스트 환경(개발 환경 또는 CI/CD 환경)에서 서비스들은 어떻게 배포되고
         실행되나요? (Docker Compose를 사용하는 것으로 보이는데, 이에 대한
         자세한 설명이 필요합니다.)
       * 테스트 실행을 위한 전제 조건(예: 특정 JDK 버전, Gradle 설치, Docker
         설치 등)은 무엇인가요?
       * 테스트 실행 시 필요한 환경 변수나 config.properties 파일 외에 추가적인
         설정이 있다면 알려주세요.
       * 로컬에서 서비스를 시작하고 중지하는 일반적인 절차를 알려주세요.


  이 정보들을 바탕으로 제가 인수 테스트 가이드 문서를 구조화하고 내용을
  채워나가겠습니다.
```


Q.
```text
우선 requirements.md와 docs/api에 있는 api 명세를 읽어주세요
```


```
# 인수 테스트 작성 가이드

## 1. 시스템 개요
- 아래 흐름에 대한 도식화 표현 원함 
- **kiosk → reservation → admin**, **kiosk → payments(WireMock)** 연결


## 2. Endpoint 요약

### 2-1. Kiosk

### 2-2. Reservation

### 2-3. Admin

### 2-4. Payments (WireMock)

- 참고. WireMock 맵핑, 확인 주소 포함

  

## 3. 사용자 여정 
- Happy Path, Sad Path

## 4. 인증 규칙
- JWT Bearer Token

## 5. 시드 데이터 규칙

## 6. 시나리오 예시 
### 6-1. 좋은 시나리오
### 6-2. 나쁜 시나리오

## 7. 품질 기준 체크 리스트

## 8. 프로젝트 폴더 구조

## 9. 터미널 실행 명령어
- 로그 디버깅 방법 (정보 제공 예정)

## 10. WireMock 설정


```




```

infra/docker-compose.yml을 읽어주세요. 그리고 docs/acceptance-test-guide.md에 10. WireMock 설정 내용을 아래 첨부한 내용 참고하여 수정해주세요. 이때 서술형으로 나열하기 보다는 요약하는 형태로 해주세요. 그리고 표로 구분하는게 깔끔하다면 표로 표현해주세요

  


WireMock  

개요 

외부 결제 서비스를 WireMock으로 대체하여, e2e 테스트를 수행 

- 아래에 마찬가지로 도식화 

- 테스트 코드에서는 kiosk 서비스에 요청하게 되고, kiosk 서비스에서 payments-mock(wiremock) 요청하게 된다

- kiosk, payments-mock의 호스트 호출, 네트워크 호출 표기도 있으면 좋겠습니다.

  

  

도커 컴포즈 정의

- payments-mock에 해당하는 부분만 추가

- 설정하지 않은 옵션에 대해서도 언급

- kiosk와 payments-mock을 연결하는 환경 변수 설정 언급 

- KIOSK_PAYMENT_BASE_URL=http://atdd-payments-mock:8080

  

WireMock의 응답 탬플릿 설정과 가이드

  

WireMock Admin API 

- curl 명령어로 

- http://localhost:8084가로 접근 가능

```


---

TestConfig 방식에 대해 질문 

```text
1. `TestConfig.java` 방식에 대한 기술 용어:


  TestConfig.java에서 사용된 접근 방식은 Java 애플리케이션의 구성
  관리(Configuration Management)를 위한 일반적인 패턴입니다. 특히 간단한
  설정이나 완전한 의존성 주입/구성 프레임워크(예: Spring Boot의
  @ConfigurationProperties 또는 Apache Commons Configuration)를 사용하지 않거나
  원하지 않을 때 사용됩니다.


  이 정확한 구현에 대한 단일 "기술 용어"는 없지만, 여러 개념을 결합합니다.
   * 속성 로딩(Property Loading): .properties 파일에서 키-값 쌍을 읽는 것입니다.
     이는 Java 애플리케이션이 외부화된 구성을 처리하는 기본적인 방법입니다.
   * 정적 구성 클래스 / 싱글톤 구성(Static Configuration Class / Singleton
     Configuration): TestConfig는 정적 메서드와 정적 Properties 객체를 사용하여
     애플리케이션 전반에 걸쳐 구성에 대한 액세스를 제공하는 사실상의
     싱글톤입니다. 이는 "구성 홀더" 또는 "구성 유틸리티" 클래스의 간단한
     형태입니다.
   * 환경 변수/시스템 속성 재정의(Environment Variable/System Property
     Override): getProperty(String key) 메서드는 .properties 파일에서 로드된
     값을 시스템 속성(System.getProperty(key))으로 재정의하는 것을 보여줍니다.
     이는 구성을 외부화하고 애플리케이션 코드 또는 패키징을 수정하지 않고 런타임
     조정을 허용하는 매우 일반적이고 강력한 패턴입니다. 종종 계층적
     구성(hierarchical configuration) 또는 구성 우선순위(configuration
     precedence)라고 불립니다.
   * "직접 구현(Roll-your-own)" 구성: 사용자가 언급했듯이 많은 최신 프레임워크는
     이를 수행하기 위한 더 추상적이고 기능이 풍부한 방법을 제공합니다(예:
     Spring의 Environment 추상화, MicroProfile Config, Typesafe Config). 이처럼
     직접 구현하는 경우 종종 "커스텀" 또는 "수동으로 만든" 구성 솔루션이라고
  따라서 TestConfig.java를 시스템 속성 재정의를 통한 계층적 속성 로딩을 구현하는
  사용자 정의 정적 구성 유틸리티 클래스라고 설명할 수 있습니다.

  ---

  2. 하이픈을 점으로 변환하는 명명 규칙:


  사용자는 하이픈을 점으로 변환하는 것에 대해 묻고 있습니다.
   * 점 표기법(Dot Notation, 예: `kiosk.base.url`): 이는 Java의
     java.util.Properties 파일에서 속성 키에 대한 표준 규칙입니다. 점은 패키지
     이름이나 객체 필드가 구성되는 방식과 유사하게 계층을 나타내는 데
     사용됩니다.
   * 하이픈(Kebab-case) 표기법(예: `kiosk-base-url`): 이는 YAML, 환경 변수(종종
     UPPER_SNAKE_CASE로 변환됨), 명령줄 인수 또는 Spring Boot와 같은
     프레임워크에서 점 표기법 또는 CamelCase로 자동 변환될 수 있는 다른
     컨텍스트에서 일반적으로 사용됩니다.


  `TestConfig.java` 예시는 `getProperty` 메서드 내에서 하이픈을 점으로 *직접
  변환*하지 않습니다. config.properties의 키가 이미 점 표기법(예:
  kiosk.base.url)으로 되어 있을 것으로 예상합니다.


  그러나 System.getProperty(key, properties.getProperty(key)) 부분은 환경 변수에
  대한 명명 규칙과 관련하여 흥미롭습니다.
   * 많은 최신 프레임워크(예: Spring Boot)에서는 환경 변수(종종 밑줄이 있는
     UPPER_SNAKE_CASE를 사용, 예: KIOSK_BASE_URL) 또는 시스템 속성(점 표기법
     kiosk.base.url 또는 때때로 kiosk-base-url을 사용 가능)이 점으로 구분된 속성
     키에 자동으로 매핑될 수 있습니다.
   * 예를 들어, SPRING_DATASOURCE_URL(환경 변수)은 spring.datasource.url(속성
     키)에 매핑될 수 있습니다. 마찬가지로, 시스템 속성으로 kiosk.base.url은
     config.properties의 값을 명시적으로 재정의합니다.


  따라서 TestConfig.java 자체는 하이픈을 점으로 변환하지는 않지만, 서로 다른
  명명 규칙(kebab-case, snake_case, dot.notation)이 구성에 대해 서로 매핑되는
  일반적인 개념은 구성 프레임워크의 일반적인 기능입니다. java.util.Properties
  표준은 점 표기법입니다. kiosk-base-url이 있는 YAML 파일을 Properties 객체로
  로드해야 하는 경우, 일반적으로 이 변환을 처리하는 라이브러리를 사용합니다(또는
  수동으로 구현합니다).


  요약하자면:
   * Java 속성 표준: 점 표기법(kiosk.base.url).
   * 일반적인 환경 변수 스타일: 대문자 스네이크_케이스(`KIOSK_BASE_URL`).
   * YAML/일부 CLI 인수: 케밥 케이스(kiosk-base-url).


  TestConfig.java는 Java 속성 표준(점 표기법)을 준수하며 시스템 속성을 통한
  재정의를 허용합니다. 시스템 속성 또한 계층 구조에 점 표기법을 일반적으로
  사용합니다. 이 코드 내에서 하이픈을 점으로 명시적으로 변환하는 것은 없지만, 더
  넓은 구성 생태계에서는 이러한 매핑을 종종 처리합니다.
```


환경변수 설정의 우선순위에 대해 
> 이 방법을 접하면서 환경 변수의 우선순위에 대해 의식하게 되었다.

```text
✦ 사용자는 구성 소스의 우선순위에 대한 설명을 요청하고 있으며, 특히 다음 사항을
  구분하고 있습니다.
   1. 프로젝트 구성 파일: .yml 또는 .properties 파일.
   2. CLI 옵션: 명령줄을 통해 전달되는 인수.
   3. 환경 변수: 애플리케이션 실행 전에 export를 사용하여 설정되는 변수.


  이는 다양한 도구와 프레임워크에 고유한 우선순위 규칙이 있기 때문에
  애플리케이션 구성에서 흔히 혼란의 원인이 됩니다. 구성 우선순위가 최신
  애플리케이션 개발, 특히 Java 및 TestConfig.java의 현재 구현 컨텍스트에서
  일반적으로 어떻게 작동하는지에 대한 일반적인 설명을 제공하겠습니다.

  설명을 다음과 같이 구성하겠습니다.


  4. 일반 원칙: 계층 구조 및 재정의
   * 구성이 종종 계층적으로 로드되며, 나중에 로드되는 계층이 이전 계층을
     재정의한다는 것을 설명합니다.
   * 목표는 일반적으로 더 구체적인(런타임, 로컬) 구성이 더 일반적인(패키징된,
     기본) 구성을 재정의하도록 허용하는 것입니다.


  2. `TestConfig.java`의 `getProperty(String key)`에 대한 구체적인 내용:
   * TestConfig.java는 우선순위를 명시적으로 정의합니다.
       * 시스템 속성 (`System.getProperty(key)`): -Dkey=value를 사용하여
         명령줄을 통해 전달됩니다(예: java
         -Dkiosk.base.url=http://localhost:9000 ...). TestConfig.java에서는
         System.getProperty(key)가 먼저 확인됩니다.
       * `config.properties` 파일: TestConfig.java의 정적 초기화 블록에서
         properties 객체로 로드됩니다. 시스템 속성이 발견되지 않으면
         properties.getProperty(key)가 두 번째로 확인됩니다.
   * 따라서 TestConfig.java의 경우 우선순위는 시스템 속성 > `config.properties`
     파일입니다.


  3. 일반적인 애플리케이션 구성 우선순위 (`TestConfig.java`를 넘어서):
   * 기본값/번들 속성: 종종 하드코딩되거나 애플리케이션 내에 번들로 제공됩니다.
     (가장 낮은 우선순위)
   * 애플리케이션 수준의 `.properties`/`.yml` 파일: Spring Boot의
     application.properties 또는 application.yml과 같습니다. 일반적으로
     애플리케이션과 함께 패키징됩니다.
   * 프로필별 `.properties`/`.yml` 파일: (예: application-dev.properties). 특정
     프로필이 활성화되면 일반 애플리케이션 파일을 재정의합니다.
   * 외부 `.properties`/`.yml` 파일: 애플리케이션의 jar/war 외부에 있는 구성
     파일로, 재배포 없이 쉽게 업데이트할 수 있습니다.
   * 환경 변수: OS 수준에서 설정됩니다(예: export
     KIOSK_BASE_BASE_URL=http://some-host).
       * 매핑에 대한 중요 참고 사항: 프레임워크는 환경 변수(일반적으로
         UPPER_SNAKE_CASE 또는 kebab-case를 사용)를 내부 점 표기법 속성 키에
         매핑하는 경우가 많습니다. 예를 들어, 환경 변수 KIOSK_BASE_URL은 속성
         kiosk.base.url에 매핑될 수 있습니다.
   * 명령줄 인수/시스템 속성: 애플리케이션을 시작할 때 직접 전달되는 인수(예:
     Spring Boot의 --kiosk.base.url=... 또는 Java 시스템 속성의
     -Dkiosk.base.url=...). (가장 높은 우선순위)

  4. 구분이 중요한 이유:
   * 로컬 개발: 개발자는 기본값에 .properties 파일을 사용하지만, 특정 로컬
     설정에 대해 환경 변수 또는 CLI 인수로 재정의할 수 있습니다.
   * CI/CD 및 배포: 환경 변수는 CI/CD 파이프라인 및 컨테이너화된 환경(Docker,
     Kubernetes)에서 애플리케이션의 빌드 아티팩트를 수정하지 않고 민감한
     정보(암호, API 키) 또는 환경별 값(데이터베이스 URL, 서비스 엔드포인트)을
     주입하는 데 선호되는 경우가 많습니다.
   * 디버깅: CLI 옵션/시스템 속성은 디버깅 중 빠르고 임시적인 재정의에 가장 높은
     우선순위를 제공합니다.

  코드를 작성하지 않고 이 내용을 명확하게 설명하겠습니다.## 구성 우선순위: 환경
  변수, 시스템 속성, 설정 파일의 관계


  애플리케이션이 실행될 때 다양한 소스에서 설정을 로드하며, 이들 간에는 명확한
  우선순위 규칙이 존재합니다. 일반적으로 더 구체적인 설정이 더 일반적인 설정을
  재정의하는 계층적 구조를 가집니다. 이는 애플리케이션의 배포 환경이나 필요에
  따라 유연하게 설정을 변경할 수 있도록 합니다.

  TestConfig.java의 우선순위

  TestConfig.java의 getProperty(String key) 메서드는 다음과 같은 순서로 설정
  값을 조회합니다.


   1. 시스템 속성 (System Properties):
       * java -Dkey=value ... 형태로 JVM 시작 시 전달되는 속성입니다.
       * 가장 높은 우선순위를 가지며, TestConfig.java에서는
         System.getProperty(key)를 통해 가장 먼저 조회됩니다.
       * 예시: gradlew :atdd-tests:test
         -Dkiosk.base.url=http://custom-kiosk:8080


   2. `config.properties` 파일:
       * 애플리케이션 리소스(src/test/resources/config.properties) 내에 정의된
         키-값 쌍입니다.
       * 시스템 속성에서 해당 키를 찾을 수 없는 경우, config.properties 파일에
         로드된 값(properties.getProperty(key))이 사용됩니다.


  따라서 TestConfig.java의 경우 설정 우선순위는 시스템 속성 >
  `config.properties` 파일 입니다.

  일반적인 애플리케이션 구성 우선순위 (더 넓은 관점)

  많은 현대 프레임워크(예: Spring Boot)에서는 다음과 같은 일반적인 구성 우선순위
  계층을 따릅니다.


   1. 기본값 (Defaults):
       * 애플리케이션 코드 내에 하드코딩되거나 라이브러리에 번들로 제공되는 가장
         일반적인 설정 값입니다. (가장 낮은 우선순위)


   2. 애플리케이션 설정 파일:
       * application.properties, application.yml과 같이 애플리케이션 패키지 내에
         포함된 설정 파일입니다.
       * TestConfig.java의 config.properties와 유사합니다.


   3. 환경 변수 (Environment Variables):
       * 운영체제 수준에서 export KEY=VALUE 형태로 설정되는 변수입니다.
       * 핵심: 많은 프레임워크가 환경 변수 명명 규칙(예: UPPER_SNAKE_CASE 또는
         kebab-case)을 내부적인 설정 키(점 표기법)로 자동 매핑하는 기능을
         제공합니다.
           * 예시: export KIOSK_BASE_URL=http://env-kiosk:8080은 kiosk.base.url
             속성에 매핑될 수 있습니다.
       * 컨테이너 환경(Docker, Kubernetes)에서 환경별 설정이나 민감 정보를
         주입하는 데 매우 유용합니다.


   4. 명령줄 인수 / 시스템 속성:
       * 애플리케이션을 실행할 때 직접 --key=value (Spring Boot) 또는
         -Dkey=value (Java 시스템 속성) 형태로 전달되는 인수입니다.
       * 이들은 보통 가장 높은 우선순위를 가집니다. 디버깅이나 특정 상황에서
         임시적으로 설정을 재정의할 때 자주 사용됩니다.

  구분이 중요한 이유


   * 유연성: 개발자가 로컬 환경에서 테스트하거나 특정 기능을 디버깅할 때,
     애플리케이션을 다시 빌드하거나 설정 파일을 수정하지 않고도 쉽게 설정을
     재정의할 수 있습니다.
   * 환경 격리: 개발, 테스트, 운영과 같은 각 환경에 따라 다른 설정을 적용할 수
     있으며, 특히 CI/CD 파이프라인에서 환경 변수를 통해 쉽게 관리됩니다.
   * 보안: 데이터베이스 비밀번호나 API 키와 같은 민감한 정보는 소스 코드나 설정
     파일에 직접 포함하는 대신 환경 변수로 주입하여 보안을 강화할 수 있습니다.

```


```shell
대부분의 현대 프레임워크, 특히 Spring Boot와 같은 경우 구성 우선순위는 다음과
  같은 순서를 따르는 경향이 있습니다 (우선순위가 낮은 것에서 높은 것으로):


   1. 애플리케이션 기본값 (코드 내 또는 라이브러리)
   2. 설정 파일 (예: `application.properties`, `application.yml` 등)
   3. 환경 변수
   4. 명령줄 인수 / 시스템 속성 (`-Dkey=value`)

  즉, 일반적으로 명령줄 인수나 시스템 속성이 환경 변수보다 더 높은 우선순위를
  가집니다.


  이는 런타임에 가장 구체적이고 임시적인 설정을 제어할 수 있는 수단이 명령줄
  인수/시스템 속성이기 때문입니다. 예를 들어, 배포 시 환경 변수로 데이터베이스
  URL을 설정해두었더라도, 특정 테스트나 디버깅을 위해 명령줄에서 java
  -Dspring.datasource.url=jdbc:h2:mem:testdb와 같이 시스템 속성을 넘겨주면, 환경
  변수 값을 재정의하게 됩니다.


  따라서 환경 변수는 배포 환경에서 유연하고 안전하게 설정을 주입하는 강력한
  수단이지만, 최종적인 재정의 권한은 일반적으로 명령줄 인수나 시스템 속성에
  있습니다.
```


```text
✦ 사용자는 여전히 우선순위를 명확히 하려고 하며, 특히 시스템 속성/환경 변수가
  먼저 읽히고 찾을 수 없으면 파일로 폴백(fallback)하는지(또는 그 반대인지) 묻고
  있습니다. 폴백 방향에 대해 고민하는 것 같습니다.

  "재정의" 대 "폴백"이라는 일반적인 패턴을 명시적으로 설명하겠습니다.


  일반적인 원칙은 다음과 같습니다. 나중에 로드되는(또는 우선순위가 높은) 구성이
  이전에 로드되는(또는 우선순위가 낮은) 구성을 *재정의*합니다. 이는 시간적
  순서로 "먼저" 읽는다는 의미가 아니라, 동일한 키가 여러 소스에 나타날 경우 어떤
  값이 "승리"하는지에 대한 것입니다.


  다음은 재정의 메커니즘에 대한 간략한 설명으로, 자연스럽게 폴백으로 이어집니다.


   1. 기본값 / 가장 낮은 우선순위 (기본 계층): 애플리케이션은 종종 properties
      파일 또는 애플리케이션 내의 하드코딩된 값에서 일부 기본 구성을 시작합니다.
      이를 기본 계층으로 생각하십시오.


   2. 더 높은 우선순위 계층 (재정의): 애플리케이션이 초기화될 때, 더 높은
      우선순위를 가진 소스에서 구성을 로드합니다.
       * 키가 우선순위가 높은 소스(예: 환경 변수)에서 발견되면, 해당 값은
         우선순위가 낮은 소스(예: application.properties)에서 발견된 동일한 키에
         대한 모든 값을 대체(재정의)합니다.
       * 키가 우선순위가 높은 소스에서 발견되지 않으면, 우선순위가 낮은 소스의
         값이 활성 상태로 유지됩니다(이것이 "폴백"입니다).

  따라서 사용자 질문에 직접 답하자면:


  시스템 속성/환경 변수가 먼저 읽히고 찾을 수 없으면 파일을 "검색"하는 방식이
  아닙니다. 오히려 파일이 일반적으로 먼저 읽히고(기본 구성을 제공), 그 후에
  시스템 속성/환경 변수가 읽히며, 기존 키에 대해 포함된 모든 값이 파일의 값을
  재정의합니다. 키가 파일에는 있지만 시스템 속성/환경 변수에는 없는 경우, 파일의
  값이 재정의되지 않았기 때문에 효과적으로 "폴백"이 됩니다.


  제가 이전에 제공했던 우선순위 순서(기본값 < 파일 < 환경 변수 < CLI/시스템
  속성)는 이러한 재정의 동작을 정의합니다. 가장 낮은 우선순위 계층이 초기 값을
  제공하고, 각 후속 우선순위가 높은 계층은 해당 값을 정의하는 경우 해당 값을
  변경할 수 있는 권한을 가집니다. 더 높은 계층이 값을 정의하지 않으면, 다음 낮은
  계층의 값(또는 궁극적으로 기본값)이 사용됩니다.


  "재정의" 개념을 강조하기 위해 신중하게 표현하겠습니다.네, 정확히 그
  반대입니다. 시스템 환경 변수가 먼저 읽히고 없으면 그 하위를 찾아가는 것이
  아니라, 하위 수준의 설정(파일)이 먼저 로드된 후, 상위 수준의 설정(환경 변수,
  시스템 속성, CLI)이 나중에 로드되어 이전에 로드된 값들을 "재정의"하는
  방식입니다.

  이를 "재정의(Override)" 메커니즘이라고 이해하는 것이 중요합니다.


   1. 기본값 또는 설정 파일 로드:
       * 애플리케이션은 가장 일반적인 설정(예: properties 파일)을 먼저 로드하여
         기본 구성을 수립합니다. 이 시점에는 모든 설정 키에 대해 파일에 정의된
         값이 적용됩니다.


   2. 환경 변수 로드 및 재정의:
       * 그 다음, 애플리케이션은 시스템 환경 변수를 읽습니다. 만약 환경 변수에
         설정 파일에서 이미 정의된 키와 동일한 키가 있다면, 환경 변수의 값이
         설정 파일의 값을 덮어씁니다(재정의합니다).
       * 만약 환경 변수에 새로운 키가 있다면, 그 값은 추가됩니다.
       * 환경 변수에 특정 키가 없다면, 설정 파일의 해당 값은 그대로
         유지됩니다(이것이 사실상 폴백처럼 보이는 효과를 냅니다).


   3. 명령줄 인수/시스템 속성 로드 및 재정의:
       * 마지막으로, 명령줄 인수나 시스템 속성을 읽습니다. 이들이 환경 변수나
         설정 파일에서 이미 정의된 키와 동일한 키를 가지고 있다면, 명령줄
         인수/시스템 속성 값이 환경 변수 및 설정 파일의 값을 모두 덮어씁니다.


  결론적으로, 설정은 낮은 우선순위에서 높은 우선순위 순으로 로드되며, 나중에
  로드되는 소스의 값이 이전에 로드된 소스의 동일한 키 값을 재정의합니다. 이는
  가장 세부적이고 즉각적인 설정 변경이 최종적으로 적용되도록 보장하는 강력한
  메커니즘입니다.
```


```java
package com.camping.tests.config;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.util.Properties;

public class TestConfig {

    private static final Properties properties = new Properties();

    static {
        try (InputStream input = TestConfig.class.getClassLoader().getResourceAsStream("config.properties")) {
            if (input == null) {
                throw new RuntimeException("Error: config.properties file not found in classpath.");
            }
            properties.load(input);
        } catch (IOException ex) {
            throw new RuntimeException("Error loading config.properties file: " + ex.getMessage(), ex);
        }
    }

    public static String getProperty(String key) {
        if (key == null || key.trim().isEmpty()) {
            throw new RuntimeException("Property key cannot be null or empty.");
        }

        String normalizedKey = normalizeKey(key);
        String envValue = System.getenv(normalizedKey);
        if(envValue != null && !envValue.isEmpty()) {
            return envValue;
        }

        String sysValue = System.getProperty(normalizedKey);
        if (sysValue != null && !sysValue.isEmpty()) {
            return sysValue;
        }

        String value = properties.getProperty(normalizedKey);
        if (value != null && !value.isEmpty()) {
            return value;
        }

        throw new RuntimeException("Required property '" + key + "' (normalized to '" + normalizedKey + "') not found in system properties or config.properties.");
    }

    public static String getProperty(String key, String defaultValue) {
        try {
            return getProperty(key);
        } catch (RuntimeException e) {
            if (defaultValue != null) return defaultValue;
            throw e;
        }
    }

    private static String normalizeKey(String key) {
        return key.replace('-', '.').replace('_', '.');
    }

	// ..
}
```

현재 코드의 조회 순서는 다음과 같습니다:
1. **OS 환경 변수 (`System.getenv`)** : 가장 높은 우선순위. 도커 컴포즈나 CI/CD 환경에서 주입한 값이 최우선입니다.
2. **자바 실행 옵션 (`System.getProperty`)** : `-Dkey=value`로 전달된 값입니다. 실행 시점에 일시적으로 변경할 때 유용합니다.
3. **파일 설정 (`properties.getProperty`)** : 기본값(Default) 역할을 합니다. `test.properties` 등에 적힌 내용이죠.
    
이 순서는 **"외부에서 주입한 설정이 내부 설정파일을 덮어쓴다"** 는 현대적인 클라우드 네이티브 앱의 표준(The Twelve-Factor App)을 아주 정확히 따르고 있습니다.


6년 차 개발자의 시각에서 답변드리면, **네, 정확하게 짚으셨습니다!** 설계하신 우선순위인 `환경 변수 > 자바 옵션 > 파일 > 하드코딩`은 사실상 모든 현대적 프레임워크가 채택하고 있는 **'국룰'**과 같습니다.

이번에 직접 구현해 보시면서 "왜 외부 주입이 파일보다 우선순위가 높아야 하는가?"를 몸소 체험하신 게 정말 큰 수확이라고 생각합니다. 질문하신 내용들을 실무적인 관점에서 조금 더 깊게 파고들어 볼게요.


 **1. 환경 변수 우선순위의 철학: "바깥에서 안으로"**

프레임워크들이 환경 변수를 가장 높은 순위에 두는 이유는 **'이식성(Portability)'** 때문입니다.

* **파일/하드코딩**: '이미 구워진' 설정입니다. 수정하려면 코드를 고치거나 다시 빌드해야 하죠.
* **자바 옵션(-D)**: '실행 시점'에 주입하는 설정입니다. 빌드 없이 바꿀 수 있습니다.
* **OS 환경 변수**: '인프라'가 주입하는 설정입니다. 도커나 쿠버네티스가 컨테이너를 띄울 때 "너는 이제부터 이 DB를 써!"라고 강제할 수 있는 가장 강력한 수단입니다.

이런 철학을 **"바깥(인프라)에서 안(코드)으로 설정을 밀어 넣는다"**라고 이해하시면 나중에 어떤 프레임워크를 만나도 헷갈리지 않으실 거예요.


 **2. 스프링 부트의 `@PropertySource`와 오버라이딩 원리**

작성자님이 기억하시는 `@PropertySource`와 오버라이딩 원리도 아주 정확합니다.

* **동작 방식**: 스프링은 여러 설정 소스들을 하나의 **'우선순위 리스트(Priority List)'**에 담습니다.
* **오버라이딩**: 동일한 키(`kiosk.url`)가 여러 파일에 있다면, 리스트의 뒤쪽에 추가된(혹은 명시적으로 우선순위가 높은) 설정이 앞의 설정을 **덮어쓰는(Overriding)** 구조입니다.
* **순서**: `@PropertySource("a.properties")`, `@PropertySource("b.properties")` 순으로 선언했다면, `b` 파일의 내용이 `a`를 이기게 됩니다.


 **3. 스프링 부트의 "진짜" 우선순위 (참고용)**

나중에 실무에서 헷갈리실 때를 대비해, 스프링 부트의 실제 우선순위 핵심 3가지만 요약해 드릴게요. (총 17단계가 넘지만 핵심은 이렇습니다.)

1. **Command Line Arguments**: 실행 시 넘기는 인자 (`--server.port=9090`)
2. **OS Environment Variables**: OS 환경 변수
3. **Application Properties**: 우리가 흔히 쓰는 `application.yml` 또는 `properties` 파일

작성자님이 만드신 `TestConfig`는 이 거대한 프레임워크의 메커니즘 중 **가장 핵심적인 3단계**를 아주 효율적으로 직접 구현해 보신 셈입니다.


**💡 6년 차의 인사이트: "의식적인 개발"**

"프레임워크 레벨의 우선순위를 의식하게 되었다"는 말씀이 참 반갑습니다. 많은 개발자가 환경 변수가 꼬였을 때 "왜 안 되지?" 하며 시간을 버리곤 하는데, 이렇게 원리를 꿰뚫고 있으면 **"아, 이건 지금 도커 환경 변수가 로컬 설정을 덮어쓰고 있겠구나"**라고 바로 진단이 가능해집니다.

선택 과제 가이드 문서에도 이 **'우선순위 로직'**을 한 줄 언급해 주세요. AI가 테스트 코드를 생성할 때 "환경에 따라 설정이 변할 수 있음"을 인지하게 하는 아주 중요한 컨텍스트가 됩니다.


토비님의 강의에 환경 변수에 대한 내용이 있었구나
- https://soono-991.tistory.com/27