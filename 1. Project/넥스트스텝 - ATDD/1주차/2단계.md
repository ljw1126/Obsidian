

**참고.**
- [REST Assured](https://rest-assured.io/)
- https://sjiwon-dev.tistory.com/29

> - 테스트 데이터 격리 방법에 대해 내 저장소에 찾아보기
> - 테스트 데이터 격리 방법 비교 작성
> - custom matcher 관련 내용 조사

**테스트 데이터 격리**
- @DirtiesContext 사용 고려 가능
- @Sql을 활용한 쿼리 수행 고려 가능
- 비즈니스 로직(서비스 클래스 활용) 활용 고려 가능

**테스트 가독성**
- 테스트 메서드명은 한글로 작성 가능
- 비즈니스 용어 사용
- 매직 넘버 대신 의미 있는 상수 사용
- 복잡한 assertion은 custom matcher로 추출


`@PersistenceContext` vs `@Autowired`

`@ActiveProfiles` vs `@Profiles`
- `@ActiveProfiles`는 테스트에서 어떤 profiles로 실행할지 설정
- `@Profiles`는 특정 profiles 일때만 동작한다는 설정
- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ActiveProfiles.html
- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Profile.html

**Step2 리팩터링 내용**
- ReservationRequest 생성이 반복된다 
	- 팩토리로 분리 
- API로 예약 생성, 검증에 대한 내용이 반복되고 있다.


**Step3 고려할 내용**
- 글로벌 예외 처리
- 예외 메시지, 상태 코드 관리
- ReservationRequest에 빌더 패턴 적용
- 성수기 요금 계산할 때 응답에 요금 정보가 없다 
	- 현재 ReservationResponse에 가격 정보(totalPrice)가 포함되어 있지 않아 검증 불가.
- 서비스에 하드 코딩된 변수들
- 연박이 안되는데 .. 다 검색이 되버리네 


---


```
@Disabled("성공 2건이 나오는 버그 확인하여 비활성화")  
@DisplayName("동일한 사이트와 기간에 대해 중복 예약 시도를 하면 한명만 예약된다 (동시성 제어)")  
@Test  
void 동일한_사이트와_기간에_대해_중복_예약_시도를_하면_한명만_예약된다() throws InterruptedException {  
    // given  
    LocalDate 시작일 = LocalDate.now().plusDays(10);  
    LocalDate 종료일 = 시작일.plusDays(1);  
  
    ReservationRequest 홍길동_예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");  
    ReservationRequest 이순신_예약요청 = 예약요청_생성(시작일, 종료일, "이순신", "01056781234");  
  
    int 동시요청_개수 = 2;  
    ExecutorService executorService = Executors.newFixedThreadPool(동시요청_개수);  
    CountDownLatch 준비_완료 = new CountDownLatch(동시요청_개수);  
    CountDownLatch 동시에_시작 = new CountDownLatch(1);  
    CountDownLatch 종료_대기 = new CountDownLatch(동시요청_개수);  
  
    AtomicInteger 예약_성공 = new AtomicInteger(0);  
    AtomicInteger 예약_실패 = new AtomicInteger(0);  
  
    executorService.submit(() -> {  
        try {  
            준비_완료.countDown();  
            동시에_시작.await();  
  
            var 예약_응답 = 예약을_요청한다(홍길동_예약요청);  
  
            if (예약_응답.statusCode() == HttpStatus.CREATED.value()) {  
                예약_성공.incrementAndGet();  
            } else {  
                예약_실패.incrementAndGet();  
            }        } catch (Throwable e) {  
            예약_실패.incrementAndGet();  
        } finally {  
            종료_대기.countDown();  
        }    });  
    executorService.submit(() -> {  
          try {  
                준비_완료.countDown();  
                동시에_시작.await();  
  
                var 예약_응답 = 예약을_요청한다(이순신_예약요청);  
  
                if (예약_응답.statusCode() == HttpStatus.CREATED.value()) {  
                  예약_성공.incrementAndGet();  
                } else {  
                  예약_실패.incrementAndGet();  
                }          } catch (Throwable e) {  
                예약_실패.incrementAndGet();  
          } finally {  
                종료_대기.countDown();  
          }    });  
    준비_완료.await();  
    동시에_시작.countDown();  
    종료_대기.await();  
    executorService.shutdown();  
  
    // then  
    assertThat(예약_성공.get()).isEqualTo(1);  
    assertThat(예약_실패.get()).isEqualTo(1);  
}
```

---

### Step2 코드 리뷰 댓글
https://github.com/next-step/atdd-camping-reservation/pull/71

```csharp
campsiteRepository.save(new Campsite("A-1", "Large Site", 6));
campsiteRepository.save(new Campsite("B-1", "Large Site", 4));
```

```text
테스트를 위한 사전값 설정이군요!

시나리오의 스텝을 구현한 다른 로직과 동일하게 의도가 드러나게 표현해보면 어떨까요?
사이트가 미리 설정되어있다 라던지 사이트 정보가 미리 저장되어있다 등으로 표현할 수 있겠네요!
```


2)
```csharp
// then
예약이_거부되었다(응답);
에러메시지가_확인된다(응답, "전화번호 형식이 올바르지 않습니다.");
```

```text
검증 시 기준이되는 메시지를 상수로 관리해도 좋을 것 같습니다!
```


3)
```csharp
// Feature 2. 사이트 가용성
@DisplayName("예약이 없는 기간으로 검색 시 가능한 예약 가능한 사이트 목록이 반환된다")
@Test
```

```text
예약 인수 테스트 클래스가 너무 커질 수 있어요!  
클래스를 분리하면 좋을 것 같은데 어떤 기준으로 클래스를 분리하면 좋을까요?
```

- AcceptancsTest 부모 클래스를 만든다 
	- 그리고 클래스를 분리한다 
	- 그런데 컨텍스트가 연달아 올라갈텐데 .. 켄텍스트 공유하려면 주입 받는 빈 객체가 동일해야 한다라고 알고 있다. (컨텍스트 캐싱을 찾아봐야 할 듯 하다)


4)
```csharp
@DisplayName("성수기 주말 할증 요금이 자동 계산된다")
@Test
void 성수기_주말_할증_요금이_자동_계산된다() {
	// given
	LocalDate 오늘 = LocalDate.now();
	LocalDate 성수기_시작 = LocalDate.of(오늘.getYear(), 7, 1);
	if (오늘.isAfter(성수기_시작)) {
	  성수기_시작 = 성수기_시작.plusYears(1); // 올해 성수기가 지났으면 내년으로
	}
	 
    // ..    
}    
```




5)
```csharp
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ConcurrencyTestHelper {
```

```text
동기화 테스트는 참 쉽지 않은 테스트인 것 같아요.
저는 동기화 테스트는 주로 인수 테스트에서는 가급적 하지 않고
단위 테스트나 통합 테스트에서 하는 편입니다.

인수 조건 및 시나리오 도출 시 모든 부분에 대한 검증을 하는 것은 어려울 수 있어요.
예를 들면 지금 처럼 동기화와 관련된 부분이라던지, 성능, 보안, 정합성 등이 있습니다.
*가급적이면 기능(시나리오)위주로 먼저 구축해주시고 위 처럼 구축하기 어려운 부분은
API 레벨의 인수 테스트 보다는 검증 범위를 축소해서 대체하는 방법을 권장드립니다!

참고로 진우님께서는 동기화 테스트에서 CyclicBarrier 대신 CountDownLatch를 사용해주셨습니다!
```
- Gemini
	- "인수 테스트는 '사용자 시나리오'에 집중하고, 동시성 같은 기술적 복잡도는 더 낮은 레벨(단위/통합 테스트)에서 정교하게 다루라"


```
이를 반영한 3단계 진행 가이드를 정리해 드립니다.

1. 우선순위 1: 확인된 버그 수정 (인수 테스트 기반)
비활성화(@Disabled)해두었던 인수 테스트들을 하나씩 깨우면서 버그를 수정하세요.

버그 1: 예약 취소 시 재고 미복구

원인: 주로 취소 로직에서 상태값만 변경하고, 검색 시 참조하는 '가용성 데이터'나 '날짜 점유 테이블'을 업데이트하지 않았을 때 발생합니다.

해결: 예약을_취소한다 API 호출 시, 해당 날짜의 사이트 점유 상태를 해제하는 로직을 추가하세요.

버그 2: 중간 날짜 예약 점유 미검러냄

원인: 검색 쿼리에서 시작일과 종료일만 체크하고, 그 사이 기간(Between)에 대한 중첩 확인(Overlap) 로직이 누락되었을 가능성이 큽니다.

해결: 날짜 겹침 공식(A.start < B.end AND A.end > B.start)을 쿼리에 적용하여 중간 날짜 점유를 정확히 걸러내세요.


2. 우선순위 2: 동시성 테스트 전략 수정
리뷰어님의 가이드에 따라, 인수 테스트에서의 동시성 테스트는 삭제하거나 아주 가볍게 유지하고, 대신 통합 테스트 레벨로 옮기세요.

인수 테스트: 동시성 테스트 코드를 삭제하거나, 시나리오 위주의 흐름만 남깁니다.

통합 테스트 (@SpringBootTest):

src/test/java/.../service 패키지에 테스트 클래스를 만듭니다.

RestAssured 대신 Service 클래스를 직접 호출하는 방식으로 동시성 테스트를 작성하세요.

이 레벨에서는 ExecutorService를 써도 네트워크 레이턴시나 HTTP 오버헤드가 없어 훨씬 빠르고 안정적으로 버그(성공 2건)를 재현하고 수정할 수 있습니다.

해결책: 데이터베이스의 Unique 제약 조건이나 **비관적 락(Pessimistic Lock)**을 도입하여 원자성을 보장하세요.



3. 추천하는 3단계 진행 순서
Step 3-1 (Red): @Disabled를 제거하여 테스트가 실패하는 것을 확인합니다. (버그 확인)

Step 3-2 (Green): 검색 로직(중간 날짜)과 취소 로직(재고 복구)을 수정하여 인수 테스트를 통과시킵니다.

Step 3-3 (Refactor/Tech): 동시성 제어 로직을 구현합니다. 이때 인수 테스트가 아닌 서비스 통합 테스트를 먼저 작성하여 실패를 확인하고, 락(Lock)을 적용하여 성공시킵니다.

Step 3-4 (Clean): 비대해진 인수 테스트 클래스들을 어제 논의한 대로 **Command(생성/취소)와 Query(검색)**로 분리합니다.


💡 6년 차의 인사이트
리뷰어님이 말씀하신 "검증 범위를 축소해서 대체"하라는 것은, **"사용자는 한 번에 한 번의 예약을 하지만, 시스템은 동시에 100건을 견뎌야 한다. 이 중 '100건을 견디는 기술적 검증'은 단위/통합 테스트의 몫이다"**라는 의미입니다.

이렇게 하면 인수 테스트는 훨씬 가벼워지고 유지보수하기 좋아집니다.

🚀 지금 바로 시작해볼까요?
가장 먼저 '중간 날짜 예약 점유' 버그부터 잡아보시는 걸 추천합니다. 쿼리문 하나로 해결될 수 있는 부분이라 성공의 맛을 빨리 보실 수 있을 거예요.

혹시 중간 날짜를 걸러내는 SQL 쿼리나 JPA QueryDSL 로직이 잘 안 풀리시면 말씀해 주세요. 같이 짜보겠습니다! 어느 버그부터 먼저 손대보시겠어요?
```


---

https://github.com/wlghsp/atdd-camping-reservation/blob/step3/src/test/java/com/camping/legacy/acceptance/ReservationSteps.java

createReservation이라는 걸로 추상화를 함 
- ReservationRequest도 이 안에서 호출을 하다보니, 테스트 코드의 중복을 줄 일 수 있어 보인다.

날짜를 `LocalDate.now()`를 계속하는데 이것 조차 간소화 할 수 있지 않을가 싶다.
- 다른 테스트는 숫자만 넣어도 상관없는데 
	- 성수기는 조금 문제가 있어 보인다. 7,8월이 되다보니 만약에 현실 날짜가 7,8월이 지나가게 되면 테스트가 실패하게 된다 

공통 상수 클래스를 관리하는 것도 하나의 방법이 아닌가 싶다

캠프 사이트 생성도 메서드 추상화 하는게 좋을듯하다



생각 나는 버그 
- 예약 취소시 .. 재 검색이 안되는 버그 
- `기간내_중간_날짜가_예약된_사이트는_검색에서_제외된다()` 에서 