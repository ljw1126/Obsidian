

**참고.**
- [REST Assured](https://rest-assured.io/)
- https://sjiwon-dev.tistory.com/29

> - 테스트 데이터 격리 방법에 대해 내 저장소에 찾아보기
> - 테스트 데이터 격리 방법 비교 작성
> - custom matcher 관련 내용 조사

**테스트 데이터 격리**
- @DirtiesContext 사용 고려 가능
- @Sql을 활용한 쿼리 수행 고려 가능
- 비즈니스 로직(서비스 클래스 활용) 활용 고려 가능

**테스트 가독성**
- 테스트 메서드명은 한글로 작성 가능
- 비즈니스 용어 사용
- 매직 넘버 대신 의미 있는 상수 사용
- 복잡한 assertion은 custom matcher로 추출


`@PersistenceContext` vs `@Autowired`

`@ActiveProfiles` vs `@Profiles`
- `@ActiveProfiles`는 테스트에서 어떤 profiles로 실행할지 설정
- `@Profiles`는 특정 profiles 일때만 동작한다는 설정
- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ActiveProfiles.html
- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Profile.html

**Step2 리팩터링 내용**
- ReservationRequest 생성이 반복된다 
	- 팩토리로 분리 
- API로 예약 생성, 검증에 대한 내용이 반복되고 있다.


**Step3 고려할 내용**
- 글로벌 예외 처리
- 예외 메시지, 상태 코드 관리
- ReservationRequest에 빌더 패턴 적용
- 성수기 요금 계산할 때 응답에 요금 정보가 없다 
	- 현재 ReservationResponse에 가격 정보(totalPrice)가 포함되어 있지 않아 검증 불가.
- 서비스에 하드 코딩된 변수들
- 연박이 안되는데 .. 다 검색이 되버리네 


---


```
@Disabled("성공 2건이 나오는 버그 확인하여 비활성화")  
@DisplayName("동일한 사이트와 기간에 대해 중복 예약 시도를 하면 한명만 예약된다 (동시성 제어)")  
@Test  
void 동일한_사이트와_기간에_대해_중복_예약_시도를_하면_한명만_예약된다() throws InterruptedException {  
    // given  
    LocalDate 시작일 = LocalDate.now().plusDays(10);  
    LocalDate 종료일 = 시작일.plusDays(1);  
  
    ReservationRequest 홍길동_예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");  
    ReservationRequest 이순신_예약요청 = 예약요청_생성(시작일, 종료일, "이순신", "01056781234");  
  
    int 동시요청_개수 = 2;  
    ExecutorService executorService = Executors.newFixedThreadPool(동시요청_개수);  
    CountDownLatch 준비_완료 = new CountDownLatch(동시요청_개수);  
    CountDownLatch 동시에_시작 = new CountDownLatch(1);  
    CountDownLatch 종료_대기 = new CountDownLatch(동시요청_개수);  
  
    AtomicInteger 예약_성공 = new AtomicInteger(0);  
    AtomicInteger 예약_실패 = new AtomicInteger(0);  
  
    executorService.submit(() -> {  
        try {  
            준비_완료.countDown();  
            동시에_시작.await();  
  
            var 예약_응답 = 예약을_요청한다(홍길동_예약요청);  
  
            if (예약_응답.statusCode() == HttpStatus.CREATED.value()) {  
                예약_성공.incrementAndGet();  
            } else {  
                예약_실패.incrementAndGet();  
            }        } catch (Throwable e) {  
            예약_실패.incrementAndGet();  
        } finally {  
            종료_대기.countDown();  
        }    });  
    executorService.submit(() -> {  
          try {  
                준비_완료.countDown();  
                동시에_시작.await();  
  
                var 예약_응답 = 예약을_요청한다(이순신_예약요청);  
  
                if (예약_응답.statusCode() == HttpStatus.CREATED.value()) {  
                  예약_성공.incrementAndGet();  
                } else {  
                  예약_실패.incrementAndGet();  
                }          } catch (Throwable e) {  
                예약_실패.incrementAndGet();  
          } finally {  
                종료_대기.countDown();  
          }    });  
    준비_완료.await();  
    동시에_시작.countDown();  
    종료_대기.await();  
    executorService.shutdown();  
  
    // then  
    assertThat(예약_성공.get()).isEqualTo(1);  
    assertThat(예약_실패.get()).isEqualTo(1);  
}
```