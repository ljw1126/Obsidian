

**참고.**
- [REST Assured](https://rest-assured.io/)
- https://sjiwon-dev.tistory.com/29

> - 테스트 데이터 격리 방법에 대해 내 저장소에 찾아보기
> - 테스트 데이터 격리 방법 비교 작성
> - custom matcher 관련 내용 조사

**테스트 데이터 격리**
- @DirtiesContext 사용 고려 가능
- @Sql을 활용한 쿼리 수행 고려 가능
- 비즈니스 로직(서비스 클래스 활용) 활용 고려 가능

**테스트 가독성**
- 테스트 메서드명은 한글로 작성 가능
- 비즈니스 용어 사용
- 매직 넘버 대신 의미 있는 상수 사용
- 복잡한 assertion은 custom matcher로 추출


`@PersistenceContext` vs `@Autowired`

`@ActiveProfiles` vs `@Profiles`
- `@ActiveProfiles`는 테스트에서 어떤 profiles로 실행할지 설정
- `@Profiles`는 특정 profiles 일때만 동작한다는 설정
- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ActiveProfiles.html
- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Profile.html

**Step2 리팩터링 내용**
- ReservationRequest 생성이 반복된다 
	- 팩토리로 분리 
- API로 예약 생성, 검증에 대한 내용이 반복되고 있다.


**Step3 고려할 내용**
- 글로벌 예외 처리
- 예외 메시지, 상태 코드 관리
- ReservationRequest에 빌더 패턴 적용
- 성수기 요금 계산할 때 응답에 요금 정보가 없다 
	- 현재 ReservationResponse에 가격 정보(totalPrice)가 포함되어 있지 않아 검증 불가.
- 서비스에 하드 코딩된 변수들
- 연박이 안되는데 .. 다 검색이 되버리네 


---


```
@Disabled("성공 2건이 나오는 버그 확인하여 비활성화")  
@DisplayName("동일한 사이트와 기간에 대해 중복 예약 시도를 하면 한명만 예약된다 (동시성 제어)")  
@Test  
void 동일한_사이트와_기간에_대해_중복_예약_시도를_하면_한명만_예약된다() throws InterruptedException {  
    // given  
    LocalDate 시작일 = LocalDate.now().plusDays(10);  
    LocalDate 종료일 = 시작일.plusDays(1);  
  
    ReservationRequest 홍길동_예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");  
    ReservationRequest 이순신_예약요청 = 예약요청_생성(시작일, 종료일, "이순신", "01056781234");  
  
    int 동시요청_개수 = 2;  
    ExecutorService executorService = Executors.newFixedThreadPool(동시요청_개수);  
    CountDownLatch 준비_완료 = new CountDownLatch(동시요청_개수);  
    CountDownLatch 동시에_시작 = new CountDownLatch(1);  
    CountDownLatch 종료_대기 = new CountDownLatch(동시요청_개수);  
  
    AtomicInteger 예약_성공 = new AtomicInteger(0);  
    AtomicInteger 예약_실패 = new AtomicInteger(0);  
  
    executorService.submit(() -> {  
        try {  
            준비_완료.countDown();  
            동시에_시작.await();  
  
            var 예약_응답 = 예약을_요청한다(홍길동_예약요청);  
  
            if (예약_응답.statusCode() == HttpStatus.CREATED.value()) {  
                예약_성공.incrementAndGet();  
            } else {  
                예약_실패.incrementAndGet();  
            }        } catch (Throwable e) {  
            예약_실패.incrementAndGet();  
        } finally {  
            종료_대기.countDown();  
        }    });  
    executorService.submit(() -> {  
          try {  
                준비_완료.countDown();  
                동시에_시작.await();  
  
                var 예약_응답 = 예약을_요청한다(이순신_예약요청);  
  
                if (예약_응답.statusCode() == HttpStatus.CREATED.value()) {  
                  예약_성공.incrementAndGet();  
                } else {  
                  예약_실패.incrementAndGet();  
                }          } catch (Throwable e) {  
                예약_실패.incrementAndGet();  
          } finally {  
                종료_대기.countDown();  
          }    });  
    준비_완료.await();  
    동시에_시작.countDown();  
    종료_대기.await();  
    executorService.shutdown();  
  
    // then  
    assertThat(예약_성공.get()).isEqualTo(1);  
    assertThat(예약_실패.get()).isEqualTo(1);  
}
```

---

### Step2 코드 리뷰 댓글
https://github.com/next-step/atdd-camping-reservation/pull/71

```csharp
campsiteRepository.save(new Campsite("A-1", "Large Site", 6));
campsiteRepository.save(new Campsite("B-1", "Large Site", 4));
```

```text
테스트를 위한 사전값 설정이군요!

시나리오의 스텝을 구현한 다른 로직과 동일하게 의도가 드러나게 표현해보면 어떨까요?
사이트가 미리 설정되어있다 라던지 사이트 정보가 미리 저장되어있다 등으로 표현할 수 있겠네요!
```


2)
```csharp
// then
예약이_거부되었다(응답);
에러메시지가_확인된다(응답, "전화번호 형식이 올바르지 않습니다.");
```

```text
검증 시 기준이되는 메시지를 상수로 관리해도 좋을 것 같습니다!
```


3)
```csharp
// Feature 2. 사이트 가용성
@DisplayName("예약이 없는 기간으로 검색 시 가능한 예약 가능한 사이트 목록이 반환된다")
@Test
```

```text
예약 인수 테스트 클래스가 너무 커질 수 있어요!  
클래스를 분리하면 좋을 것 같은데 어떤 기준으로 클래스를 분리하면 좋을까요?
```

- AcceptancsTest 부모 클래스를 만든다 
	- 그리고 클래스를 분리한다 
	- 그런데 컨텍스트가 연달아 올라갈텐데 .. 켄텍스트 공유하려면 주입 받는 빈 객체가 동일해야 한다라고 알고 있다. (컨텍스트 캐싱을 찾아봐야 할 듯 하다)


4)
```csharp
@DisplayName("성수기 주말 할증 요금이 자동 계산된다")
@Test
void 성수기_주말_할증_요금이_자동_계산된다() {
	// given
	LocalDate 오늘 = LocalDate.now();
	LocalDate 성수기_시작 = LocalDate.of(오늘.getYear(), 7, 1);
	if (오늘.isAfter(성수기_시작)) {
	  성수기_시작 = 성수기_시작.plusYears(1); // 올해 성수기가 지났으면 내년으로
	}
	 
    // ..    
}    
```




5)
```csharp
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ConcurrencyTestHelper {
```

```text
동기화 테스트는 참 쉽지 않은 테스트인 것 같아요.
저는 동기화 테스트는 주로 인수 테스트에서는 가급적 하지 않고
단위 테스트나 통합 테스트에서 하는 편입니다.

인수 조건 및 시나리오 도출 시 모든 부분에 대한 검증을 하는 것은 어려울 수 있어요.
예를 들면 지금 처럼 동기화와 관련된 부분이라던지, 성능, 보안, 정합성 등이 있습니다.
*가급적이면 기능(시나리오)위주로 먼저 구축해주시고 위 처럼 구축하기 어려운 부분은
API 레벨의 인수 테스트 보다는 검증 범위를 축소해서 대체하는 방법을 권장드립니다!

참고로 진우님께서는 동기화 테스트에서 CyclicBarrier 대신 CountDownLatch를 사용해주셨습니다!
```
- Gemini
	- "인수 테스트는 '사용자 시나리오'에 집중하고, 동시성 같은 기술적 복잡도는 더 낮은 레벨(단위/통합 테스트)에서 정교하게 다루라"


```
이를 반영한 3단계 진행 가이드를 정리해 드립니다.

1. 우선순위 1: 확인된 버그 수정 (인수 테스트 기반)
비활성화(@Disabled)해두었던 인수 테스트들을 하나씩 깨우면서 버그를 수정하세요.

버그 1: 예약 취소 시 재고 미복구

원인: 주로 취소 로직에서 상태값만 변경하고, 검색 시 참조하는 '가용성 데이터'나 '날짜 점유 테이블'을 업데이트하지 않았을 때 발생합니다.

해결: 예약을_취소한다 API 호출 시, 해당 날짜의 사이트 점유 상태를 해제하는 로직을 추가하세요.

버그 2: 중간 날짜 예약 점유 미검러냄

원인: 검색 쿼리에서 시작일과 종료일만 체크하고, 그 사이 기간(Between)에 대한 중첩 확인(Overlap) 로직이 누락되었을 가능성이 큽니다.

해결: 날짜 겹침 공식(A.start < B.end AND A.end > B.start)을 쿼리에 적용하여 중간 날짜 점유를 정확히 걸러내세요.


2. 우선순위 2: 동시성 테스트 전략 수정
리뷰어님의 가이드에 따라, 인수 테스트에서의 동시성 테스트는 삭제하거나 아주 가볍게 유지하고, 대신 통합 테스트 레벨로 옮기세요.

인수 테스트: 동시성 테스트 코드를 삭제하거나, 시나리오 위주의 흐름만 남깁니다.

통합 테스트 (@SpringBootTest):

src/test/java/.../service 패키지에 테스트 클래스를 만듭니다.

RestAssured 대신 Service 클래스를 직접 호출하는 방식으로 동시성 테스트를 작성하세요.

이 레벨에서는 ExecutorService를 써도 네트워크 레이턴시나 HTTP 오버헤드가 없어 훨씬 빠르고 안정적으로 버그(성공 2건)를 재현하고 수정할 수 있습니다.

해결책: 데이터베이스의 Unique 제약 조건이나 **비관적 락(Pessimistic Lock)**을 도입하여 원자성을 보장하세요.



3. 추천하는 3단계 진행 순서
Step 3-1 (Red): @Disabled를 제거하여 테스트가 실패하는 것을 확인합니다. (버그 확인)

Step 3-2 (Green): 검색 로직(중간 날짜)과 취소 로직(재고 복구)을 수정하여 인수 테스트를 통과시킵니다.

Step 3-3 (Refactor/Tech): 동시성 제어 로직을 구현합니다. 이때 인수 테스트가 아닌 서비스 통합 테스트를 먼저 작성하여 실패를 확인하고, 락(Lock)을 적용하여 성공시킵니다.

Step 3-4 (Clean): 비대해진 인수 테스트 클래스들을 어제 논의한 대로 **Command(생성/취소)와 Query(검색)**로 분리합니다.


💡 6년 차의 인사이트
리뷰어님이 말씀하신 "검증 범위를 축소해서 대체"하라는 것은, **"사용자는 한 번에 한 번의 예약을 하지만, 시스템은 동시에 100건을 견뎌야 한다. 이 중 '100건을 견디는 기술적 검증'은 단위/통합 테스트의 몫이다"**라는 의미입니다.

이렇게 하면 인수 테스트는 훨씬 가벼워지고 유지보수하기 좋아집니다.

🚀 지금 바로 시작해볼까요?
가장 먼저 '중간 날짜 예약 점유' 버그부터 잡아보시는 걸 추천합니다. 쿼리문 하나로 해결될 수 있는 부분이라 성공의 맛을 빨리 보실 수 있을 거예요.

혹시 중간 날짜를 걸러내는 SQL 쿼리나 JPA QueryDSL 로직이 잘 안 풀리시면 말씀해 주세요. 같이 짜보겠습니다! 어느 버그부터 먼저 손대보시겠어요?
```


---

https://github.com/wlghsp/atdd-camping-reservation/blob/step3/src/test/java/com/camping/legacy/acceptance/ReservationSteps.java

createReservation이라는 걸로 추상화를 함 
- ReservationRequest도 이 안에서 호출을 하다보니, 테스트 코드의 중복을 줄 일 수 있어 보인다.

날짜를 `LocalDate.now()`를 계속하는데 이것 조차 간소화 할 수 있지 않을가 싶다.
- 다른 테스트는 숫자만 넣어도 상관없는데 
	- 성수기는 조금 문제가 있어 보인다. 7,8월이 되다보니 만약에 현실 날짜가 7,8월이 지나가게 되면 테스트가 실패하게 된다 

공통 상수 클래스를 관리하는 것도 하나의 방법이 아닌가 싶다

캠프 사이트 생성도 메서드 추상화 하는게 좋을듯하다





---

생각 나는 버그 
- 예약 취소시 하기 전인데
	- 예약 점유 된 상태인데 사이트 검색 조회 노출되는
- `기간내_중간_날짜가_예약된_사이트는_검색에서_제외된다()` 에서
	- 중간 점유 하는 사이트가 노출되는 상태
		- 사이트의 

```text
예약 취소하기 전인데 사이트 검색에 노출되는 버그나
중간 날짜에 예약된 사이트가 검색에 노출되는 버그나
이러한걸 사이트의 신뢰성 문제라고 부르면 될까요

1. 데이터 정합성 (Data Integrity / Consistency)
가장 보편적이고 적절한 표현입니다. **"예약 상태와 실제 검색 결과가 일치하지 않는 문제"**를 뜻합니다.

예약 취소 전 노출 버그: "예약 상태(Status)와 가용 재고(Inventory) 간의 정합성이 깨졌다"라고 표현합니다.

중간 날짜 노출 버그: "날짜 기반의 조회 로직에서 데이터 일관성이 유지되지 않는다"라고 합니다.

2. 가용성 관리 오류 (Availability Management Issue)
캠핑장이나 호텔 같은 예약 도메인에서 아주 구체적으로 사용하는 표현입니다.

"취소되지 않은 예약이 있음에도 사이트가 'Available' 상태로 노출되는 것은 가용성 체크 로직의 결함이다"라고 표현할 수 있습니다.

사용자에게는 '예약 가능한 줄 알았는데 안 되는' 부정적인 경험을 주기 때문에 재고 관리(Inventory Management) 오류라고도 부릅니다.

3. 과다 예약 위험 (Overbooking Risk)
이 버그들이 방치되었을 때 발생할 비즈니스적 위험을 강조하는 용어입니다.

"중간 날짜 점유 사이트가 노출되는 버그는 **오버부킹(Double Booking)**으로 이어져 시스템의 신뢰도를 실질적으로 떨어뜨리는 중대한 결함이다"라고 정의할 수 있습니다.
```


```java
boolean isAvailable = !reservationRepository.existsByCampsiteAndStatusNotAndEndDateGreaterThanAndStartDateLessThan(
                site, "CANCELLED", request.getStartDate(), request.getEndDate());

// ReservationRepository
boolean existsByCampsiteAndStatusNotAndEndDateGreaterThanAndStartDateLessThan(  
    Campsite campsite, String status, LocalDate startDate, LocalDate endDate);
```
- 예약 중에 Campsite된 예약이고 `CANCELLED` 상태이 아니면서 
	- 그리고 `검색 시작일 < 예약 종료일`, `예약 시작일 < 검색 종료일` 인 경우를 찾는거네

날짜 조건에 equal이 들어가지 않는 이유에 대해 

```text
날짜 겹침 공식에서 왜 `=`을 빼고 초과(`>`)와 미만(`<`)만 사용하는지에 대한 의문은 예약 시스템을 설계할 때 반드시 마주하게 되는 아주 좋은 질문입니다.

결론부터 말씀드리면, 이는 **"체크아웃 날짜와 다음 예약의 체크인 날짜가 겹칠 수 있기 때문"**입니다.

---

### 1. 캠핑장/호텔 예약의 '박(Night)' 개념

일반적인 숙박 예약은 당일 오후에 입실하여 다음 날 오전에 퇴실합니다.

* **예약 A**: 1월 10일(입실) ~ **1월 11일(퇴실)** -> 1박
* **예약 B**: **1월 11일(입실)** ~ 1월 12일(퇴실) -> 1박

위 시나리오에서 11일은 **A가 나가는 날이자 B가 들어오는 날**입니다. 만약 공식에 `=`을 넣게 되면 어떻게 될까요?

* `1월 11일(A 종료일) >= 1월 11일(B 시작일)` 이 참이 되어버려, 실제로는 겹치지 않는데도 시스템은 **중복 예약(Conflict)**으로 판단하고 B의 예약을 막아버리게 됩니다.

---

### 2. 공식의 동작 원리 분석

다시 공식을 보겠습니다.
`existEndDate > newStartDate` AND `existStartDate < newEndDate`

* **케이스 1: 연속된 예약 (A: 10~11일, B: 11~12일)**
* `11(A 종료) > 11(B 시작)` -> **False**
* 첫 번째 조건부터 `False`이므로 전체 결과는 `False` (중복 아님으로 정상 판정!)


* **케이스 2: 1박이라도 겹치는 경우 (A: 10~12일, B: 11~13일)**
* `12(A 종료) > 11(B 시작)` -> **True**
* `10(A 시작) < 13(B 종료)` -> **True**
* 둘 다 `True`이므로 `Conflict` 발생 (예약 불가로 정상 판정!)



---

### 3. 만약 '날짜' 단위가 아닌 '시간' 단위라면?

만약 캠핑장이 일 단위가 아니라 **시간 단위(예: 11일 11시 퇴실, 11일 11시 입실)**로 운영된다면, 그때는 상황에 따라 `=`을 포함해야 할 수도 있습니다. 하지만 대부분의 숙박 시스템은 **"종료일 = 다음 사람 시작일"**이 허용되므로, 초과/미만 조건을 사용하는 것이 표준입니다.

---

### 💡 6년 차의 조언: '당일 예약 후 당일 취소'와 재고 복구

이 날짜 공식이 정확히 작동한다면, 아까 고민하셨던 **버그 1(예약 취소 시 재고 복구)**도 아주 깔끔하게 해결됩니다.

1. 사용자가 취소를 하면 `status`를 `"CANCELLED"`로 바꿉니다.
2. `existsBy...AndStatusNot("CANCELLED")` 쿼리는 이제 해당 데이터를 무시합니다.
3. 그 결과, 다른 사용자가 같은 날짜로 검색했을 때 `exists`가 `false`를 반환하며 해당 사이트가 **'예약 가능'** 상태로 노출됩니다.

---

### 🚀 다음 확인 사항

이제 이 수식의 원리를 이해하셨으니, 실제 코드로 테스트를 돌려보실 차례입니다.

**혹시 "연박"이 아니라 "당일치기(오전 입실 - 오후 퇴실)" 같은 특수한 상품도 있나요?** 그런 경우에는 날짜 공식이 달라져야 할 수도 있습니다. 현재 요구사항 내에서는 이 `>`와 `<` 조합이 가장 완벽한 정답입니다!

이제 버그 수정이 완료되었다면, **Step 3-4(테스트 클래스 분리)**를 시작해 보시겠어요? 아니면 로직 구현 중에 더 궁금한 점이 있으신가요?
```

```java
@Query(
      "SELECT count(r) > 0 "
          + "FROM Reservation r "
          + "WHERE r.campsite = :campsite "
          + "AND r.status <> 'CANCELLED' "
          + "AND r.endDate > :startDate "
          + "AND r.startDate < :endDate")
  boolean hasOverlappingReservation(
      @Param("campsite") Campsite campsite,
      @Param("startDate") LocalDate startDate,
      @Param("endDate") LocalDate endDate);
```


### 경계값 

```text
2. 테스트 커버리지 확장
    - [ ] 엣지 케이스 도출
    - [ ] 경계값 테스트 추가
    - [ ] 예외 상황 테스트 보강
```

```shell
 네, 훌륭한 생각입니다. 인수 테스트를 강화하여 엣지 케이스, 경계값, 예외 상황을 다루는 것은
  시스템의 안정성과 신뢰도를 크게 향상시킵니다. ReservationAcceptanceTest를 더 강력하게 만들기 위한
  구체적인 가이드라인을 제시해 드리겠습니다.

  아래 가이드는 "어떤 테스트를 추가해야 하는가"와 "왜 필요한가"에 초점을 맞추어 각 기능별로
  제안합니다.

  1. 예약 생성(Reservation Creation) 기능 보강

  현재 테스트는 기본적인 성공/실패 케이스와 동시성 제어에 집중되어 있습니다. 여기에 다음과 같은
  경계값 및 예외 상황 테스트를 추가할 수 있습니다.

  가이드라인: 경계값 테스트

   * 테스트명 제안: "0박 1일(당일 퇴실) 예약은 거부된다"
       * 필요성: 예약 기간의 최소 경계값을 테스트합니다. startDate와 endDate가 동일한 경우,
         시스템이 이를 유효하지 않은 기간으로 올바르게 처리하는지 확인해야 합니다.
       * 구현: 예약요청_생성(오늘, 오늘, ...) 과 같이 시작일과 종료일을 같은 날짜로 설정하여
         요청하고, 예약이_거부되었다를 검증합니다.

   * 테스트명 제안: "최소 예약 기간(1박 2일)은 예약이 성공한다"
       * 필요성: 유효한 최소 경계값(1박)이 정상적으로 처리되는지 확인합니다.
       * 구현: 예약요청_생성(오늘, 오늘+1일, ...)로 요청하고 예약_성공_확인을 검증합니다.

  가이드라인: 엣지 케이스 테스트

   * 테스트명 제안: "기존 예약과 정확히 일치하는 기간에 신규 예약을 시도하면 거부된다"
       * 필요성: 동시성 테스트(@Disabled된 테스트)는 동시에 여러 요청이 올 때를 다루지만, 이미
         확정된 예약 위에 순차적으로 덮어쓰려는 시도를 막는지도 명시적으로 확인해야 합니다.
       * 구현:
           1. GIVEN: 특정 사이트(A-1)에 특정 기간(내일 ~ 모레)으로 예약을 먼저 생성합니다.
           2. WHEN: 동일한 사이트와 기간으로 다시 예약을 요청합니다.
           3. THEN: 예약이_거부되었다를 검증합니다.

  가이드라인: 예외 상황 테스트

   * 테스트명 제안: "존재하지 않는 사이트 ID로 예약하면 거부된다"
       * 필요성: 요청 데이터의 식별자(siteNumber 또는 siteId)가 유효하지 않을 때, 시스템이
         데이터베이스를 조회한 후 NotFound 또는 BadRequest 오류를 안정적으로 반환하는지 확인합니다.
       * 구현: 예약요청_생성(...) 시 siteNumber를 "없는-사이트-99" 와 같이 존재하지 않는 값으로
         설정하여 요청하고, 예상되는 HTTP 상태 코드(e.g., 400 Bad Request 또는 404 Not Found)와
         에러 메시지를 검증합니다.

  2. 사이트 검색(Site Search) 기능 보강

  현재 테스트는 예약이 중간에 껴있는 케이스를 다루지만, 예약 기간의 경계에 걸치는 상황에 대한
  테스트가 더 필요합니다.

  가이드라인: 경계값 테스트

   * 테스트명 제안: "기존 예약의 종료일이 검색 시작일과 같으면 해당 사이트는 검색된다"
       * 필요성: 날짜 기반 검색 로직에서 가장 실수가 잦은 off-by-one 에러를 방지합니다. 예약이
         끝나는 날부터 바로 다음 예약이 가능해야 합니다.
       * 구현:
           1. GIVEN: A-1 사이트에 오늘+2일 ~ 오늘+4일까지 예약을 생성합니다.
           2. WHEN: 오늘+4일부터 오늘+6일까지의 기간으로 사이트를 검색합니다.
           3. THEN: 검색 결과에 A-1 사이트가 포함되어야 합니다.

   * 테스트명 제안: "기존 예약의 시작일이 검색 종료일과 같으면 해당 사이트는 검색된다"
       * 필요성: 위와 동일하게 날짜 경계값 처리를 검증합니다.
       * 구현:
           1. GIVEN: A-1 사이트에 오늘+2일 ~ 오늘+4일까지 예약을 생성합니다.
           2. WHEN: 오늘부터 오늘+2일까지의 기간으로 사이트를 검색합니다.
           3. THEN: 검색 결과에 A-1 사이트가 포함되어야 합니다.

  가이드라인: 엣지 케이스 테스트

   * 테스트명 제안: "취소된 예약 기간은 다시 검색되었을 때 예약 가능한 상태로 노출된다"
       * 필요성: 예약 취소 로직이 재고(가용 사이트)에 즉시 정확하게 반영되는지 검색 기능을 통해
         이중으로 검증합니다.
       * 구현:
           1. GIVEN: 특정 기간으로 A-1 사이트를 예약한 후, 즉시 해당 예약을 취소합니다.
           2. WHEN: 원래 예약했던 것과 동일한 기간으로 사이트를 검색합니다.
           3. THEN: 검색 결과에 A-1 사이트가 포함되어야 합니다.

  3. 예약 취소(Reservation Cancellation) 기능 보강

  현재 테스트는 정상 취소, 잘못된 확인 코드로 인한 실패 등을 다룹니다. 여기에 이미 처리된 요청이나
  잘못된 식별자에 대한 방어 로직을 검증하는 테스트를 추가할 수 있습니다.

  가이드라인: 예외 상황 테스트

   * 테스트명 제안: "존재하지 않는 예약 ID로 취소를 시도하면 실패한다"
       * 필요성: 유효하지 않은 reservationId에 대해 시스템이 404 Not Found와 같은 명확한 응답을
         주는지 확인합니다.
       * 구현: 예약을_취소한다(99999L, "아무코드") 와 같이 존재하지 않을 법한 ID로 취소를 요청하고,
         404 Not Found 응답을 검증합니다.

   * 테스트명 제안: "이미 취소된 예약을 다시 취소하려고 하면 실패한다"
       * 필요성: 시스템의 상태(State)가 올바르게 관리되는지, 즉 멱등성(Idempotency)이 없는
         작업(중복 취소)을 안전하게 거부하는지 확인합니다.
       * 구현:
           1. GIVEN: 예약을 생성하고 성공적으로 취소합니다.
           2. WHEN: 동일한 reservationId와 confirmationCode로 다시 취소를 요청합니다.
           3. THEN: 예약_취소가_거부되었다 또는 409 Conflict와 같은 적절한 실패 응답을 검증합니다.

  실행 계획 제안

  이 가이드라인을 바탕으로 테스트를 추가하여 시스템을 더욱 견고하게 만들 수 있습니다. 어떤 부분부터
  보강 작업을 시작하고 싶으신가요?

  예를 들어, "예약 생성 기능 보강"부터 시작해 0박 1일 예약 거부 테스트를 함께 추가해볼 수 있습니다.
  원하시는 부분을 알려주시면 바로 코드 작성에 들어가겠습니다.

```


### 기존 예약 클래스
- 비대하기 때문에 클래스를 분리해보도록 한다. 


```java
package com.camping.legacy;

import static com.camping.legacy.step.ReservationStep.*;
import static com.camping.legacy.step.SiteStep.*;
import static org.assertj.core.api.Assertions.*;

import com.camping.legacy.domain.Campsite;
import com.camping.legacy.domain.Reservation;
import com.camping.legacy.dto.ReservationRequest;
import com.camping.legacy.repository.CampsiteRepository;
import com.camping.legacy.repository.ReservationRepository;
import com.camping.legacy.utils.ConcurrencyTestHelper;
import com.camping.legacy.utils.DatabaseCleaner;
import io.restassured.RestAssured;
import io.restassured.response.ExtractableResponse;
import io.restassured.response.Response;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.temporal.TemporalAdjusters;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.http.HttpStatus;
import org.springframework.test.context.ActiveProfiles;

@ActiveProfiles("test")
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ReservationAcceptanceTest {

  @LocalServerPort int port;

  @Autowired private DatabaseCleaner databaseCleaner;

  @Autowired private CampsiteRepository campsiteRepository;

  @Autowired private ReservationRepository reservationRepository;

  @BeforeEach
  void setUp() {
    RestAssured.port = port;

    databaseCleaner.execute();

    campsiteRepository.save(new Campsite("A-1", "Large Site", 6));
    campsiteRepository.save(new Campsite("B-1", "Small Site", 4));
  }

  @DisplayName("유효한 정보로 예약 요청 시 예약이 확정된다")
  @Test
  void 유효한_정보로_예약요청시_예약이_확정된다() {
    // given
    var 시작일 = LocalDate.now();
    var 종료일 = 시작일.plusDays(2);
    var 예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");

    // when
    var 응답 = 예약을_요청한다(예약요청);

    // then
    예약_성공_확인(응답);
    예약이_확정된_상태이다(응답, "CONFIRMED");
    예약_확인코드가_발급되었다(응답);
  }

  @DisplayName("최대 예약 가능 기간(30박)을 꽉 채워 예약 요청한다")
  @Test
  void 최대_예약_가능기간을_꽉_채워_예약_요청한다() {
    // given
    var 시작일 = LocalDate.now();
    var 종료일 = 시작일.plusDays(30); // 30박
    var 예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");

    // when
    var 응답 = 예약을_요청한다(예약요청);

    // then
    예약_성공_확인(응답);
  }

  @DisplayName("예약 제한 기간(30박)을 초과하여 요청하면 예약이 거부된다")
  @Test
  void 예약_제한_기간을_초과하여_요청하면_예약이_거부된다() {
    // given
    var 시작일 = LocalDate.now();
    var 종료일 = 시작일.plusDays(31);
    var 예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");

    // when
    var 응답 = 예약을_요청한다(예약요청);

    // then
    예약이_거부되었다(응답);
    에러메시지가_확인된다(응답, "예약 기간은 최대 30일입니다.");
  }

  @DisplayName("유효하지 않은 고객 이름으로 예약할 경우 예약 거부된다")
  @Test
  void 유효하지_않은_고객_이름으로_예약할_경우_예약_거부된다() {
    // given
    var 시작일 = LocalDate.now();
    var 종료일 = 시작일.plusDays(2);
    var 예약요청 = 예약요청_생성(시작일, 종료일, "김", "01012345678");

    // when
    var 응답 = 예약을_요청한다(예약요청);

    // then
    예약이_거부되었다(응답);
    에러메시지가_확인된다(응답, "예약자 이름은 최소 2자 이상이어야 합니다.");
  }

  @DisplayName("유효하지 않은 전화번호로 예약 요청하면 예약 거부된다")
  @Test
  void 유효하지_않은_전화번호로_예약_요청하면_예약_거부된다() {
    // given
    var 시작일 = LocalDate.now();
    var 종료일 = 시작일.plusDays(2);
    var 예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "010-123-456");

    // when
    var 응답 = 예약을_요청한다(예약요청);

    // then
    예약이_거부되었다(응답);
    에러메시지가_확인된다(응답, "전화번호 형식이 올바르지 않습니다.");
  }

  @Disabled
  @DisplayName("동일한 사이트와 기간에 대해 중복 예약 시도를 하면 한명만 예약된다 (동시성 제어)")
  @Test
  void 동일한_사이트와_기간에_대해_중복_예약_시도를_하면_한명만_예약된다() throws InterruptedException {
    // given
    LocalDate 시작일 = LocalDate.now().plusDays(10);
    LocalDate 종료일 = 시작일.plusDays(1);

    var 홍길동_예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");
    var 이순신_예약요청 = 예약요청_생성(시작일, 종료일, "이순신", "01056781234");

    AtomicInteger 예약_성공_카운트 = new AtomicInteger(0);

    // when
    ConcurrencyTestHelper.execute(
        () -> recordResult(예약_성공_카운트, 예약을_요청한다(홍길동_예약요청)),
        () -> recordResult(예약_성공_카운트, 예약을_요청한다(이순신_예약요청)));

    // then
    assertThat(예약_성공_카운트.get()).isEqualTo(1);
  }

  private void recordResult(AtomicInteger count, ExtractableResponse<Response> response) {
    if (response.statusCode() == HttpStatus.CREATED.value()) {
      count.incrementAndGet();
    }
  }

  // TODO. 서비스에 LocalDate.now()가 고정되어 있어서, 특정 날짜 지정 후 기간이 지나면 테스트 실패하게 된다
  // TODO. 응답에 결제 예정 금액 정보가 없다
  @DisplayName("성수기 주말 할증 요금이 자동 계산된다")
  @Test
  void 성수기_주말_할증_요금이_자동_계산된다() {
    // given
    LocalDate 오늘 = LocalDate.now();
    LocalDate 성수기_시작 = LocalDate.of(오늘.getYear(), 7, 1);
    if (오늘.isAfter(성수기_시작)) {
      성수기_시작 = 성수기_시작.plusYears(1); // 올해 성수기가 지났으면 내년으로
    }

    LocalDate 성수기_토요일 = 성수기_시작.with(TemporalAdjusters.nextOrSame(DayOfWeek.SATURDAY));
    LocalDate 성수기_일요일 = 성수기_토요일.plusDays(1);

    var 예약요청 = 예약요청_생성(성수기_토요일, 성수기_일요일, "성수기 주말 고객", "01012345678");

    // when & then
    var 예약_응답 = 예약을_요청한다(예약요청);
    예약_성공_확인(예약_응답);
  }

  // Feature 2. 사이트 가용성
  @DisplayName("예약이 없는 기간으로 검색 시 가능한 예약 가능한 사이트 목록이 반환된다")
  @Test
  void 예약이_없는_기간으로_검색_시_예약_가능한_사이트_목록이_반환된다() {
    // given
    // A-1, B-1 모두 예약 없는 상태
    var 시작일 = LocalDate.now().plusMonths(1);
    var 종료일 = LocalDate.now().plusMonths(1).plusDays(2);
    var 사이즈 = "대형";

    // when
    var 사이트_검색_결과 = 기간_조건으로_사이트를_검색한다(시작일, 종료일);

    // then
    검색_결과에_해당_사이트가_포함된다(사이트_검색_결과, "A-1", "B-1");
    모든_사이트는_이용가능한_상태이다(사이트_검색_결과);
  }

  @DisplayName("사이트 크기 필터링 및 상세 정보 확인이 가능하다")
  @Test
  void 사이트_크기_필터링_및_상세_정보_확인이_가능하다() {
    // given : "A-1(대형)", "B-1(소형)" 사이트가 등록되어 있다
    var 시작일 = LocalDate.now();
    var 종료일 = 시작일.plusDays(2);
    var 사이즈 = "대형";

    // when
    var 검색_결과 = 사이트를_검색한다(시작일, 종료일, 사이즈);

    // then
    검색_결과에_특정_사이트만_포함된다(검색_결과, "A-1");
    검색_결과에는_최대인원과_전기가능여부가_포함되야한다(검색_결과);
  }

  @DisplayName("기간 내 중간 날짜가 예약된 사이트는 검색에서 제외된다 (연박 불가)")
  @Test
  void 기간내_중간_날짜가_예약된_사이트는_검색에서_제외된다() {
    // given : A-1 사이트는 이미 예약된 상태, A-2는 예약이 없는 상태
    campsiteRepository.save(new Campsite("A-2", "Large Site", 5));

    LocalDate 오늘 = LocalDate.now();
    LocalDate 시작일 = 오늘.plusDays(1);
    LocalDate 종료일 = 오늘.plusDays(3);
    var 예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");

    예약을_요청한다(예약요청);

    // when & then
    var 검색_결과 = 사이트를_검색한다(오늘, 종료일, "대형");

    검색_결과에_특정_사이트는_포함되지_않는다(검색_결과, "A-1");
    검색_결과에_해당_사이트가_포함된다(검색_결과, "A-2");
  }

  @DisplayName("과거 날짜 포함하여 검색할 경우 요청이 거부된다")
  @Test
  void 과거_날짜_포함하여_검색할_경우_요청이_거부된다() {
    // given
    var 어제 = LocalDate.now().minusDays(1);
    var 내일 = LocalDate.now().plusDays(1);

    // when
    var 사이트_검색_결과 = 기간_조건으로_사이트를_검색한다(어제, 내일);

    // then
    검색_요청이_거부되었다(사이트_검색_결과);
  }

  // Feature3. 예약 취소
  @DisplayName("올바른 예약 확인 코드로 취소 시 재고가 즉시 복구된다")
  @Test
  void 올바른_예약_확인코드로_취소시_재고가_즉시_복구된다() {
    // given: 예약 생성
    var 사이트 = campsiteRepository.save(new Campsite("A-2", "대형", 5));
    var 시작일 = LocalDate.now().plusMonths(1);
    var 확인코드 = "SAFE12";

    var 저장된_예약 = reservationRepository.save(예약_데이터_준비(사이트, 시작일, 확인코드));

    long reservationId = 저장된_예약.getId();
    String confirmationCode = 저장된_예약.getConfirmationCode();

    // when
    var 취소_응답 = 예약을_취소한다(reservationId, confirmationCode);
    예약_취소가_성공했다(취소_응답);

    var 조회_응답 = 예약을_조회한다(reservationId);
    예약_상태_확인(조회_응답, "CANCELLED");

    // then
    var 검색_결과 = 사이트를_검색한다(저장된_예약.getStartDate(), 저장된_예약.getEndDate(), "대형");
    검색_결과에_해당_사이트가_포함된다(검색_결과, "A-2");
  }

  @DisplayName("예약 확인 코드가 일치하지 않으면 취소할 수 없다")
  @Test
  void 예약_확인_코드가_일치하지_않으면_취소할_수_없다() {
    // given
    var 시작일 = LocalDate.now();
    var 종료일 = 시작일.plusDays(2);
    var 예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");

    var 예약_응답 = 예약을_요청한다(예약요청);

    long reservationId = 예약_응답.jsonPath().getLong("id");
    String confirmationCode = "WRONG_CODE";

    // when
    var 취소_응답 = 예약을_취소한다(reservationId, confirmationCode);

    // then
    예약_취소가_거부되었다(취소_응답);

    var 조회_응답 = 예약을_조회한다(reservationId);
    예약_상태_확인(조회_응답, "CONFIRMED");
  }

  @DisplayName("당일 예약 취소 시 별도의 상태 코드로 관리된다")
  @Test
  void 당일_예약_취소_시_별도의_상태_코드로_관리된다() {
    // given
    var 시작일 = LocalDate.now();
    var 종료일 = 시작일.plusDays(2);
    var 예약요청 = 예약요청_생성(시작일, 종료일, "홍길동", "01012345678");

    var 예약_응답 = 예약을_요청한다(예약요청);

    long reservationId = 예약_응답.jsonPath().getLong("id");
    String confirmationCode = 예약_응답.jsonPath().get("confirmationCode");

    // when
    var 취소_응답 = 예약을_취소한다(reservationId, confirmationCode);
    예약_취소가_성공했다(취소_응답);

    // then
    var 조회_응답 = 예약을_조회한다(reservationId);
    예약_상태_확인(조회_응답, "CANCELLED_SAME_DAY");
  }

  private static ReservationRequest 예약요청_생성(
      LocalDate startDate, LocalDate endDate, String name, String phoneNumber) {
    return new ReservationRequest(
        name, startDate, endDate, "A-1", phoneNumber, 4, "12가3456", "잘 부탁드립니다.");
  }

  private static Reservation 예약_데이터_준비(Campsite site, LocalDate start, String code) {
    Reservation reservation = new Reservation();
    reservation.setCampsite(site);
    reservation.setStartDate(start);
    reservation.setEndDate(start.plusDays(2));
    reservation.setConfirmationCode(code);
    reservation.setStatus("CONFIRMED");
    reservation.setCustomerName("익명의 고객");
    return reservation;
  }

  public static void 예약_성공_확인(ExtractableResponse<Response> response) {
    assertThat(response.statusCode()).isEqualTo(HttpStatus.CREATED.value());
  }

  public static void 예약이_거부되었다(ExtractableResponse<Response> response) {
    assertThat(response.statusCode()).isEqualTo(HttpStatus.CONFLICT.value());
  }

  public static void 예약이_확정된_상태이다(ExtractableResponse<Response> response, String expected) {
    assertThat(response.jsonPath().getString("status")).isEqualTo(expected);
  }

  private void 에러메시지가_확인된다(ExtractableResponse<Response> response, String expected) {
    assertThat(response.jsonPath().getString("message")).isEqualTo(expected);
  }

  public static void 예약_확인코드가_발급되었다(ExtractableResponse<Response> response) {
    String code = response.jsonPath().getString("confirmationCode");
    assertThat(code).isNotNull();
    assertThat(code).hasSize(6);
    assertThat(code).matches("^[A-Z0-9]*$");
  }

  public static void 검색_결과에_해당_사이트가_포함된다(
      ExtractableResponse<Response> response, String... siteNumbers) {
    List<String> resultNumbers = response.jsonPath().getList("siteNumber");
    assertThat(resultNumbers).contains(siteNumbers);
  }

  public static void 모든_사이트는_이용가능한_상태이다(ExtractableResponse<Response> response) {
    List<Boolean> availability = response.jsonPath().getList("available");
    assertThat(availability).allMatch(available -> available);
  }

  public static void 검색_결과에_특정_사이트는_포함되지_않는다(
      ExtractableResponse<Response> response, String siteNumber) {
    List<String> siteNumbers = response.jsonPath().getList("siteNumber");
    assertThat(siteNumbers).doesNotContain(siteNumber);
  }

  public static void 검색_결과에_특정_사이트만_포함된다(
      ExtractableResponse<Response> response, String siteNumber) {
    List<String> siteNumbers = response.jsonPath().getList("siteNumber");
    assertThat(siteNumbers).hasSize(1);
    assertThat(siteNumbers).containsExactly(siteNumber);
  }

  public static void 검색_요청이_거부되었다(ExtractableResponse<Response> response) {
    assertThat(response.statusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.value());
  }

  public static void 검색_결과에는_최대인원과_전기가능여부가_포함되야한다(ExtractableResponse<Response> response) {
    List<Integer> maxPeopleList = response.jsonPath().getList("maxPeople");
    List<Boolean> electricityList = response.jsonPath().getList("hasElectricity");

    assertThat(maxPeopleList).allMatch(people -> people > 0);
    assertThat(electricityList).allMatch(Objects::nonNull);
  }

  public static void 예약_취소가_성공했다(ExtractableResponse<Response> response) {
    assertThat(response.statusCode()).isEqualTo(HttpStatus.OK.value());
  }

  public static void 예약_취소가_거부되었다(ExtractableResponse<Response> response) {
    assertThat(response.statusCode()).isEqualTo(HttpStatus.BAD_REQUEST.value());
    assertThat(response.jsonPath().getString("message")).isNotNull();
  }

  public static void 예약_상태_확인(ExtractableResponse<Response> response, String expectedStatus) {
    String status = response.jsonPath().getString("[0].status");
    assertThat(status).isEqualTo(expectedStatus);
  }
}

```


신규_사이트를_등록한다
ReservationFixture 생성 
날짜 오프셋 형식 적용 
- `예약을_요청한다()`에 적용
예약을 생성한다 <- 에서 예약 요청 생성 책임을 가지도록 위임, 파라미터 변경

> 사용자가 어떤 경험을 하는가에 초점을 두고 시나리오 테스트를 작성


```java
@DisplayName("예약 확인 코드가 일치하지 않으면 취소할 수 없다")
@Test
void 예약_확인_코드가_일치하지_않으면_취소할_수_없다() {
// given
var 예약_응답 = 예약을_요청한다(0, 2, CUSTOMER_NAME, PHONE_NUMBER);

long reservationId = 예약_응답.jsonPath().getLong("id");
String confirmationCode = WRONG_CONFIRMATION_CODE;

// when
var 취소_응답 = 예약을_취소한다(reservationId, confirmationCode);

// then
예약_취소가_거부되었다(취소_응답);

var 조회_응답 = 예약을_조회한다(reservationId);
예약_상태_확인(조회_응답, CONFIRMED_STATUS);
}
```
- 예약 응답에서 값을 꺼내 취소 요청을 하는것이 효율적일거 같지만.. 사용자 입장/시나리오를 고려한다면 예약을 조회한 후에 예약을 취소하는게 맞지 않나 싶다

```text
저의 말은 "예약을_요청한다"에서 받은 응답 객체에서 값을 꺼내는게 아니라 "예약을 취소한다" 전에 "예약을 조회한다"를 먼저 수행한 후에 "예약을 취소한다" 단계로 넘어가는게 자연스러운게 아닌가 싶어서요. 기존 방식은 개발자 입장에서 효율면에서 당연하지만, 사용자 입장/시나리오에서는 뭔가 부자연 스러운거 같아서요
```

와, 그 부분은 정말 **중요하고 본질적인 통찰**입니다. 6년 차 개발자들도 '효율성'이라는 함정에 빠져서 놓치기 쉬운 지점을 정확히 짚어내셨어요.

사용자 입장에서 생각해보면, **"예약 완료 페이지에서 받은 ID를 들고 바로 취소 페이지로 가는 것"**보다 **"내가 예약한 내역을 다시 한 번 확인(조회)하고, 거기서 취소 버튼을 누르는 것"**이 실제 사용자 시나리오(User Journey)에 훨씬 가깝습니다.

이 관점을 테스트 코드에 녹여내면 다음과 같은 **두 가지 큰 이점**이 생깁니다.

**1. 사용자 시나리오의 완결성 (Real-world Flow)**
사용자는 보통 `예약 상세 조회` 화면에서 취소 기능을 마주합니다. 따라서 테스트에서도 `조회` 단계를 거치는 것이 실제 서비스 흐름과 일치합니다.
- **기존 방식**: 예약(A) -> 취소(B)
- **제안하신 방식**: 예약(A) -> **내 예약 확인(A')** -> 취소(B)
    
**2. 기술적인 '검증의 신뢰도' 상승**
`조회`를 먼저 수행하면, **"내가 방금 한 예약이 시스템에 정확히 기록되었는가"**를 먼저 확인한 뒤에 다음 동작(취소)으로 넘어가게 됩니다. 만약 예약 자체가 잘못되었다면 `조회` 단계에서 먼저 테스트가 깨질 것이므로, 에러의 원인을 더 명확히 파악할 수 있습니다.


```java
 @DisplayName("예약 확인 코드가 일치하지 않으면 취소할 수 없다")
  @Test
  void 예약_확인_코드가_일치하지_않으면_취소할_수_없다() {
    // given
    var 예약_응답 = 예약을_요청한다(0, 2, CUSTOMER_NAME, PHONE_NUMBER);
    long 예약ID = 예약_응답.jsonPath().getLong("id");

    var 예약확인_조회_응답 = 예약을_조회한다(예약ID);
    예약_상태_확인(예약확인_조회_응답, CONFIRMED_STATUS);

    // when
    var 취소_응답 = 예약을_취소한다(예약ID, WRONG_CONFIRMATION_CODE);

    // then
    예약_취소가_거부되었다(취소_응답);

    var 조회_응답 = 예약을_조회한다(예약ID);
    예약_상태_확인(조회_응답, CONFIRMED_STATUS);
  }
```
- 좀더 사용자 중심적으로 만들어봄 
	- 예약 생성한 후 바로 취소하는게 아니라
		- 개발 효율성 면에서 이게 맞지만.. 사용자 면에서는 이상하다 
	- 예약 되었는지 재 확인하고 취소 요청