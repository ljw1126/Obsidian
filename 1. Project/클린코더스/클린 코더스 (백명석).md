
- [유튜브](https://www.youtube.com/watch?v=60lLSe1phks&list=PLeQ0NTYUDTmMM71Jn1scbEYdLFHz5ZqFA&index=2)
- [발표자료](https://github.com/msbaek/clean-coders-2013)

## 섹션1. 클린 코더스

### 2. 소개 및 OOP
절차지향 vs 객체지향
캡슐화 
다형성

>[!note] 창피함을 이기고 모르는 것을 질문 했을 때 성장을 할 기회가 있다

### 3. OOP part 2

절자 지향의 한계 
- 요구사항의 변경이 데이터 구조 변경 유발 
- 데이터를 사용하는 모든 코드의 수정 유발(Client, Test)

✨ 캡슐화를 하는 경우
- 절차 지향에 비해 상대적으로 변경의 영향이 적다
- 구현 변경의 유연함이 있어, 클라이언트 코드에 영향 안 미침

> [!note] Tell, Don't Ask
> - 데이터를 요청해서 변경하고, 저장하라고 하지마라
> - 무슨 기능을 실행하라
> - 데이터를 잘 알고 있는 객체에게 기능을 수행하라고 하라
> - Encapsulation이 유지되어 변경에 영향을 안 받게 됨  


Composition(합성) / Delegation(위임)
- 전략 패턴과도 연관 
	- 합성과 위임은 다르지 않나
	- Composition 패턴이 있고, 위임은 런타임에 동적으로 구현체를 바꿔가는 .. 다형성을 활용한 기법이고 

다형성 + Composition 통해
- 유연성 증대(변경 용이)
- 테스트 용이
- TDD 용이
- 인터페이스의 중요성 체감

> 예제 코드가 심플하다. 3개 인데 캡슐화와 다형성을 활용한 전략 패턴(위임)에 대해 가볍게 하고 넘어감


### 4. Function ✨ 
> 함수는 한 가지 일만 해야 한다 


// 리팩터링 도서에서 함수 조차 SRP가 적용되었던게 기억남

**The First Rule of Functions** 
- 함수는 더 이상 작아질 수 없을 만큼 작아야 한다
- 큰 함수를 보면 클래스로 추출할 생각을 해야함
- 클래스는 일련의 ㅂ녀수들에 동작하는 기능의 집합

> 마틴 파울러 Extract Method Object 


> [!todo] 예제 꼭 리팩터링 해보기
> [예제 저장소](https://github.com/msbaek/fitness-example) 


>[!note] org.fitness 라이브러리가 다운로드 되지 않아서 직접 찾아 넣어줘야 한다
>https://repo1.maven.org/maven2/org/fitnesse/fitnesse/20081201/

```java
public class FitnessExample {  
    public String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {  
        WikiPage wikiPage = pageData.getWikiPage();  
        StringBuffer buffer = new StringBuffer();  
  
        if (pageData.hasAttribute("Test")) {  
            if (includeSuiteSetup) {  
                WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);  
                if (suiteSetup != null) {  
                    WikiPagePath pagePath = wikiPage.getPageCrawler().getFullPath(suiteSetup);  
                    String pagePathName = PathParser.render(pagePath);  
                    buffer.append("!include -setup .").append(pagePathName).append("\n");  
                }            }            WikiPage setup = PageCrawlerImpl.getInheritedPage("SetUp", wikiPage);  
            if (setup != null) {  
                WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);  
                String setupPathName = PathParser.render(setupPath);  
                buffer.append("!include -setup .").append(setupPathName).append("\n");  
            }        }  
        buffer.append(pageData.getContent());  
        if (pageData.hasAttribute("Test")) {  
            WikiPage teardown = PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);  
            if (teardown != null) {  
                WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);  
                String tearDownPathName = PathParser.render(tearDownPath);  
                buffer.append("!include -teardown .").append(tearDownPathName).append("\n");  
            }            if (includeSuiteSetup) {  
                WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage);  
                if (suiteTeardown != null) {  
                    WikiPagePath pagePath = wikiPage.getPageCrawler().getFullPath(suiteTeardown);  
                    String pagePathName = PathParser.render(pagePath);  
                    buffer.append("!include -teardown .").append(pagePathName).append("\n");  
                }            }        }  
        pageData.setContent(buffer.toString());  
        return pageData.getHtml();  
    }          
}
```


마이클 팔저스 - 워킹 이펙리블리 레거시 코드 
- 캐릭터 라이즌 테스트 기법 (?) : 무조건 실행해서 말도 안되는 값으로 테스트 비교

1.필드 추출
`class field variable`로 옮겨서 생성자 초기화하게 되면 
- 함수가 추출될때 달고 다닐 필요가 없어짐
	- 함수는 작은 개수의 파라미터를 가져야 한다 (**조건 충족**)
	- 추출하려는 코드 블락이 두 개이상의 변수에 변경을 가하면 함수 추출 리팩터링을 못함 (이때 유용)

2.변수추출 
- 서로 다른 문자열이나 변수 값만 사용하는 경우 
	- 변수 추출 후 메서드 추출

3.라인 이동 리팩터링하여 변수를 올림
- 똑같은 로직 부분을 메소드 추출

> 서로 다른 부분은 변수로 추출 

4.변수 인라인하기
- 메서드에 인자에 넣고, 변수 지우기

> 강의자료에 리팩터링 결과 있음 🙌


리팩터링 효과 
- 가독성 향상 
- 이해하기 쉬워지고 함수가 자신의 의도를 잘 전달

개선의 원인
- 1. 함수가 작아짐(Small)
	- 함수의 첫번째 규칙
		- `함수는 작아질 수 있는 한 최대한 작아야 한다`
- 2. 블록이 적어야 함
	- if, else, while 문장 등의 내부 블록은 한줄이어야 함
	- 괄호가 try/catch 말고는 없어야 함 (최대한)
- 3. Indenting이 적어야 한다
	- 함수는 중첩 구조를 갖을 만큼 크면 안된다
	- 들여쓰기는 한 두 단계 정도만 
		- 객체 지향 생활 체조 원칙이 생각나네 
			- **토비님 글 찾아보자** 

리팩터링 전의 경우 하나의 함수에서 여러 일을 함 
- creating buffers 
- fetching pages
- searching for in herited pages
- rendering paths 
- appending arcane strings
- including setups and teardowns into test pages

리팩터링 후 
- 페이지가 테스트 페이지 인가?
	- 맞다면 setups, teardowns를 include 한 후
	- HTML 페이지로 전달

> 결과물이 3가지 일을 하고 있는거 아닌가?
- **메서드 이름 추상화** 
	- 추상화를 한 단계 높임 
- 함수의 각 스텝들은 함수 이름보다 한수준 낮은 추상화 수준을 갖는다 
- 이 예제는 완전한 예제가 아니라 여기서 종료 
	- 실제 예제를 찾아보면 잘 되어 있다하는데 .. (`찾아보자`)

> [!tip] 함수의 각 스텝들이 함수 이름이 갖는 추상화 수준보다 한 단계 낮은 것으로만 이뤄졌다면 함수는 한가지 일만 하는 것


>[!note] 추상화 수준이 변하지 않는 수준까지 메소드 추출하면 자연스럽게 추상화 수준이 같은 메소드가 만들어진다 


예. 아래와 같이 함수를 메소드 추출하여 추상화해본다
- To include the setups and tear downs 
	- include setups
		- To include the setups 
			- include the suite setup if this is a suite
				- to include the suite setup
					- search the parent hiearchy for the "SuiteSetUp" page
					- add and include with the path of that page
			- then include the regular setup 
	- then include the test page content
	- then include the teardowns

뎁스별로 같은 추상화

<u>큰 함수는 실제로는 클래스가 숨어 있는 곳</u>
- 변수와 인자로 구성 (=필드)
	- 이를 가지고 통신하는 기능 블락을 가짐 (=메서드)
- 들여쓰기에 존재하고, 변수들을 사용해서 통신하는 기능들의 집합
- 항상 하나 이상의 클래스로 분리할 수 있다

---
### 5. Function part2
- [Prime Number 리팩터링 예제](https://github.com/msbaek/print-prime)
	- master 브랜치는 리팩터링 결과 브랜치
	- 직접 해보는 브랜치는 따로 있음

> [!tip] 아는 것과 필요할 때 사용할 줄 아는 것은 다르다. 연습을 많이 해야 필요할 때 자연스럽게 나올 수 있다.


**PrintPrimeTest**
- (특이하네)파일로 쓰고 읽어와서 비교하는 형태


- 변수 색깔만 보고 한 군데에서만 사용하는 경우 로컬 변수나 메서드 파라미터로 받는게 나을 수 있다 
	- 메서드 내용이 NumberPrint라는 클래스로 바껴짐 ✨
- 인라인, 클래스 리네이밍

> 리팩터링 후 전체 라인수는 증가하지만 복잡도는 줄어듦 ➡️ 조건문이 깊어질수록 복잡도 증가


PrintPrime이 처음에는 one big function 구조 였다
- 리팩터링 후 Three little classes로 분리됨으로써 복잡도가 낮아짐

**큰 함수를 작은 함수들로 쪼갤때 흥미로운 일을 수행** 👀
- 함수를 서로 다른 추상화 레벨로 분리 
	- 함수가 하나 이상의 추상화 레벨을 다루면 이 함수는 한 가지 이상의 일을 하는 것
		- `fitness` 예제 에서
		- StringBuffer, parse, pageCrawler은 low level detail of implementation
		- 반면 testablePage, inheritedPage 등은 비즈니스 개념으로 high level of abstraction 
		- 하나의 함수가 2가지 개념들을 모두 다루는 것을 원치 않는다
		- 서로 다른 추상화 레벨을 서로 다른 함수로 분리
		- 함수가 한 가지 일만 하기 위해서는 추상화 레벨의 경계를 넘지 말아야 한다 
> 함수 레벨에서 추상화 단계를 분리한다는게 아직까지 와닿지 않음 (6/2)

하지만 추상화 레벨은 불분명(fuzzy)하다

>[!tip] Extract Till you Drop
>- 함수가 한가지 일만 하는지 어떻게 확실할 수 있는가?
>- 더 이상 extract할 수 없을 때까지 extract 하라
>- extract할 코드를 가진 함수는 한가지 이상의 일을 하는 것이다
>- 4줄 이내의 함수들로만 구성된 클래스 (분리 가능)
>- if, while 문 등에서 {} 블록이 보이면 extract 대상
>- {} 블록은 extract할 기회이다 !


**10. conclusion**
- 1st rule : `function should be small`
- 2nd rule  : `smaller than that`
- 이름을 잘 지으면 모두의 시간을 절약 가능
	- 네비게이션/이정표 역할을 하기 때문
- 함수를 작게 만들면 모두의 시간을 절약 가능 (경우에 따라 절차적인게 가독성이 나을 수 있다)
- 클래스는 큰 함수를 감춘다 (👀 **신호인듯**)
	- 함수를 여러 클래스들에 잘 배분하려면 함수를 작게 만들어야 한다
- 함수는 한가지 일만 해야하고, 한가지만 하는지 확신할 수 있는 유일한 방법은 `extract till you drop` 이다. 


> 맥북에서 control + t 누르면 가능한 리팩터링 표출해준다 ✨

---
### 6. Function Structure
- [강의 자료 이미지](https://github.com/msbaek/clean-coders-2013/blob/master/3.Function%20Structure.png)


아래의 내용을 살펴본다
1. Arguments
2. The Stepdown Rule
3. switches and cases
4. Temporal Coupling
5. CQS
6. Tell Don't Ask
7. Law of Demeter
8. early returns
9. error handling
10. Special Cases
11. Null is not an error
12. Null is a value
13. try도 하나의 역할/기능이다

**1. Arguments**
파라미터가 많으면 가독성도 떨어지고, 실수하기 좋다 
- 개선 방법1. Java Bean Pattern
	- getter/setter 사용
		- 이 경우 setter를 누락하면 불완전한 빈을 생성 가능 
- 개선 방법2. 빌더 패턴 사용 

Boolean 인자 사용 금지 
- 2가지 이상의 일을 하는 것을 의미하기 때문에 읽어야 함 
	- 2개의 함수로 분리 고려하기

Innies not ou??
- output 인자를 사용하지 말라 
- Argument는 함수로 전달되는 것이지 함수로부터 변경되어 나오는 것이라고 생각하지 않음

> 파라미터로 받은 인자를 함수 내부에서 변경한 후 다시 반환하는 것은 좋지 않다 💩 


the null defense
- null을 전달/기대하는 함수는 있으면 안 된다.💩
	- boolean을 전달하는 만큼 잘못된 것이다 (null인 경우와 아닌 경우 행위를 구분해야 한다💩)
	- 이 경우 2개의 함수를 만드는 것이 맞다
- null을 pseudo boolean으로 쓰지 마라
- defensive 프로그래밍을 지양하라 ⚠️
	- null, 에러 체크로 코드를 더럽히지 말라 
	- 잘못되었다는 단서다 (smell💩)
	- 이는 곧 팀원이나 단위 테스트를 못 믿는다는 말 
	- null 여부를 지속적으로 조사할 것이 아니라 **단위 테스트에서 검증**해야 한다
		- 단위 테스트에는 **회귀 테스트의 목적**도 있다
- 단, public api의 경우 defensive하게 프로그래밍 해야 한다🙌


**2.The Stepdown Rule**

> 모든 public은 위에, 모든 private는 아래에
> public 메서드만 보고도 클라이언트가 이해 가능하다록
- public part만 사용자에게 전달하면 된다
- 중요한 부분(public)은 위로 상세한 부분(private)은 밑으로 
- 이점
	- 편집자들은 마지막 부분은 필수적인 내용 전달 오류 없이 제거할 수 있다
	- 독자들은 제일 위에서부터 읽기 시작해서 지루해지면 그만 읽으면 된다
- backward reference 없이 top 에서 botton 으로 읽을 수 있게

> 메서드의 순서를 맞춰주는 IDE 기능이 있다?? public private 메서드


**3. switches and cases (중요✨)**
- 왜 스위치 문장을 꺼리는가?
	- 스위치는 객체지향스럽지 않다는 만족스러운 대답이 아니다
- 객체지향의 가장 큰 이점 중 하나는 의존성 관리 능력
	- DIP, 다형성 인터페이스를 구현체와 클라이언트 사이에 둠으로써
		- 런타임 의존성은 그대로 둔 채 소스 코드의 의존성을 역전시킴
			- 소크 코드의 의존성이 a > b 였는데 a > interface가 됨
	- 인터페이스가 중요
		- TDD에서도 인터페이스만 있으면 구현체 고려할 필요 없음
- 스프링은 DIP 구조를 가질 수 있도록 지원해주기 때문에 좋다
	- 인터페이스를 의존하기 때문에 단위테스트 작성하기도 쉽다
- 스위치 문장은 독립적 배포에 방해가 됨
	- 각 case 문장은 외부 모듈에 의존성을 갖는다
	- 다수의 다른 모듈에 의존성을 갖을 수 있다
		- 이것은 `fan-out problem` 이라고 한다
	- 구현체에 직접 의존하기 때문에 변경에 취약하다
	- switch 문장에서 소스 코드 의존성은 flow of control과 방향이 같다 
		- 모든 외부 모듈에 영향을 받는다 
		- 외부 모듈 중 하나라도 변경이 일어나면 switch 문장이 영향 받음
		- 독립적 배포를 불가능하게 하는 많은 의존성을 만듦

🙌 스위치 문장 제거 절차 
- 스위치 문장을 다형성 인터페이스 호출로 변환 
- case에 있는 문장들을 별도의 클래스로 추출하여 변경 영향이 발생하지 않도록 한다
- https://github.com/msbaek/videostore?tab=readme-ov-file

✨ 실습 remove-switch-statement 브랜치
- https://github.com/msbaek/videostore/tree/remove-switch-stmt?tab=readme-ov-file

후기.
- 우선 테스트 코드에서 상수 타입 명칭에 따라 Movie 하위 클래스 생성 (상속)
- 타입 코드를 생성자에서 직접 주입 하도록 리팩터링
- Movie 클래스 하위에 위치한 계산 메서드 2개를 서브 클래스에서 각자 구현하도록 리팩터링
	- 추상 메서드 선언
- **상속을 활용해 switch문에 다형성 적용하는 심플한 예제**


---

### 7. Function Structure (Part. 2)

**4. Temporal Coupling**
- open, close를 순차적으로 호출해야 하는 비즈니스 로직의 경우
	- 사용자가 실수(누락) 가능하므로 아래 템플릿에서 변경 가능한 부분을 인터페이스로 빼고, 나머지 로직은 내부에 캡슐화
	- 🤔 템플릿 콜백 패턴 같네

```java
class FileCommandTemplate {
	public void process(File file, FileCommand command) {
		file.open();
		command.process(file);
		file.close();
	}
}
```

**5. CQS**
- side effect를 관리하는 좋은 방법
- 시스템의 상태 변경 가능
- command
	- side effect를 갖는다
	- 아무것도 반환하지 않는다
- query
	- side effect가 없다
	- 계산값이나 시스템의 상태를 변환
- CQS 정의 
	- 상태를 변경하는 함수는 값을 반환하면 안된다
	- 값을 반환하는 함수는 상태를 변경하면 안된다
- `당신 코드의 독자들을 혼란스럽게 하지 말라`
	- 값을 반환하는 함수는 상태를 변경하면 안된다
		- 상태를 변경하는 함수는 exception을 발생시킬 수 있지만, 값을 반환할 수는 없다
		- 이것은 약속이다
```java
// 💩 로그인을 하면 user 정보를 읽어야 함
User u = authorizer.login(userName, password);

// ✨
authorizer.login(userName, password);
User u = authorizer.getUser(userName);
```

**6. Tell Don't Ask**
- extreme한 CQS는 C와 Q를 함께 사용하지 말도록 한다.

유저가 로그인한 건지 if 조건문 검증보다 아래와 같이 예외 처리가 경우에 따라 나을 수 있단다
```java
try {
	user.execute(command);
} catch(NotLoggedIn e) {
	anthenticator.promptLogin();
}
```

나아가 아래와 같이 user 객체가 모든 것을 처리하도록 하는 것이 더 나을 수 있다 
```java
user.execute(command, authenticator);
```
- 로그인 여부 상태는 user 객체에 속함
- 왜 user 상태를 가져다가, user 대신해서 결정 하는가 
- user가 해당 범위를 수행하는 것이 맞다

**Tell Don't Ask**
- tell other object what to do
- but not to ask object what the stat is (상태를 묻지 마라)

> [!note] CQS를 강화하는 수단이 Tell Don't Ask 규칙이다


**7. Law of Demeter (디미터 원칙)**
- 메서드 체이닝이 너무 깊어지면
	- 하나의 함수가 전체 시스템 객체들 간의 네비게이션을 아는 것은 잘못된 설계이다
- 함수가 시스템의 전체를 알게 하면 안된다 
- 개별 함수는 제한된 지식만 가져야 한다
- 객체는 요청된 기능 수행을 위해 이웃 객체에게 요청해야 한다
- 요청을 수신하면 적절한 객체가 수신할 때까지 전파되어야 한다
- `law of demeter`는 아래와 같은 일련의 규칙을 통해 Tell Don't Ask를 형식화한다.
	- 인자로 전달된 객체
	- localy 생성한 객체
	- 필드로 선언된 객체
	- 전역 객체

**8. early returns**
- early return 이나 guarded return은 허용됨
- 루프의 중간에서 리턴하는 것은 문제이다 💣
	- break, 루프 중간에서의 return은 loop를 복잡하게 함
	- 코드가 동작하도록 하는 것보다 이해할 수 있게 하는 것이 더 중요✨

```java
private boolean isValidName() {
	if(name.equals("")) return true;
	if(..) return true;

	return false;
}
```


**9. error handling**
- [예제 저장소 - stack-example](https://github.com/msbaek/stack-example)
- 스택을 직접 구현할 때
	- 에러 처리를 위해 pop()은 null 반환하고, push()는 false를 반환할 수 있다
	- 이보다는 exception을 발생시키는 것이 좋다
		- 실패시 값에 대해 알아야 하네.. 내부 구현을 알아야 한다는 의미인듯🤔
	- 이때 exception의 이름은 최대한 구체적이여야 한다. 

```java
public static Stack make(int capacity) {
	if(capacity < 0) 
		throw new IllegalCapacity();
	if(capacity == 0)
		return new ZeroCapacityStack(); // NOP, 널오브젝트 패턴

	return new BoundedStack(capacity);
}

public static class IllegalCapacity extends RuntimeException { 
}
```

**checked vs unchecked 예외**
- checked 예외가 발생하면 catch나 throw 해야 한다 
	- 특정 기술의 예외에 대한 의존이 발생
	- checked exception을 아예 사용하지 말라 
		- 단, 👀 재시도 로직의 경우 checked exception이 필요하다고 생각
		- 그리고 public api의 경우에도 checked exception이 필요
- 예외 메시지는 어떤걸 담아야 하나?
	- 메시지가 필요없는게 가장 좋다 👍
	- 예외 클래스 이름을 정확하게 지어 이름으로 의미가 전달되도록 하라
		- 가장 좋은 커맨트는 커맨트를 작성하지 않는 것이다
		- 코드(이름)가 커맨트를 대신하도록 해라

**10. Special Cases**
- `stack-example` 예제에서
	- capacity가 0인 경우 어떻게 처리할 것인가?
	- 


**11. Null is not an error**

**12. Null is a value**

**13. try도 하나의 역할/기능이다**

