
- [유튜브](https://www.youtube.com/watch?v=60lLSe1phks&list=PLeQ0NTYUDTmMM71Jn1scbEYdLFHz5ZqFA&index=2)
- [발표자료](https://github.com/msbaek/clean-coders-2013)

## 섹션1. 클린 코더스

### 2. 소개 및 OOP
절차지향 vs 객체지향
캡슐화 
다형성

>[!note] 창피함을 이기고 모르는 것을 질문 했을 때 성장을 할 기회가 있다

### 3. OOP part 2

절자 지향의 한계 
- 요구사항의 변경이 데이터 구조 변경 유발 
- 데이터를 사용하는 모든 코드의 수정 유발(Client, Test)

✨ 캡슐화를 하는 경우
- 절차 지향에 비해 상대적으로 변경의 영향이 적다
- 구현 변경의 유연함이 있어, 클라이언트 코드에 영향 안 미침

> [!note] Tell, Don't Ask
> - 데이터를 요청해서 변경하고, 저장하라고 하지마라
> - 무슨 기능을 실행하라
> - 데이터를 잘 알고 있는 객체에게 기능을 수행하라고 하라
> - Encapsulation이 유지되어 변경에 영향을 안 받게 됨  


Composition(합성) / Delegation(위임)
- 전략 패턴과도 연관 
	- 합성과 위임은 다르지 않나
	- Composition 패턴이 있고, 위임은 런타임에 동적으로 구현체를 바꿔가는 .. 다형성을 활용한 기법이고 

다형성 + Composition 통해
- 유연성 증대(변경 용이)
- 테스트 용이
- TDD 용이
- 인터페이스의 중요성 체감

> 예제 코드가 심플하다. 3개 인데 캡슐화와 다형성을 활용한 전략 패턴(위임)에 대해 가볍게 하고 넘어감


### 4. Function ✨ 
> 함수는 한 가지 일만 해야 한다 


// 리팩터링 도서에서 함수 조차 SRP가 적용되었던게 기억남

**The First Rule of Functions** 
- 함수는 더 이상 작아질 수 없을 만큼 작아야 한다
- 큰 함수를 보면 클래스로 추출할 생각을 해야함
- 클래스는 일련의 ㅂ녀수들에 동작하는 기능의 집합

> 마틴 파울러 Extract Method Object 


> [!todo] 예제 꼭 리팩터링 해보기
> [예제 저장소](https://github.com/msbaek/fitness-example) 



마이클 팔저스 - 워킹 이펙리블리 레거시 코드 
- 캐릭터 라이즌 테스트 기법 (?) : 무조건 실행해서 말도 안되는 값으로 테스트 비교

1.필드 추출
`class field variable`로 옮겨서 생성자 초기화하게 되면 
- 함수가 추출될때 달고 다닐 필요가 없어짐
	- 함수는 작은 개수의 파라미터를 가져야 한다 (**조건 충족**)
	- 추출하려는 코드 블락이 두 개이상의 변수에 변경을 가하면 함수 추출 리팩터링을 못함 (이때 유용)

2.변수추출 
- 서로 다른 문자열이나 변수 값만 사용하는 경우 
	- 변수 추출 후 메서드 추출

3.라인 이동 리팩터링하여 변수를 올림
- 똑같은 로직 부분을 메소드 추출

> 서로 다른 부분은 변수로 추출 

4.변수 인라인하기
- 메서드에 인자에 넣고, 변수 지우기

> 강의자료에 리팩터링 결과 있음 🙌


리팩터링 효과 
- 가독성 향상 
- 이해하기 쉬워지고 함수가 자신의 의도를 잘 전달

개선의 원인
- 1. 함수가 작아짐(Small)
	- 함수의 첫번째 규칙
		- `함수는 작아질 수 있는 한 최대한 작아야 한다`
- 2. 블록이 적어야 함
	- if, else, while 문장 등의 내부 블록은 한줄이어야 함
	- 괄호가 try/catch 말고는 없어야 함 (최대한)
- 3. Indenting이 적어야 한다
	- 함수는 중첩 구조를 갖을 만큼 크면 안된다
	- 들여쓰기는 한 두 단계 정도만 
		- 객체 지향 생활 체조 원칙이 생각나네 
			- **토비님 글 찾아보자** 

리팩터링 전의 경우 하나의 함수에서 여러 일을 함 
- creating buffers 
- fetching pages
- searching for in herited pages
- rendering paths 
- appending arcane strings
- including setups and teardowns into test pages

리팩터링 후 
- 페이지가 테스트 페이지 인가?
	- 맞다면 setups, teardowns를 include 한 후
	- HTML 페이지로 전달

> 결과물이 3가지 일을 하고 있는거 아닌가?
- **메서드 이름이 추상화** 
	- 추상화를 한 단계 높임 
- 함수의 각 스텝들은 함수 이름보다 한수준 낮은 추상화 수준을 갖는다 
- 이 예제는 완전한 예제가 아니라 여기서 종료 
	- 실제 예제를 찾아보면 잘 되어 있다하는데 .. (`찾아보자`)

> [!tip] 함수의 각 스텝들이 함수 이름이 갖는 추상화 수준보다 한 단계 낮은 것으로만 이뤄졌다면 함수는 한가지 일만 하는 것


>[!note] 추상화 수준이 변하지 않는 수준까지 메소드 추출하면 자연스럽게 추상화 수준이 같은 메소드가 만들어진다 


예. 아래와 같이 함수를 메소드 추출하여 추상화해본다
- To include the setups and tear downs 
	- include setups
		- To include the setups 
			- include the suite setup if this is a suite
				- to include the suite setup
					- search the parent hiearchy for the "SuiteSetUp" page
					- add and include with the path of that page
			- then include the regular setup 
	- then include the test page content
	- then include the teardowns

뎁스별로 같은 추상화

**큰 함수**는 
- 변수와 인자로 구성 (=필드)
	- 이를 가지고 통신하는 기능 블락을 가짐 (=메서드)
- 항상 하나 이상의 클래스로 분리할 수 있다

---
### 5. Function part2
- Prime Number 리팩터링 예제

> [!tip] 아는 것과 필요할 때 사용할 줄 아는 것은 다르다. 연습을 많이 해야 필요할 때 자연스럽게 나올 수 있다.


**PrintPrimeTest**
- (특이하네)파일로 쓰고 읽어와서 비교하는 형태


---
### 6. Function Structure
아래의 내용을 살펴본다
1. Arguments
2. The Stepdown Rule
3. switches and cases
4. Temporal Coupling
5. CQS
6. Tell Don't Ask
7. Law of Demeter
8. early returns
9. error handling
10. Special Cases
11. Null is not an error
12. Null is a value
13. try도 하나의 역할/기능이다

**1. Arguments**
파라미터가 많으면 가독성도 떨어지고, 실수하기 좋다 
- 개선 방법1. Java Bean Pattern
	- getter/setter 사용
		- 이 경우 setter를 누락하면 불완전한 빈을 생성 가능 
- 개선 방법2. 빌더 패턴 사용 

Boolean 인자 사용 금지 
- 2가지 이상의 일을 하는 것을 의미하기 때문에 읽어야 함 
	- 2개의 함수로 분리 고려하기

Innies not ou??
- output 인자를 사용하지 말라 
- Argument는 함수로 전달되는 것이지 함수로부터 변경되어 나오는 것이라고 생각하지 않음

> 파라미터로 받은 인자를 함수 내부에서 변경한 후 다시 반환하는 것은 좋지 않다 💩 


the null defense
- null을 전달/기대하는 함수는 있으면 안 된다.💩
	- boolean을 전달하는 만큼 잘못된 것이다 (null인 경우와 아닌 경우 행위를 구분해야 한다💩)
	- 이 경우 2개의 함수를 만드는 것이 맞다
- null을 pseudo boolean으로 쓰지 마라
- defensive 프로그래밍을 지양하라 ⚠️
	- null, 에러 체크로 코드를 더럽히지 말라 
	- 잘못되었다는 단서다 (smell💩)
	- 이는 곧 팀원이나 단위 테스트를 못 믿는다는 말 
	- null 여부를 지속적으로 조사할 것이 아니라 **단위 테스트에서 검증**해야 한다
		- 단위 테스트에는 **회귀 테스트의 목적**도 있다
- 단, public api의 경우 defensive하게 프로그래밍 해야 한다🙌


**2.The Stepdown Rule**

> 모든 public은 위에, 모든 private는 아래에
> public 메서드만 보고도 클라이언트가 이해 가능하다록
- public part만 사용자에게 전달하면 된다
- 중요한 부분(public)은 위로 상세한 부분(private)은 밑으로 
- 이점
	- 편집자들은 마지막 부분은 필수적인 내용 전달 오류 없이 제거할 수 있다
	- 독자들은 제일 위에서부터 읽기 시작해서 지루해지면 그만 읽으면 된다
- backward reference 없이 top 에서 botton 으로 읽을 수 있게

> 메서드의 순서를 맞춰주는 IDE 기능이 있다?? public private 메서드


**3. switches and cases**
- 왜 스위치 문장을 꺼리는가?
	- 스위치는 객체지향스럽지 않다는 만족스러운 대답이 아니다
- 객체지향의 가장 큰 이점 중 하나는 의존성 관리 능력
	- DIP, 다형성 인터페이스를 구현체와 클라이언트 사이에 둠으로써
		- 런타임 의존성은 그대로 둔 채 소스 코드의 의존성을 역전시킴
			- 소크 코드의 의존성이 a > b 였는데 a > interface가 됨
	- 인터페이스가 중요
		- TDD에서도 인터페이스만 있으면 구현체 고려할 필요 없음
- 스프링은 DIP 구조를 가질 수 있도록 지원해주기 때문에 좋다
	- 인터페이스를 의존하기 때문에 단위테스트 작성하기도 쉽다
- 스위치 문장은 독립적 배포에 방해가 됨
	- 각 case 문장은 외부 모듈에 의존성을 갖는다
	- 다수의 다른 모듈에 의존성을 갖을 수 있다
		- 이것은 `fan-out problem` 이라고 한다
	- 구현체에 직접 의존하기 때문에 변경에 취약하다
	- switch 문장에서 소스 코드 의존성은 flow of control과 방향이 같다 
		- 모든 외부 모듈에 영향을 받는다 
		- 외부 모듈 중 하나라도 변경이 일어나면 switch 문장이 영향 받음
		- 독립적 배포를 불가능하게 하는 많은 의존성을 만듦

🙌 스위치 문장 제거 절차 
- 스위치 문장을 다형성 인터페이스 호출로 변환 
- case에 있는 문장들을 별도의 클래스로 추출하여 변경 영향이 발생하지 않도록 한다
- https://github.com/msbaek/videostore?tab=readme-ov-file

✨ 실습 remove-switch-statement 브랜치
- https://github.com/msbaek/videostore/tree/remove-switch-stmt?tab=readme-ov-file