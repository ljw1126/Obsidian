
- [유튜브](https://www.youtube.com/watch?v=60lLSe1phks&list=PLeQ0NTYUDTmMM71Jn1scbEYdLFHz5ZqFA&index=2)
- [발표자료](https://github.com/msbaek/clean-coders-2013)

**✅ 남은 강의**
- 22 ~ 26 TDD 
- 31. Presenting TDD
- 33. Vertical Slice 방식으로 GrpahQL 어플리케이션을 TDD로 구현하기


## 섹션1. 클린 코더스

### 2. 소개 및 OOP
절차지향 vs 객체지향
캡슐화 
다형성

>[!note] 창피함을 이기고 모르는 것을 질문 했을 때 성장을 할 기회가 있다

### 3. OOP part 2

절자 지향의 한계 
- 요구사항의 변경이 데이터 구조 변경 유발 
- 데이터를 사용하는 모든 코드의 수정 유발(Client, Test)

✨ 캡슐화를 하는 경우
- 절차 지향에 비해 상대적으로 변경의 영향이 적다
- 구현 변경의 유연함이 있어, 클라이언트 코드에 영향 안 미침

> [!note] Tell, Don't Ask
> - 데이터를 요청해서 변경하고, 저장하라고 하지마라
> - 무슨 기능을 실행하라
> - 데이터를 잘 알고 있는 객체에게 기능을 수행하라고 하라
> - Encapsulation이 유지되어 변경에 영향을 안 받게 됨  


Composition(합성) / Delegation(위임)
- 전략 패턴과도 연관 
	- 합성과 위임은 다르지 않나
	- Composition 패턴이 있고, 위임은 런타임에 동적으로 구현체를 바꿔가는 .. 다형성을 활용한 기법이고 

다형성 + Composition 통해
- 유연성 증대(변경 용이)
- 테스트 용이
- TDD 용이
- 인터페이스의 중요성 체감

> 예제 코드가 심플하다. 3개 인데 캡슐화와 다형성을 활용한 전략 패턴(위임)에 대해 가볍게 하고 넘어감


### 4. Function ✨ 
> 함수는 한 가지 일만 해야 한다 


// 리팩터링 도서에서 함수 조차 SRP가 적용되었던게 기억남

**The First Rule of Functions** 
- 함수는 더 이상 작아질 수 없을 만큼 작아야 한다
- 큰 함수를 보면 클래스로 추출할 생각을 해야함
- 클래스는 일련의 ㅂ녀수들에 동작하는 기능의 집합

> 마틴 파울러 Extract Method Object 


> [!todo] 예제 꼭 리팩터링 해보기
> [예제 저장소](https://github.com/msbaek/fitness-example) 


>[!note] org.fitness 라이브러리가 다운로드 되지 않아서 직접 찾아 넣어줘야 한다
>https://repo1.maven.org/maven2/org/fitnesse/fitnesse/20081201/

```java
public class FitnessExample {  
    public String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {  
        WikiPage wikiPage = pageData.getWikiPage();  
        StringBuffer buffer = new StringBuffer();  
  
        if (pageData.hasAttribute("Test")) {  
            if (includeSuiteSetup) {  
                WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);  
                if (suiteSetup != null) {  
                    WikiPagePath pagePath = wikiPage.getPageCrawler().getFullPath(suiteSetup);  
                    String pagePathName = PathParser.render(pagePath);  
                    buffer.append("!include -setup .").append(pagePathName).append("\n");  
                }            }            WikiPage setup = PageCrawlerImpl.getInheritedPage("SetUp", wikiPage);  
            if (setup != null) {  
                WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);  
                String setupPathName = PathParser.render(setupPath);  
                buffer.append("!include -setup .").append(setupPathName).append("\n");  
            }        }  
        buffer.append(pageData.getContent());  
        if (pageData.hasAttribute("Test")) {  
            WikiPage teardown = PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);  
            if (teardown != null) {  
                WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);  
                String tearDownPathName = PathParser.render(tearDownPath);  
                buffer.append("!include -teardown .").append(tearDownPathName).append("\n");  
            }            if (includeSuiteSetup) {  
                WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage);  
                if (suiteTeardown != null) {  
                    WikiPagePath pagePath = wikiPage.getPageCrawler().getFullPath(suiteTeardown);  
                    String pagePathName = PathParser.render(pagePath);  
                    buffer.append("!include -teardown .").append(pagePathName).append("\n");  
                }            }        }  
        pageData.setContent(buffer.toString());  
        return pageData.getHtml();  
    }          
}
```


마이클 팔저스 - 워킹 이펙리블리 레거시 코드 
- 캐릭터 라이즌 테스트 기법 (?) : 무조건 실행해서 말도 안되는 값으로 테스트 비교

1.필드 추출
`class field variable`로 옮겨서 생성자 초기화하게 되면 
- 함수가 추출될때 달고 다닐 필요가 없어짐
	- 함수는 작은 개수의 파라미터를 가져야 한다 (**조건 충족**)
	- 추출하려는 코드 블락이 두 개이상의 변수에 변경을 가하면 함수 추출 리팩터링을 못함 (이때 유용)

2.변수추출 
- 서로 다른 문자열이나 변수 값만 사용하는 경우 
	- 변수 추출 후 메서드 추출

3.라인 이동 리팩터링하여 변수를 올림
- 똑같은 로직 부분을 메소드 추출

> 서로 다른 부분은 변수로 추출 

4.변수 인라인하기
- 메서드에 인자에 넣고, 변수 지우기

> 강의자료에 리팩터링 결과 있음 🙌


리팩터링 효과 
- 가독성 향상 
- 이해하기 쉬워지고 함수가 자신의 의도를 잘 전달

개선의 원인
- 1. 함수가 작아짐(Small)
	- 함수의 첫번째 규칙
		- `함수는 작아질 수 있는 한 최대한 작아야 한다`
- 2. 블록이 적어야 함
	- if, else, while 문장 등의 내부 블록은 한줄이어야 함
	- 괄호가 try/catch 말고는 없어야 함 (최대한)
- 3. Indenting이 적어야 한다
	- 함수는 중첩 구조를 갖을 만큼 크면 안된다
	- 들여쓰기는 한 두 단계 정도만 
		- 객체 지향 생활 체조 원칙이 생각나네 
			- **토비님 글 찾아보자** 

리팩터링 전의 경우 하나의 함수에서 여러 일을 함 
- creating buffers 
- fetching pages
- searching for in herited pages
- rendering paths 
- appending arcane strings
- including setups and teardowns into test pages

리팩터링 후 
- 페이지가 테스트 페이지 인가?
	- 맞다면 setups, teardowns를 include 한 후
	- HTML 페이지로 전달

> 결과물이 3가지 일을 하고 있는거 아닌가?
- **메서드 이름 추상화** 
	- 추상화를 한 단계 높임 
- 함수의 각 스텝들은 함수 이름보다 한수준 낮은 추상화 수준을 갖는다 
- 이 예제는 완전한 예제가 아니라 여기서 종료 
	- 실제 예제를 찾아보면 잘 되어 있다하는데 .. (`찾아보자`)

> [!tip] 함수의 각 스텝들이 함수 이름이 갖는 추상화 수준보다 한 단계 낮은 것으로만 이뤄졌다면 함수는 한가지 일만 하는 것


>[!note] 추상화 수준이 변하지 않는 수준까지 메소드 추출하면 자연스럽게 추상화 수준이 같은 메소드가 만들어진다 


예. 아래와 같이 함수를 메소드 추출하여 추상화해본다
- To include the setups and tear downs 
	- include setups
		- To include the setups 
			- include the suite setup if this is a suite
				- to include the suite setup
					- search the parent hiearchy for the "SuiteSetUp" page
					- add and include with the path of that page
			- then include the regular setup 
	- then include the test page content
	- then include the teardowns

뎁스별로 같은 추상화

<u>큰 함수는 실제로는 클래스가 숨어 있는 곳</u>
- 변수와 인자로 구성 (=필드)
	- 이를 가지고 통신하는 기능 블락을 가짐 (=메서드)
- 들여쓰기에 존재하고, 변수들을 사용해서 통신하는 기능들의 집합
- 항상 하나 이상의 클래스로 분리할 수 있다

---
### 5. Function part2
- [Prime Number 리팩터링 예제](https://github.com/msbaek/print-prime)
	- master 브랜치는 리팩터링 결과 브랜치
	- 직접 해보는 브랜치는 따로 있음

> [!tip] 아는 것과 필요할 때 사용할 줄 아는 것은 다르다. 연습을 많이 해야 필요할 때 자연스럽게 나올 수 있다.


**PrintPrimeTest**
- (특이하네)파일로 쓰고 읽어와서 비교하는 형태


- 변수 색깔만 보고 한 군데에서만 사용하는 경우 로컬 변수나 메서드 파라미터로 받는게 나을 수 있다 
	- 메서드 내용이 NumberPrint라는 클래스로 바껴짐 ✨
- 인라인, 클래스 리네이밍

> 리팩터링 후 전체 라인수는 증가하지만 복잡도는 줄어듦 ➡️ 조건문이 깊어질수록 복잡도 증가


PrintPrime이 처음에는 one big function 구조 였다
- 리팩터링 후 Three little classes로 분리됨으로써 복잡도가 낮아짐

**큰 함수를 작은 함수들로 쪼갤때 흥미로운 일을 수행** 👀
- 함수를 서로 다른 추상화 레벨로 분리 
	- 함수가 하나 이상의 추상화 레벨을 다루면 이 함수는 한 가지 이상의 일을 하는 것
		- `fitness` 예제 에서
		- StringBuffer, parse, pageCrawler은 low level detail of implementation
		- 반면 testablePage, inheritedPage 등은 비즈니스 개념으로 high level of abstraction 
		- 하나의 함수가 2가지 개념들을 모두 다루는 것을 원치 않는다
		- 서로 다른 추상화 레벨을 서로 다른 함수로 분리
		- 함수가 한 가지 일만 하기 위해서는 추상화 레벨의 경계를 넘지 말아야 한다 
> 함수 레벨에서 추상화 단계를 분리한다는게 아직까지 와닿지 않음 (6/2)

하지만 추상화 레벨은 불분명(fuzzy)하다

>[!tip] Extract Till you Drop
>- 함수가 한가지 일만 하는지 어떻게 확실할 수 있는가?
>- 더 이상 extract할 수 없을 때까지 extract 하라
>- extract할 코드를 가진 함수는 한가지 이상의 일을 하는 것이다
>- 4줄 이내의 함수들로만 구성된 클래스 (분리 가능)
>- if, while 문 등에서 {} 블록이 보이면 extract 대상
>- {} 블록은 extract할 기회이다 !


**10. conclusion**
- 1st rule : `function should be small`
- 2nd rule  : `smaller than that`
- 이름을 잘 지으면 모두의 시간을 절약 가능
	- 네비게이션/이정표 역할을 하기 때문
- 함수를 작게 만들면 모두의 시간을 절약 가능 (경우에 따라 절차적인게 가독성이 나을 수 있다)
- 클래스는 큰 함수를 감춘다 (👀 **신호인듯**)
	- 함수를 여러 클래스들에 잘 배분하려면 함수를 작게 만들어야 한다
- 함수는 한가지 일만 해야하고, 한가지만 하는지 확신할 수 있는 유일한 방법은 `extract till you drop` 이다. 


> 맥북에서 control + t 누르면 가능한 리팩터링 표출해준다 ✨

---
### 6. Function Structure
- [강의 자료 이미지](https://github.com/msbaek/clean-coders-2013/blob/master/3.Function%20Structure.png)


아래의 내용을 살펴본다
1. Arguments
2. The Stepdown Rule
3. switches and cases
4. Temporal Coupling
5. CQS
6. Tell Don't Ask
7. Law of Demeter
8. early returns
9. error handling
10. Special Cases
11. Null is not an error
12. Null is a value
13. try도 하나의 역할/기능이다

**1. Arguments**
파라미터가 많으면 가독성도 떨어지고, 실수하기 좋다 
- 개선 방법1. Java Bean Pattern
	- getter/setter 사용
		- 이 경우 setter를 누락하면 불완전한 빈을 생성 가능 
- 개선 방법2. 빌더 패턴 사용 

Boolean 인자 사용 금지 
- 2가지 이상의 일을 하는 것을 의미하기 때문에 읽어야 함 
	- 2개의 함수로 분리 고려하기

Innies not ou??
- output 인자를 사용하지 말라 
- Argument는 함수로 전달되는 것이지 함수로부터 변경되어 나오는 것이라고 생각하지 않음

> 파라미터로 받은 인자를 함수 내부에서 변경한 후 다시 반환하는 것은 좋지 않다 💩 


the null defense
- null을 전달/기대하는 함수는 있으면 안 된다.💩
	- boolean을 전달하는 만큼 잘못된 것이다 (null인 경우와 아닌 경우 행위를 구분해야 한다💩)
	- 이 경우 2개의 함수를 만드는 것이 맞다
- null을 pseudo boolean으로 쓰지 마라
- defensive 프로그래밍을 지양하라 ⚠️
	- null, 에러 체크로 코드를 더럽히지 말라 
	- 잘못되었다는 단서다 (smell💩)
	- 이는 곧 팀원이나 단위 테스트를 못 믿는다는 말 
	- null 여부를 지속적으로 조사할 것이 아니라 **단위 테스트에서 검증**해야 한다
		- 단위 테스트에는 **회귀 테스트의 목적**도 있다
- 단, public api의 경우 defensive하게 프로그래밍 해야 한다🙌


**2.The Stepdown Rule**

> 모든 public은 위에, 모든 private는 아래에
> public 메서드만 보고도 클라이언트가 이해 가능하다록
- public part만 사용자에게 전달하면 된다
- 중요한 부분(public)은 위로 상세한 부분(private)은 밑으로 
- 이점
	- 편집자들은 마지막 부분은 필수적인 내용 전달 오류 없이 제거할 수 있다
	- 독자들은 제일 위에서부터 읽기 시작해서 지루해지면 그만 읽으면 된다
- backward reference 없이 top 에서 botton 으로 읽을 수 있게

> 메서드의 순서를 맞춰주는 IDE 기능이 있다?? public private 메서드


**3. switches and cases (중요✨)**
- 왜 스위치 문장을 꺼리는가?
	- 스위치는 객체지향스럽지 않다는 만족스러운 대답이 아니다
- 객체지향의 가장 큰 이점 중 하나는 의존성 관리 능력
	- DIP, 다형성 인터페이스를 구현체와 클라이언트 사이에 둠으로써
		- 런타임 의존성은 그대로 둔 채 소스 코드의 의존성을 역전시킴
			- 소크 코드의 의존성이 a > b 였는데 a > interface가 됨
	- 인터페이스가 중요
		- TDD에서도 인터페이스만 있으면 구현체 고려할 필요 없음
- 스프링은 DIP 구조를 가질 수 있도록 지원해주기 때문에 좋다
	- 인터페이스를 의존하기 때문에 단위테스트 작성하기도 쉽다
- 스위치 문장은 독립적 배포에 방해가 됨
	- 각 case 문장은 외부 모듈에 의존성을 갖는다
	- 다수의 다른 모듈에 의존성을 갖을 수 있다
		- 이것은 `fan-out problem` 이라고 한다
	- 구현체에 직접 의존하기 때문에 변경에 취약하다
	- switch 문장에서 소스 코드 의존성은 flow of control과 방향이 같다 
		- 모든 외부 모듈에 영향을 받는다 
		- 외부 모듈 중 하나라도 변경이 일어나면 switch 문장이 영향 받음
		- 독립적 배포를 불가능하게 하는 많은 의존성을 만듦

🙌 스위치 문장 제거 절차 
- 스위치 문장을 다형성 인터페이스 호출로 변환 
- case에 있는 문장들을 별도의 클래스로 추출하여 변경 영향이 발생하지 않도록 한다
- https://github.com/msbaek/videostore?tab=readme-ov-file

✨ 실습 remove-switch-statement 브랜치
- https://github.com/msbaek/videostore/tree/remove-switch-stmt?tab=readme-ov-file

후기.
- 우선 테스트 코드에서 상수 타입 명칭에 따라 Movie 하위 클래스 생성 (상속)
- 타입 코드를 생성자에서 직접 주입 하도록 리팩터링
- Movie 클래스 하위에 위치한 계산 메서드 2개를 서브 클래스에서 각자 구현하도록 리팩터링
	- 추상 메서드 선언
- **상속을 활용해 switch문에 다형성 적용하는 심플한 예제**


---

### 7. Function Structure (Part. 2)
- [stack-example](https://github.com/msbaek/stack-example/tree/master)


**4. Temporal Coupling**
- open, close를 순차적으로 호출해야 하는 비즈니스 로직의 경우
	- 사용자가 실수(누락) 가능하므로 아래 템플릿에서 변경 가능한 부분을 인터페이스로 빼고, 나머지 로직은 내부에 캡슐화
	- 🤔 템플릿 콜백 패턴 같네

```java
class FileCommandTemplate {
	public void process(File file, FileCommand command) {
		file.open();
		command.process(file);
		file.close();
	}
}
```

**5. CQS**
- side effect를 관리하는 좋은 방법
- 시스템의 상태 변경 가능
- command
	- side effect를 갖는다
	- 아무것도 반환하지 않는다
- query
	- side effect가 없다
	- 계산값이나 시스템의 상태를 변환
- CQS 정의 
	- 상태를 변경하는 함수는 값을 반환하면 안된다
	- 값을 반환하는 함수는 상태를 변경하면 안된다
- `당신 코드의 독자들을 혼란스럽게 하지 말라`
	- 값을 반환하는 함수는 상태를 변경하면 안된다
		- 상태를 변경하는 함수는 exception을 발생시킬 수 있지만, 값을 반환할 수는 없다
		- 이것은 약속이다
```java
// 💩 로그인을 하면 user 정보를 읽어야 함
User u = authorizer.login(userName, password);

// ✨
authorizer.login(userName, password);
User u = authorizer.getUser(userName);
```

**6. Tell Don't Ask**
- extreme한 CQS는 C와 Q를 함께 사용하지 말도록 한다.

유저가 로그인한 건지 if 조건문 검증보다 아래와 같이 예외 처리가 경우에 따라 나을 수 있단다
```java
try {
	user.execute(command);
} catch(NotLoggedIn e) {
	anthenticator.promptLogin();
}
```

나아가 아래와 같이 user 객체가 모든 것을 처리하도록 하는 것이 더 나을 수 있다 
```java
user.execute(command, authenticator);
```
- 로그인 여부 상태는 user 객체에 속함
- 왜 user 상태를 가져다가, user 대신해서 결정 하는가 
- user가 해당 범위를 수행하는 것이 맞다

**Tell Don't Ask**
- tell other object what to do
- but not to ask object what the stat is (상태를 묻지 마라)

> [!note] CQS를 강화하는 수단이 Tell Don't Ask 규칙이다


**7. Law of Demeter (디미터 원칙)**
- 메서드 체이닝이 너무 깊어지면
	- 하나의 함수가 전체 시스템 객체들 간의 네비게이션을 아는 것은 잘못된 설계이다
- 함수가 시스템의 전체를 알게 하면 안된다 
- 개별 함수는 제한된 지식만 가져야 한다
- 객체는 요청된 기능 수행을 위해 이웃 객체에게 요청해야 한다
- 요청을 수신하면 적절한 객체가 수신할 때까지 전파되어야 한다
- `law of demeter`는 아래와 같은 일련의 규칙을 통해 Tell Don't Ask를 형식화한다.
	- 인자로 전달된 객체
	- localy 생성한 객체
	- 필드로 선언된 객체
	- 전역 객체

**8. early returns**
- early return 이나 guarded return은 허용됨
- 루프의 중간에서 리턴하는 것은 문제이다 💣
	- break, 루프 중간에서의 return은 loop를 복잡하게 함
	- 코드가 동작하도록 하는 것보다 이해할 수 있게 하는 것이 더 중요✨

```java
private boolean isValidName() {
	if(name.equals("")) return true;
	if(..) return true;

	return false;
}
```


**9. error handling**
- [예제 저장소 - stack-example](https://github.com/msbaek/stack-example)
- 스택을 직접 구현할 때
	- 에러 처리를 위해 pop()은 null 반환하고, push()는 false를 반환할 수 있다
	- 이보다는 exception을 발생시키는 것이 좋다
		- 실패시 값에 대해 알아야 하네.. 내부 구현을 알아야 한다는 의미인듯🤔
	- 이때 exception의 이름은 최대한 구체적이여야 한다. 

```java
public static Stack make(int capacity) {
	if(capacity < 0) 
		throw new IllegalCapacity();
	if(capacity == 0)
		return new ZeroCapacityStack(); // NOP, 널오브젝트 패턴

	return new BoundedStack(capacity);
}

public static class IllegalCapacity extends RuntimeException { 
}
```

**checked vs unchecked 예외**
- checked 예외가 발생하면 catch나 throw 해야 한다 
	- 특정 기술의 예외에 대한 의존이 발생
	- checked exception을 아예 사용하지 말라 
		- 단, 👀 재시도 로직의 경우 checked exception이 필요하다고 생각
		- 그리고 public api의 경우에도 checked exception이 필요
- 예외 메시지는 어떤걸 담아야 하나?
	- 메시지가 필요없는게 가장 좋다 👍
	- 예외 클래스 이름을 정확하게 지어 이름으로 의미가 전달되도록 하라
		- 가장 좋은 커맨트는 커맨트를 작성하지 않는 것이다
		- 코드(이름)가 커맨트를 대신하도록 해라

**10. Special Cases**
- `stack-example` 예제에서 ([저장소](https://github.com/msbaek/stack-example))
	- capacity가 0인 경우 어떻게 처리할 것인가? `Null Object Pattern` 사용
		- Stack 인터페이스 추출 
		- 특이한게 인터페이스에 런타임 예외를 선언하네 🤔

> 절차를 지키지 못했다.
- https://github.com/msbaek/stack-example/blob/master/src/test/java/new-requirement
- https://github.com/msbaek/stack-example/blob/master/SpecialCases.md

**11. Null is not an error**
- 예제 스택에서 
	- `top()` 호출시 null 반환보다 `Stack.Empty` 예외를 던지는게 나을 수 있다.
		- 아무도 null 기대하지 않을 것이다 
		- null을 던지면 시스템의 여기저기에 조용히 퍼지는 속성이 있다

**12. Null is a value**
- 예제 스택에서 
	-  `find()`에서 element가 없을 수 있기 때문에 -1보다 null이 의미있을 수 있다 (`Null == Nothing`)

**13. try도 하나의 역할/기능이다**

---
### 8. Form 
> 개념적인 부분이 많다


---

### 9. TDD 1️⃣
- 개념을 살펴봄
- 아무것도 없는 상태에서 Movie 클래스를 TDD로 만드는 과정을 보여줌
	- 2️⃣부터 본격적인 예제

### 10. TDD 2️⃣ - tyrant
- 서버 설치 후 통신하는 도메인 클래스를 TDD로 개발하는 예제
- `tokyo-cabinet`과 `tokyo-tyrant`설치해야 하는데 10년 전이라 다운로드 불가
- 저장소:  [https://github.com/msbaek/tyrant-client-tdd](https://github.com/msbaek/tyrant-client-tdd)
	- `git clone` 내려 받고 가이드라인에 따라 `tokyo-tyrant` 설치 후 실행
- 절차적인 실행 코드를 리팩터링
    - 1. inner class 추출
    - 2. 로컬 변수를 멤버 변수로 이동
    - 3. 파라미터를 변수 추출
    - 4. 메서드 추출
    - 5. 변수 인라인
    - 6. 로컬 변수를 메서드 인자로 전환
    - 7. 상위 클래스로 추출
- 개인적으로 👀
	- 메서드 추출하기 전 서로 다른 값을 가지는 파라미터에 대해 변수를 추출한 후 메서드 추출하는 게 인상적.
	- 클래스 내에서 public 을 위에 두고, private을 아래에 두는 것도 인상적.

**리팩터링 전**
```java
class TyrantMapTest {  
  
    @Test  
    void getRetrievesWhatWasPut() throws IOException {  
       Socket socker = new Socker("localhost", 1978);
       OutputStream writer = socker.getOutputStream();
       writer.write(0xC8); // OPERATION_PREFIX
       writer.write(0x10); // OPERATION_PUT
       writer.write(0);
       writer.write(0);
       writer.write(0);
       writer.write(3); // key length
       writer.write(0);
       writer.write(0);
       writer.write(0);
       writer.write(5); // value length
       writer.write("key".getBytes());
       writer.write("value".getBytes());

	   InputStream reader = socket.getInputStream();
	   int status = reader.read();
	   assertThat(status).isEqualsTo(0); // 0 성공, 그외 실패
		
    }  
}
```


**리팩터링 후**
```java
class TyrantMapTest {  
  
    @Test  
    void getRetrievesWhatWasPut() throws IOException {  
        TyrantMap tyrantMap = new TyrantMap();  
        tyrantMap.open();  
        tyrantMap.put("key", "value");  
        assertThat(tyrantMap.get("key")).isEqualTo("value".getBytes());  
        tyrantMap.close();  
    }  
}
```


```java
public class TyrantMap {  
    public static final int OPERATION_PREFIX = 0xC8;  
    public static final int OPERATION_PUT = 0x10;  
    public static final int OPERATION_GET = 0x30;  
  
    private Socket socket;  
    private DataOutputStream writer;  
    private DataInputStream reader;  
  
    public void put(String key, String value) throws IOException {  
        writeHeader(OPERATION_PUT);  
        writeKeyValue(key, value);  
        verifyStatus();  
    }  
  
    public void open() throws IOException {  
        socket = new Socket("localhost", 1978);  
        writer = new DataOutputStream(socket.getOutputStream());  
        reader = new DataInputStream(socket.getInputStream());  
    }  
  
    public byte[] get(String key) throws IOException {  
        writeHeader(OPERATION_GET);  
        writeKey(key);  
        verifyStatus();  
        return readResults();  
    }  
  
    public void close() throws IOException {  
        reader.close();  
        writer.close();  
        socket.close();  
    }  
  
    private void writeKey(String key) throws IOException {  
        writer.writeInt(key.length());  
        writer.write(key.getBytes());  
    }  
  
    private void writeHeader(int operationCode) throws IOException {  
        writer.write(OPERATION_PREFIX);  
        writer.write(operationCode);  
    }  
  
    private void writeKeyValue(String key, String value) throws IOException {  
        writer.writeInt(key.length());  
        writer.writeInt(value.length());  
        writer.write(key.getBytes());  
        writer.write(value.getBytes());  
    }  
  
    private void verifyStatus() throws IOException {  
        int status = reader.read();  
        assert status == 0;  
    }  
  
    private byte[] readResults() throws IOException {  
        int length = reader.readInt();  
        byte[] results = new byte[length];  
        reader.read(results);  
        return results;  
    }  
}
```

### 11. TDD 3️⃣ - bowling game (유명한 예제)
- 볼링 게임에 대한 규칙을 확인 후 TDD 기반으로 구현 
- 📌 규칙
	- 볼링 게임은 10개의 프레임으로 구성된다
	- 각 프레임은 대게 `2룰`을 갖는다 
		- ➡️ 10개의 핀을 쓰러뜨리기 위해 2번의 기회를 갖는다
	- `Spare`: 10 + next first roll에서 쓰러 뜨린 핀수
	- `Strike`: 10 + next two roll에서 쓰러 뜨린 핀수
	- 10th 프레임은 특별
		- spare를 처리하면 3번 던질 수 있다
- Game이라는 클래스를 생성
	- `bowling` 패키지에
	- roll과 score라는 2개의 메소드를 가짐
	- roll 함수: ball을 roll할 때마다 호출된다. 인자로는 쓰러뜨린 핀 수를 가짐
	- score 함수: 게임이 끝난 후에만 호출되어 게임의 점수를 반환한다
- `new int[21]` 배열에 순차적으로 저장하기 때문에 점수 게산은 문제없으나 frame 별로 점수가 어떻게 되는지 표출하는거는 고려하지 않을 듯하다💩
	 
> 켄트벡의 클린코더스 영상이라는게 있는 듯

에제 저장소 - https://github.com/msbaek/bowling-game

**용어**
- frame: 판을 뜻하고, 2번씩 던짐
	- 단, 10번째 프레임에 경우에 따라 보너스 롤(`+1`) 이 있을 수 있다 (최대 3번)
	- 배열 크기를 21로 초기화해서 0 ~ 20까지 하니, 10번째 프레임의 보너스를 고려했구나
- strike : 첫 번째 투구에서 10개 핀 전부를 쓰러뜨림 (`X` 표기)
- spare: 두 번의 투구로 총 10개의 핀을 모두 쓰러뜨림 (`/` 표기)
- open frame: 2번 던졌는데 합이 10이 안되는 경우 

**점수 계산**
- one frame: 투구 2번의 합 (10 미만)
- spare: 
	- 2번 던져서 10개를 쓰러 뜨림
	- 다음 프레임의 첫번째 투구 값이 보너스 점수로 합산됨 
	- `10 + 다음 프레임의 첫번째 투구 값(보너스)`
- strike:
	- 1번 던져서 10개를 쓰러 뜨림 
	- 다음 프레임의 2개 투구 값이 보너스 점수로 합산됨 
	- `10 + 다음 프레임의 두개의 투구 값(보너스)`


스트라이크가 연속해서 나온 경우 (edge case 👀)
```text
[1] X       → 다음 두 번: X(10), 3 → 10+10+3 = 23
[2] X       → 다음 두 번: 3, 4    → 10+3+4 = 17
[3] 3 4     → 합: 7
```
- **프레임 단위가 아니라 투구 단위**로 "총 2번의 실제 투구 점수"를 더해야 합니다.
- 스트라이크가 연속해서 나오니 3번째 프레임의 첫번째 값이 합산되버림
- 예제의 경우 순차적으로 인덱스에 pins 개수를 할당하기 때문에 엣지 케이스도 통과함✨

스페어 다음에 스트라이크가 나오는 경우 
```text
[1] 5 /    10 + 10 = 20, 다음 투구가 스트라이크이므로
[2] X      10 + .. 다음 투구 2회 대기
```


public class 를 먼저 만들 수 있지만, nothing부터 시작 
```java
public class GameTest {  
    @Test  
    void nothing() {  
        Game game = new Game();  
    }  
}
```

> tdd를 할 때 실패할 테스트 작성, 성공, 리팩터링 사이클을 지키도록 한다
> 이때 테스트 케이스는 최대한 간단한 것부터 작성
> - 예제 코드의 테스트 순서를 확인하기


> 중복되는 메서드 추출할 때 변수값이 다른 경우 
> - 변수 추출 ➡️ 메서드 추출 ➡️ 변수 인라인


one spare 테스트시 실패하게 되고, Game에 SRP 책임이 위반된것을 확인하는게 인상적
```java
@Test  
void oneSpare() {  
    game.roll(5);  
    game.roll(5);  
    game.roll(3);  
    rollMany(17, 0);  
  
    assertThat(game.getScore()).isEqualTo(16);  
}  
  
private void rollMany(int pins, int frame) {  
    for(int i = 0; i < frame; i++) {  
        game.roll(pins);  
    }  
}
```


```java
public class Game {  
    private int score;  
  
    public void roll(int pins) {  
        this.score += pins;  
    }  
  
    public int getScore() {  // 점수 계산의 책임을 가짐
        return this.score;  
    }  
}
```

// 요구사항에 대한 좋은 말이 있었음 .. 
### 12. TDD 4️⃣ - primefactor and wordwrap 
- 마찬가지로 요구사항 확인 후 2개의 예제 수행
- primefactor : 소인수 분해, wordwrap: 단어 나누기
- 저장소 : https://github.com/msbaek/primefactors


```java

  
public class PrimeFactorTest {  

	@Test  
	void canFactorIntoPrimes() {  
		assertThat(of(1)).isEqualTo(list());  
		assertThat(of(2)).isEqualTo(list(2));  
		assertThat(of(3)).isEqualTo(list(3));  
	}  
	
	private List<Integer> list(Integer... ints) {  
		return Arrays.asList(ints);  
	}  
	
	private List<Integer> of(int n) {  
		List<Integer> factors = new ArrayList<>();  
		if(n > 1)  
			factors.add(n);  
	
		return factors;  
		}  
	}

}
```
- 테스트가 성공하도록 가장 심플하게 구현 (static)

```java
public class PrimeFactorTest {  
  
    @Test  
    void canFactorIntoPrimes() {  
        assertPrimeFactors(1, list());  
        assertPrimeFactors(2, list(2));  
        assertPrimeFactors(3, list(3));  
        assertPrimeFactors(4, list(2, 2));  
        assertPrimeFactors(5, list(5));  
        assertPrimeFactors(6, list(2, 3));  
        assertPrimeFactors(8, list(2, 2, 2));  
        assertPrimeFactors(9, list(3, 3));  
    }  
  
    private void assertPrimeFactors(int n, List<Integer> list) {  
        assertThat(of(n)).isEqualTo(list);  
    }  
  
    private List<Integer> list(Integer... ints) {  
        return Arrays.asList(ints);  
    }  
  
    private List<Integer> of(int n) {  
        List<Integer> factors = new ArrayList<>();  
        if(n > 1) {  
            while(n % 2 == 0) {  
                factors.add(2);  
                n /= 2;  
            }  
  
            while(n % 3 == 0) {  
                factors.add(3);  
                n /= 3;  
            }  
        }  
        if(n > 1)  
            factors.add(n);  
        return factors;  
    }  
}
```

> [!note] 원칙이 증가할수록 production 코드는 제네럴 해져야 한다(구체화)
> if 조건문이나, while을 for로 변환

```java
private List<Integer> of(int n) {  
    List<Integer> factors = new ArrayList<>();  
    int divisor = 2;  
    for(;n > 1; divisor++) {  
        for(;n % divisor == 0; n /= divisor) {  
            factors.add(divisor);  
        }  
    }  
    return factors;  
}
```


word wrap 예제 
https://github.com/msbaek/wordwrap

> nothing이라는 아무것도 없는 테스트를 만들고 실행해보는게 개발자에게 심리적 안정감을 준다함 

```java
public class WrapperTest {  
  
    @Test  
    void shouldWrap() {  
        assertThat(wrap("word word", 4)).isEqualTo("word\nword");  
        assertThat(wrap("a dog", 5)).isEqualTo("a dog");  
        assertThat(wrap("a dog with a bone", 6)).isEqualTo("a dog\nwidth a\bbone"); // fail
  }  
  
    private static String wrap(String s, int width) {  
        return s.length() > width ? s.replaceAll(" ", "\n") : s;  
    }  
}
```
- `Getting Stuck` 상태에 빠짐 
	- 현재 실패하고 있는 테스트를 성공시키기 위해 점진적(incremental)으로 할 수 있는 일이 없고
	- 테스트를 성공시키기 위해서는 아주 많은 양의 프로덕션 코드를 작성해야 하고
	- 극단의 경우 전체 알고리즘을 다시 작성해야만하는 경우를 일컫는 기술적 용어
- 이 **테스트를 패스시키는 유일한 방법은 알고리즘을 다시 작성하는 것 뿐**이다.


**Getting Unstuck**👍  // 좋은거 같다. 스텝을 밟아가면서 테스트 케이스 검증
- `most degenerate test case`를 먼저 작성하고
- 이 복잡함 퀴즈를 아주 작은 스텝씩 올라가자.
- 각 경우에서 해당 테스트를 통과시키도록 specific한 fix를 하는 것이 아니라
- production code를 generalizing하여 테스트가 통과되도록 하자.

```java
public class WrapperTest {  
  
    @Test  
    void shouldWrap() {  
        assertWraps(null, 1, "");  
        assertWraps("", 1, "");  
        assertWraps("x", 1, "x");  
        assertWraps("xx", 1, "x\nx");  
        assertWraps("xxx", 1, "x\nx\nx");  
        assertWraps("x x", 1, "x\nx");  
        assertWraps("x xx", 3, "x\nxx");  
        assertWraps("four score and seven years ago our fathers brought forth upon this continent",  
                7,  
                "four\nscore\nand\nseven\nyears\nago our\nfathers\nbrought\nforth\nupon\nthis\ncontine\nnt");  
    }  
  
    private static void assertWraps(String s, int width, String expected) {  
        assertThat(wrap(s, width)).isEqualTo(expected);  
    }  
  
    private static String wrap(String s, int width) {  
        if(s == null)  
            return "";  
  
        if(s.length() <= width)  
            return s;  
  
        int breakPoint = s.lastIndexOf(" ", width);  
        if(breakPoint == -1) {  
            breakPoint = width;  
        }  
  
        return s.substring(0, breakPoint) + "\n" + wrap(s.substring(breakPoint).trim(), width);  
    }  
}
```


---

### 10. Architecture

**What is Architecture**
- `아키텍처는 사용법(Usage)에 대한 것이다`
- 전체적인 시스템 개발에 기반을 제공하는 변경 불가한 초기 결정사항의 집합
	- Eclipse: development environment
	- Spring, Tomcat, Hibernate: Framework
	- MySQL, MVC 


**What is Use Case**
> a list of steps, typically defining interactions between a role(actor) and a system, to achieve a goal
- `actor` : 사용자 그룹
- `use case`: actor가 사용하는 기능, 일련의 단계 (상호작용)


**Architecture Exposes Usage**
- 아키텍처는 사용법에 대해서 설명
- Use case should stand alone
- ...


**Deferring Decisions**
- 좋은 아키텍처는 FW, WAS, UI 등과 같은 stuff들에 대한 결정을 연기하는 것을 허용
	- Stuff에 대한 결정은 연기될 수 있어야 하고, 연기되어야 한다
	- 이게 좋은 아키텍처의 주요한 목적 중 하나
- 시간이 지날수록 결정을 위한 정보가 풍부해짐 


(Fitness 예제 및 설명 생략)

**Central Abstraction**
- 많은 아키텍트는 DB를 core abstraction 이라고 생각
	- DB가 동작하고 스키마가 준비되기 전에는 어떠한 생각도, 작업도 시작하지 않는다 💩
- **개발 입장에서 추상화한 후에 기능부터 하고 데이터를 하면** 👍
	- 데이터부터하면 절차지향적으로 감
- Fitness 프로젝트의 Central Abstraction - WikiPage
	- DB를 연기할 수 있는 Detail로 간주
	- 좋은 아키텍처는 Tool, Framework로 구성되는 것이 아니다 
	- 좋은 아키텍처는 UI, WAS, DI FW 등과 같은 Detail에 대한 결정을 연기할 수 있도록 해준다
- 어떻게 하면 이렇게 연기할 수 있나?
	- 연기하고 싶은 것에서 구조를 decouple, irrelevant 하게 설계
- 어떻게 하면  Tool, FWs, DB에서 decouple 하나?
	- 아키텍처 측면에서 SW 환경이 아닌 Use Case에 집중하라

**Conclusion**
- 아키텍처를 Use case에 집중
	- 다른 시스템 컴포넌트에 대한 결정을 미룰 수 있다
	- 이러한 연기는 우리의 선택을 최대한 오래 열어둘 수 있다. 
	- 이말은 필요에따라 결정을 변경할 수 있다는 것이다
	- 프로젝트 진행 중에 충분한 정보(도메인) 생김에 따라 undo에 대한 비용없이 여러번 변경할 수도있다

>(👀 내생각) 외부 의존성을 제외하고 Use case에 집중해 도메인 설계부터 하면 구현 및 피드백이 빠르기 때문에 도메인에 대한 이해도가 높아지고, 더 좋은 설계를 만들수있다



### 11. Architecture UseCase
- 도메인 모델 설계 방법을 살펴봄

**1. 클래스/속성/관계 식별**
- 도메인 영역의 주요 개념(명사)를 식별
- "Applying UML and Patterns" 참조
- 정적 모델링
	- 클래스
	- 속성
	- 관계 식별


**2. 도메인 모델에 행위 추가하기**
- 도메인 모델에 행위를 추가함으로써 도메인 모델에 생명력을 부여
- 도메인 모델의 행위를 결정하기 위해 도메인 모델의 책임(Responsibility)과 상호작용(Collaboration)을 식별
- 클래스의 책임
	- 클래스가 아는 것(속성, 관계), 하는 것, 결정 하는 것 등
- 클래스의 상호작용
	- 책임 수행을 위해 호출하는 다른 클래스들
- 책임과 상호작용을 식별하는 절차
	- 1. 요구사항 ..
	- 2. 도메인 모델의 클라이언트(프리젠테이션 티어 등)에게 도메인 모델을 노출하기 위한 도메인 모델의 인터페이스(타입, 메소드) 결정
	- 3. 해당 인터페이스를 각각의 요구사항을 고려하여 TDD 접근법으로 구현

**2.1 요구사항 식별하기**
- 처리해야 할 요구사항 식별 ➡️ 어떻게 응답할지 결정
- UI 디자인, 유스케이스, 유저스토리 등을 분석
- 요구사항은 2가지 부분으로 구성 
	- 사용자 행위
	- 사용자 행위 요청에 대한 어플리케이션의 응답(책임)
- 어플리케이션의 책임은 2가지로 그룹핑 
	- 사용자 입력 검증, 값 계산, 데이터베이스 갱신 등
	- 값 출력

> CQS, 2가지 행위로 나뉨


**2.2 메소드 식별하기**
- 각 요청에 대해 2가지 메소드들이 존재
	- 서비스 메소드
		- 사용자 요청 검증
		- 계산 수행
		- 데이터베이스 갱신
	- 레파지토리 메서드
		- 출력을 위한 데이터 반환
- 도메인 모델의 클라이언트는 도메인 티어를 2번 호출
	- 서비스 메소드 + 레파지토리 메소드


**2.3 TDD로 메소드 구현하기**
- 대상 서비스 메소드에 대해 하나 이상의 T.C를 작성하는 것으로 시작
	- 각 테스트케이스는 서로 다른 상황을 재현하기 위해 다른 인자로 구성됨
- mock 객체를 이용해서
	- service methods ➡️ repository methods 순으로 top-down 방식으로 구현
	- 구현을 하다가 발견되는 collaborator를 구현하기 위해 머릿속에서 context-switching이 일어날 필요가 없이 집중하면서 구현 가능

📚 [POJOs in Action](https://www.manning.com/books/pojos-in-action)
- `3. Using the Domain Model Pattern`


**Architecture**
- 웹 시스템에서는 비즈니스 로직에 대해 얘기하지 않고 웹 시스템의 이슈에 대해 말하는 경우가 많다 👀

**Use Cases**
- 딜리버리 문제를 우아하게 해결하는 방법
	- 딜리버리 메커니즘
- `"Object-Oriented Software Engineering - A Use Case Driven Approach", Ivar Jacobson`
	- Delivery 문제를 우아한 아키텍처로 해결
	- Delivery와 무관한 방식으로 사용자가 시스템과 상호작용하는 방식을 이해하는 것
	- 링크, 버튼, 클릭 등의 용어를 사용하지 않고 표현
	- Delivery 매커니즘을 나타내지 않는 용어를 사용 
	- 제이콥슨은 이런 상호작용을 **Use Case**라고 했다
	- 어플리케이션 개발은 Delivery와 독립적인 Use Case에 의해 주도되어햐 한다.
	- Use Case가 시스템에서 가장 중요한 것



> 특정 웹 시스템의 딜리버리 매커니즘이 MVC를 뜻하는가 싶다
> MVC에 집중하다보면 비즈니스에 대해 소홀해진다는 의미인듯


> 개별적으로 배포할 수 있다는건 개별적으로 개발가능하다


> 딜리버리 메커니즘의 변경이 있더라도 내 어플리케이션은 보호받을 수 있다가 중요


**Use Case Driven Architecture**
> 14:05 클래스 다이어그램 추가하기
- use case driven 시스템의 아키텍처를 보면 delivery 메커니즘이 아닌 use case를 보게 됨
	- 독자가 보게되는 것은 **시스템의 의도**이다


**Use Case (정의)**
- 사용자가 특정 목적을 이루기 위해 시스템과 어떻게 상호작용하는지에 대한 형식적 기술
- 목적: 주문처리시스템에서 새로운 주문을 생성하는 것
	- screen, button, field 등과 같은 웹(delivery 매커니즘)과 같은 것들은 언급하지 않음
	- 시스템으로 들어가는 데이터, 커맨드와 시스템이 응답하는 것만 언급
	- Delivery 매커니즘과 무관한 아키텍처를 가지려면 delivery 매커니즘과 무관한 use case로 시작해야 한다
	- Use case의 응답도를 주목
		- orider-id는 완전하게 delivery 메커니즘과 무관 
		- human clerk은 order-id를 볼 필요가 없다
		- 반면 delivery 매커니즘은 팝업을 띄워서 사용자에게 항목을 주문에 추가하라고 요청할 수 있다
- **Use Case는 입력 데이터를 해석하여 출력 데이터를 생성하는 필수 알고리즘이다**
	- Use Case를 구현하는 객체를 생성할 수 있다는 것을 의미
	- ?? 예제??


**Use Case 알고리즘**
- 다른 비즈니스 객체들(Customer, Order)을 언급
- 알고리즘: use case 정의, 비즈니스 규칙을 내포
- 하지만 이런 비즈니스 규칙은 Customer, Order 객체에 속하지 않는다
	- 👀 인터페이스로 정의하고 특정 레이어에서 조합하는게 아닐까
- 그럼 어디에 비즈니스 규칙을 내포 시킬 것인가? 
- 어떤 객체에 위치시킬 것이며 Use Case 객체를 아키텍처의 어디에 위치시킬 것인가?
- 어떻게 우리의 시스템을 partition해서 use case가 central organizing principle이 되게 할 것인가?


**Partitioning**
- 야콥슨: 아키텍처는 3개의 fundamental kinds of object들을 갖는다 
	- 비즈니스 객체 : `엔티티`
	- UI 객체 : `Boundaries`
	- Use Case 객체: Controller 또는 MVC와 혼동을 피하기 위해 `Interactors`라고 부름
- 엔티티 have
	- Application 독립적인 비즈니스 로직 
	- 다른 application에서도 엔티티들은 사용됨
	- 특정 application에 특화된 메소드를 갖으면 안됨 
		- 이런 메소드들은 Interactor로 옮겨야 한다 📌
- Interactor have
	- application에 종속적인 비즈니스 로직 
	- 특정 application에 특화된 메소드들은 Interactor 객체에 구현
- Interactors는 application에 특화된 로직을 통해 목적을 달성
	- application과 무관한 entity 로직을 호출 
	- Use Case 목적을 달성하기 위해 entity의 메서드들을 어떻게 호출하는지 아는 것이 Interactor의 책임이다

> Interactor가 서비스가 될수도 있고, 컨트롤러가 될 수 있어 보이네 👀

- Use Case의 책임중 하나는 사용자로부터 입력을 받고, 결과를 다시 사용자에게 반환하는 것
- 이를 위해 또 다른 객체가 존재 
	- **boundary object** (ex. dto)
		- Use case를 delivery 매커니즘으로부터 격리
		- Use case를 delivery 매커니즘 간의 통신 수단 제공
		- MVC / Console / Thick Client 등은 Boundary의 반대편에 존재
		- Use case는 이러한 Delivery 매커니즘에 대해 모른체 Boundary의 또 다른 반대편에 존재

**Partitioning - Flow**
- Delivery 매커니즘
	- 사용자 요청 수집 
	- 요청을 표준적인 형식(RequestModel)으로 표현 
	- Boundary를 통해 RequestModel을 Interactor에 전달
- Interactors 
	- applications 특화된 비즈니스 로직 수행
	- entity를 조작하여 application 독립적인 비즈니스 로직을 수행
	- 결과를 수집
	- 표준적인 형식(ResultModel) 생성
	- Boundary를 통해 다시 Delivery 매커니즘으로 전달


**Use Cases and Partitioning**
- 우리는 시스템의 행위를 use case로 기술한다
	- Use case에서 application 특화된 행위를 interactor 객체로 캡쳐한다
	- application 무관한 행위를 entity 객체로 캡쳐하고 interactor로 제어한다
	- UI 종속적인 행위는 Boundary 객체로 캡쳐하여 intractor와 커뮤니커에시녀한다. 

의존성은 단방향, 데이터베이스도 격리와 DIP 적용


**Case Study**
- 📚 "Agile Software Development - Principles, Patterns and Practices" - SOLID, Design Patterns, Agile Practices
- 📚 Payroll System 
	- https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445
	- https://github.com/FreekPaans/PPPPayrollCaseStudy


유스케이스 설계, Delivery 메커니즘은 이랃ㄴ 무시


**Conclusion**
- 📚 "Agile Software Development - Principles, Patterns and Practices" - SOLID, Design Patterns, Agile Practices
- Architectures는 툴이나 프레임워크에 기반하지 않는다
- 좋은 Architectures는
	- 툴이나 프레임워크에 대한 결정을 아주 오랫동안 미룸
	- 이행되지 않는 결정의 갯수를 최대화 
	- delivery 매커니즘에 의존하지 않고, 노출시키지 않고 숨김
- 시스템의 모양을 보면 웹 시스템인지 여부를 알 수 없어야 함
- 시스템의 use case는 주요한 추상화(primary abstraction)이고 시스템 아키텍처를 구성하는 핵심적인 원칙
- 아키텍쳐를 보면 UI가 아니라 시스템의 의도를 볼 수 있어야 함
- Use case 지향 아키텍쳐를 만들기 위한 야콥슨의 Boundary, Interactor, Entity partition을 배웠다.
- Interactor가 use case를 캡슐화하고 entity는 비즈니스 객체를 캡슐화하고, boundary는 UI와 격리를 제공
- 격리를 얻기 위해 application을 delivery 측과 분리하는 boundary 인터페이스를 생성


**Who is the Architect?**
- 생략..

---

## 12. SOLID Foundation

> 대부분 이론적인 설명

**The Source Code is Design**
- 소프트웨어
	- 저렴한 구축 비용 (컴파일, 빌드)
	- 비싼 설계 비용(소스 코드 작성)
- 반면, 건물/회로/기계
	- 저렴한 설계 비용
	- 비싼 수정 비용


**Design Smells**
- `Rigidity` (강직성, 견고함)
- `Fragility` (취약성)
- `Immobility` (부동성)
- `Viscosity` (점성)

`Rigidity`
- 시스템 의존성으로 인해 변경하기 어려워지는 것 
		- 결합도가 높아서 변경시 컴파일 오류 발생, 수정할 곳이 많아진다는거네
- Rigid하게 하는 원인
	- 많은 시간이 소요되는 테스트와 빌드
	- 전체 리빌드를 유발하는 아주 작은 변화
- 테스트와 리빌드 시간을 줄이면
	- Rigidity를 줄이고
	- 수정이 용이해짐

`Fragility`
- 한 모듈의 수정이 다른 모듈에 영향을 미칠 때
- ex. 자동차를 sw로 제어
	- 라디오 버튼을 수정하는데 자동 창문이 영향을 받는다
- 해결책
	- 모듈간의 의존성을 제거한다

`Immobility`
- 모듈이 쉽게 추출되지 않고 재사용되지 않는 경우
- ex. 로그인 모듈이 특정 DB의 Schema를 사용하고, 특정 UI Skin을 사용하는 경우
	- 이 로그인 모듈은 다른 시스템에서 재사용하지 못하는 것 
	- 이 로그인 모듈은 Immobile하다라고 표현 
- 해결책
	- DB, UI, Framework 등의 결합도를 낮추는 것

`Viscosity`
- 빌드/테스트 같은 필수 오퍼레이션들이 오래 걸려 수행이 어렵다면 그 시스템은 역겨운 (disgust) 것
	- 체크인, 체크아웃, 머지 등은 비용이 크고 역겨움 
	- 여러 레이어를 가로질러 의존성을 갖는 것은 역겨움
- 항상 같은 역겨움의 원인 
	- Irresponsible tolerance (**무책임한 용인**) ➡️ 개인적으로 좋은 부분
		- 나빠질거라는 걸 아는데 아무것도 하지 않음 💩
		- 바쁘니깐 .. 어쩔수없으니깐 .. 타협하고 쓰레기 코드를 작성
		- 결국 부채가 쌓임
- 강하게 oupling된 시스템은 테스트, 빌드, 수정을 어렵게 한다
- 해결책
	- dependency는 유지한채, decoupling 하는 것 🤔


**Needless Complexity** (불필요한 복잡성✨)
- SW 설계의 이슈 
	- 미래를 어떻게 다루나 
- 현재 요구사항만 구현 vs 미래를 예측하여 구현 
	- 앞으로의 확장을 고려하여 설계?
		- 불필요하게 시스템 복잡도 🆙
		- 개발자는 현재를 제어할 수 없음
- 불필요한 복잡함은 강한 커플링을 유발 
- 해결 방법
	- **현재 요구 사항에 집중**한다👍


> Code Rot , 키보드 입력에 대한 예제 (생략)
> - 장치 추가에 따른 변경이 발생
> - OOP 구현


**OOP**
- High Level dont depend on Low level
	- 구현체는 인터페이스에 의존 (캡슐화)
	- 입출력 기기가 출력되더라도 인터페이스 구현체만 변경하면 됨
- Dependency Inverted, 의존성 역전 발생


**What is OO?**
- Dynamic polymorphism
	- 인터페이스가 요구하는 무엇인가 전달하면 내가 원하는 대로 잘 동작할거다
- OO는 메시지를 전달하는 것📬
	- 어떻게 동작하는지 모르고
	- 무엇을 원하는지를 전달하는 것
- `Dependency Inversion`이 OO의 정수
- OO는 실세계를 똑같이 모델링 하는 것이다 
	- Inheritance(상속), Encapsulation(캡슐화), Polymorphism(다형성)
	- 이것은 OO의 핵심이 아니라 메커니즘
- OO의 핵심은
	- **IoC를 통해 상위 레벨의 모듈을 하위 레벨의 모듈로부터 보호하는 것** ✨
	- Inverted structure tends not to rot
- OOD
	- Dependency Management
	- `Inversion of key dependencies that isolate the high level policies from low level details`

> Dependency Management, 의존성 관리를 위해 중요한 규칙이 **SOLID**이다


## 13. SRP(Single Responsibility Principle)

> Actor가 포인트

- 클래스는 하나의 책임을 가져야 한다
- 책임은 무엇인가? 
	- **부류**로 구분
		- 메소드의 Client에 의해 결정
		- 누가 해당 메소드의 변경을 유발하는 **사용자**인가 ✅
			- 이런걸로 메소드를 **그룹핑** 할 수 있다

**It's About Users** 
- SRP는 사용자(Actor)에 관한 것이다 
- 책임 
	- `변경의 근원`으로 볼 수 있다
	- SW의 변경을 요청하는 특정 사용자들에 대해 클래스/함수가 갖는 것
- 예제. Employee 클래스의 변경을 요구하는 사용자들
	- Actor: 서로 다른 Needs, Expectation(기대치)을 가짐
	- 3개의 액터가 있다
		- Policy, Architect, Operations 
- User들은 그들이 수행하는 Role에 따라 나뉨
- User가 특정 Role을 수행할 때 Actor라고 부른다
	- 책임은 개인이 아니라 액터와 연결 


> [!note] Responsibility (책임) 
> - 특정 액터의 요구사항을 만족시키기 위한 일련의 함수의 집합
> - Actor의 요구사항 변경이 일련의 함수들의 변경의 근원이 된다


**SW의 두가지 가치**
- Primary and Secondary Value로 구분 
- 보통 Secondary Value를 중요하게 생각한다 
	- `Secondary Value of SW is it's behavior`
	- 현재의 SW가 현재 사용자의 요구사항을 만족하는가?
- 실제로 중요한건 Primary Value of SW 이다
	- 지속적으로 변화하는 요구사항을 수용(tolerate, facilitate)하는 것 
	- 대부분의 SW의 경우 현재의 요구사항을 잘 만족하지만 변경하긴 어렵다

**Collision**(충돌)
- Primary Value 저하
- Actor들의 요구사항에 따라 의존하고 있는 동일 모듈의 변경이 발생 
	- Merge 충돌, Source Repo 충돌이라고도 표현

**Fan Out 문제**
- 하나의 클래스가 너무 많은 책임을 가짐
- Empolyee 클래스에 거대한 Fan Out이 존재 (예제. 클래스 다이어그램 )
	- 변경에 민감
- Fan Out은 제한하는 것이 좋다 
	- **좋은 방법은 책임을 최소화하는 것이다**✨

**Collocation is Coupling**
- Operations Actor 가 새로운 리포트 기능을 필요로 할 때
	- 새로운 리포트 기능도 Employee 클래스에 추가한다 
	- 기존 책임(Policy, Architecure = 클라이언트, 액터)에는 변경이 없음에도 새로운 리포트가 추가되어 Employee 클래스가 변경된다
	- 새로운 리포트 기능이 Employee 클래스에 추가되면 이 기능을 필요로 하지 않는 Employee 클래스를 사용하는 모든 클래스들이 다시 컴파일/배포되어야 한다
	- 결과적으로 모든 액터들이 영향을 받게 된다 (리포트 기능만 추가했는데 .. )
- `Collocation of responsibilities coules the actors`

**SRP**
- 하나의 모듈은 반드시 하나의 변경 사유를 가져야 한다
- `하나의 모듈은 하나의 클라이언트, 액터에게만 서빙해야 한다`
- `One and only one responsibility`
	- 동일한 이유로 변경되어야 하는 것들은 동일 모듈에
	- 다른 이유로 변경되어야 하는 것들은 다른 모듈에

**SRP는 시스템 설계할 때 식별하기 좋다**
- Actor 파악에 주의해야 함 
- Actor 들은 serve하는 책임들을 식별 
- 책임을 모듈에 할당 
	- 각 모듈이 반드시 하나의 책임을 갖도록 유지
- 분리의 이유
	- 다른 이유로 인해 변경되고, 다른 시점에 변경되기 때문


> **해결책**
> 1. 인터페이스를 하나 빼서 Inverted Dependencise 한다. (가장 간단)
> 2. Extract Classes 하여 3개로 분리 
>    ➡️ 이때 문제점은 Empolyee 개념이 3개의 조각으로 분리됨 (복잡도 상승)
> 
> `1,2` 두 해결책을 합쳐서 사용할 수도 있다
> 
> 3. Facade : 어디에 구현되었는지 찾기 쉽다, 단점은 Actor들이 여전히 하나의 클래스에 의존
> 4. Interface Segregation (이게 제일 좋지만 복잡도 상승)
>    장점: Actor들은 완전히 decoupled
>    단점: 어디에 구현되었는지 찾기 어렵다, 하나의 클래스에 구현되어 구현은 coupled
>    
> 정답은 없다. 상황에 맞는 최선의 선택을 반복할 뿐 👍


**Case Study - Architecture**
- 각 패키지는 각 액터들을 위한 책임을 구현 
- 패키지 간의 의존성 방향에 주의 
- 이 설계는 좋은 아키텍처이다 (게임 관련 예제인데, 클래스/패키지 다이어그램으로만 설명)
- 각 클래스/패키지는 하나의 액터만을 위한 기능을 제공
	- 패키지는 집합인 듯하다

**실제로 한 것(설명만)**
- 제일 먼저 테스트를 작성하고 통과하도록 함
- 스코어를 계산하는 동작 함수를 하나 만듦
- 추측하는 로직을 위한 동작 함수를 만듦
- 설계가 드러날 때까지 함수를 리팩터링한다 
- 동작하는 전체 게임을 얻을때까지 모든 동작들이 테스트에 성공하도록 설계를 적용
- 그리고 아키텍처를 살폈다. 
	- 테스트가 당신들에게 보여준 설계의 80%를 유도했다
- 그리고 테스트가 3개의 책임을 식별하는 것을 도왔다
- Unit Test가 확보된 후에 무차별적인 리팩터링을 수행한다
	- 디자인을 향상시키기 위해서
- 이런 후에만 3개의 액터들이 식별된다 ✨
	- 그러면 클래스들을 3개의 패키지로 분리시킨다
- 마지막으로 이쁜 다이어그램들을 그린다
	- 이쁜 다이어그램을 그리기 가장 좋은 때는 완료된 후이다
		- 처음에는 화이트보드에 가볍게 브레인 스토밍을 하고 지운다


## 14.1 OCP(Open-Closed Principle)

> OCP에 대해 설명하면서 현실적인 설계 방법에 대해 점진적으로 설명한다

- 확장에는 열려있고, 변경에는 열려있다 
	- **확장**: 새로운 타입을 추가하여 기능을 추가
- But Closed For modification
	- `High Level Policy shouldnt be modified`
	- 상위 레벨 정책은 변경되면 안된다


**Copy Example**
- Abstraction and Inversion
	- insert abstract interface between copy and device
	- cause the inverted dependencies
- 인터페이스에 의존하고 구현체를 런타임에 유연하게 갈아 끼운다
- 확장이 필요한 행위를 `Abstraction` 한다
	- 디바이스가 추가되면 해당 디바이스를 담당하는 클래스를 추가한다 
	- `open for extension`
- 하지만 copy로직의 수정을 발생하지 않는다 
	- `closed for modification`

> 코드 레벨 예시는 있지만 하지 않음 .
> Copy 클래스에 구현된 메서드를 추상 인터페이스로 추출해서 인자로 주입받아 사용한다 (OCP)


**POS Example**
- 부분 코드 예시 주어짐 
- 현찰을 받는 경우는 잘 동작하지만, 신용카드를 받고자 할 때는 확장을 해야 한다
	- 확장을 위해 소스를 수정하는 것은 OCP 위반💩
	- 해결책은 확장이 필요한 행위를 **Abstraction** 한다

**Is This Possible?**
- OCP를 준수하면 Modification을 완벽하게 제거할 수 있나?
	- 이론적으로 OK이나 But 비실용적이다
- 2가지 문제 있다
	- main partition
	- Crystal ball problem

> A Smelly Desin - 비용 출력 예제가 깃허브에 있다고 함 (`printReport()`)

**De-Orderizing the Design** (직접 해보기✨)
- 원본 예제: https://github.com/unclebob/Episode-10-ExpenseReport
- 강의: https://github.com/msbaek/expense
	- 원본  예제에서 리팩터링 전 코드를 카피한 후 강의 저장소 보면서 리팩터링 수행

**The Lie (거짓말)**
- 고객이 주말(날짜 개념), Transportation 관련된 **새로운 기능을 요구하면 대책이 없다**
- 아무도 이런 얘길 해주지 않아서다. **만일 미리 얘기해 줬다면** 이런 요구사항을 수용할 수 있도록 **Abstraction을 적용했을 것**이다.
- 내가 **알았더라면 OCP를 준수하도록 했을텐데**. 새로운 기능을 수정없이 확장할 수 있도록 설계 했을 것이란 말이다. `내가 미리 알았더라면 말이다`
- 그럼 **OCP는 앞으로 어떤 확장이 필요할 지 알아야만 제대로 할 수 있다는 말인가?**

> [!note] 고객은 자기가 만져보기 전에 자기가 원하는게 무엇인지 모른다 (fact)

- 당신이 아무리 잘 찾고, 잘 예측해도 고객은 **반드시 당신이 준비하지 못한 것에 대한 기능 추가/변경을 요구**한다. (`Unknown Unknowns`)
- 미래의 변경으로부터 보호 받도록 Abstraction을 적용하여 설계하는 것은 쉽다. 만일 미래에 어떤 변경이 있을지 알 수 있다면 말이다. 하지만 우린 그런 미래를 알 수 있는 **Crystal ball**이 없다 (예언하는 구슬)
- 고객은 우리가 놓치고 준비하지 않은 부분에 대해서 변경을 요구하는 능력을 가지고 있다. 😂😂
- 이것이 사람들이 **말하기를 꺼리는 OCP, OOD에 대한 하나의 더러운 비밀**이다
	- **OCP, OOD는 당신이 미래를 예측할 수 있을 때만 해당 기능을 보호할 수 있다.**
- 그럼 어떻게 해야 하나?
	- 지난 30년간 SW 산업은 이 문제와 투쟁해 왔다
	- 이러한 노력의 일환으로 **Crystal Ball의 필요성을 제거하기 위한 2가지 주요한 접근법을 식별**했다.


**방법1. Big Design Up Front(BDUF)**
- 미리 최대한의 설계를 한다 
- 조심스럽게 고객과 문제 영역을 고찰한다 
- 고객의 요구사항을 **예측하여** 도메인 모델을 만든다
- OCP가 가능하도록 도메인 모델에 추상화를 적용한다
- 변경될 가능성이 있는 모든 것들에 대한 청사진을 얻을 때까지 헛된 짓을 계속한다 
- 문제 💣
	- 대부분의 경우 필요치 않은 추상화로 도배된 매우 크고, 무겁고 복잡한 쓰레기 설계를 만든다
	- 추상화는 유용하고 강력한 만큼 비용도 크다



> 이 방법의 단점은 구체화가 되가면 고객의 요구사항이 변경이 일어나게 되고, 그럼 추상화, 설계는 쓸모없어짐 🤔


**방법2. Agile Design** (✨현실적 방법, 좋은듯)
- 실용적이고, 반응을 하는 방법
- 가장 좋은 예시법은 `은유법(메타포)`이다
- 은유법
	- 일련의 병사들이 적군의 사격에 포위됐다 
	- 총탄이 난발하고 있는 가운데 참호에 숨어있다
	- 적을 향해 집중 사격할 수 있으면 전투에서 승리한다 
	- 문제는 어디에 적이 있는지 모른다는 것이다 
	- 어떤 방향에서 적들이 총을 쏘는지 모른다. 만일 일어나서 방향을 살펴보려고 한다면 적을 찾고 겨냥하지 전에 총에 맞을 것이다.
	- How? Agile Design
		- 그래서 상사가 실행 가능한 결정을 내린다 
		- "존슨 일어나". 탕탕탕 이제 총알이 날아온 방향을 안다 
- Agile Design은 이런 것이다 
- **최대한 빨리 고객의 요구사항을 끌어낼 수 있는 가장 단순한 일을 한다**
- 그럼 **고객은 그 결과물에 대해 요구사항 변경(사격)을 시작**한다
- 그럼 **어떤 변경이 요구되는지 알게 된다.**

> 변경을 예상, 준비하지 말고

- **변화에 대한 가장 좋은 예측은 변화를 경험하는 것**
- 발생할 것 같은 변화를 발견한다면 향후 해당 변화와 같은 종류의 변화로부터 코드를 보호할 수 있다
- 고객이 요구할 **모든 종류의 변경을 완벽하게 예측**하고, 이에 대한 변경에 대응하기 위해 Abstraction을 적용하는 대신
- 고객이 **변경을 요구할 때까지 기다리고** Abstraction을 만들어서 향후 추가적으로 재발하는 변화로부터 보호될 수 있도록 하라.
- Agile Designer는 **주단위 정도로 간단한 뭔가를 Deliver한다**
- 고객이 변경을 요구하면 Agile Designer는 코드를 **리팩터링**해서 그런 종류의 변경을 쉽게 할 수 있도록 Abstraction을 추가한다. OCP를 준수하도록


**Agile Design in Practice**
- 물론 우리는 실제로 BDUF와 Agile 두 극단 사이에 살고 있다
	- **BDUF를 피해야 하지만 No DUF도 피해야 한다**
- 시스템에 대해서 사고하고 Decoupled 모델을 **사전 설계** 하는 것은 가치있는 일이다.
- 하지만 **간단하고 적은 면**에 있다
- 우리의 목적은 시스템의 **기본 모양을 수립**하는 것이지 모든 **작은 상세**까지 수립하는 것은 아니다👍
	- 러프하게
- 문제에 대해서 과하게 생각하면 유지보수 비용이 높은 많은 **불필요한 추상화**를 만들게 된다
- 가장 좋은 것은 
	- **빨리 자주 Delivery**하고, **고객의 요구사항 변화에 기반하여 리팩터링** 하는 것이 매우 가치있다
	- 이럴때 **OCP가 진가**를 발휘한다 ✅
	- 하지만 **간단한 도메인 모델없이 이렇게 진행하면 방향성 없는 혼란한 구조**를 유발한다

**Example**
- 팀 관련해서 어떻게 적용할지 .. (필요시 찾아보자)


**Reprise**
- 마술이 아니라 공학이다 
- OCP을 완벽하게 준수하는 것은 불가능하다. 모든 것을 생각해 낼 수는 없다
- 아무리 철저히 규칙을 준수하고 조심해도 결국 고객은 시스템 전반에 걸친 대대적인 수정이 필요한 변경을 생각해 낼 것이다 😂 (기가 막힌 기능 보유)
- 당신의 목적은 **변경의 고통을 완전히 제거하는 것**이 아니다. 
- 이것은 불가능하다
- 당신의 목적은 **변경을 최소화하는 것**이다
- 이게 **OCP를 준수하는 디자인**이 당신에게 주는 이점이다
- OCP는 시스템 아키텍처의 핵심이다
- 완벽한 보호(변경으로부터의)를 얻을 수는 없지만, 얻기 위해 투쟁할 필요는 있다

**Appendix**
- [Is Design Dead? - 마틴 파울러](https://www.martinfowler.com/articles/designDead.html)


## 14.2 LSP (Liskov Substitution Principle)
> 강의 시간 약 7분

**OCP vs LSP**
- OCP는 
	- abstraction, polymorphism(inheritance)를 이용해서 구현
- LSP는 
	- OCP를 받쳐주는 polymorphism에 관한 원칙을 제공
	- LSP가 위반되면 OCP도 위반됨
	- LSP를 위반하면 subtype이 추가될 때마다 클라이언트들이 수정되어야 함
	- `instanceof / downcasting`을 사용하는 것은 전형적인 LSP 위반의 징조 💩


**Rectangle 예제**
- `Square`(정사각형, subtype)에서 LSP 위반 설명

**The Representative Rule**
- 대리인은 자신이 대리하는 어떤 것들에 대한 관계까지 대리(공유)하지는 않는다
- 이혼 소송 변호사들(대리인)이 이혼하는 부부들의 관계(부부)를 대리(공유)하지 않는 것 처럼
- 따라서 기하학에 따르면 Square Is-A Rectangle 이지만 
- 이들을 표현/대리(represent)하는 SW는 그들의 관계 (IS-A)를 공휴하지 않는다

## 14.3 ISP (Interface Segregation Principle)
> 강의 시간 약 7분

**Interface Segregation Principle**
- `Don't depend on things that you don't need`
	- **클라이언트 입장에서 인터페이스를 분리하라는 원칙**
- 사용하지 않지만 의존성을 가지고 있다면
	- 그 인터페이스가 변경되면 재컴파일/빌드/배포되야 한다
	- 독립적인 개발/배포가 불가하다는 의미
- SPR와도 연관
	- 한 기능에 변경이 발생하면 다른 기능을 사용하는 클라이언트들에도 영향을 미침
- **사용하는 기능만 제공하도록 인터페이스를 분리함으로써 한 기능에 대한 변경의 여파를 최소화**함

**Switch 예제** 
- 클래스 다이어그램 기반 설명하여 생략 

**Fat class 예제**
- 마찬가지로 클래스 다이어그램 기반 설명
- 하나의 클래스에 클라이언트가 여러명
- 제일 쉬운 해결책 
	- `One Interface for a sub system`
		- 새로운 인터페이스를 보도록 수정이 크지만, Job의 변경 영향 전파가 최소화됨
	- Fat class를 만난다면 
		- Interface를 생성하여 Fat class를 클라이언트로부터 isolate 시켜야함
		- Fat class에서 다수의 Interface를 구현
		- Interface는 구현체보다는 클라이언트와 논리적으로 결합되므로 클라이언트가 호출하는 메소드만 Interface에 정의되었다는 것을 확신할 수 있음 
		- 결과적으로 **ISP 준수**


## 15.1 DIP (Dependency Inversion Principle)

> 예제 코드는 없다. 대부분 클래스 다이어그램 위주

**Dependency Inversion Principle**
- `High Level Policy should not depend on Low Level Details`
- 구현체(저수준 모듈, 구현체)는 Abstract Type(고수준 모듈, 인터페이스/추상 클래스)에 의존해야 한다

**OO의 핵심**✨
- Inheritance(상속), Encapsulation(캡슐화), Polymorphism(다형성)
	- 이것은 OO의 핵심이 아니라 메커니즘
- OO의 핵심은
	- **IoC를 통해 상위 레벨의 모듈을 하위 레벨의 모듈로부터 보호하는 것** ✨
	- Inverted structure tends not to rot
	- ex. OCP를 통해 새로운 타입(요구사항)을 반영할 수 있음

**Structured Design(구조적 디자인)**
- Top-down 방법론
	- `소스 코드 의존성의 방향 = 런타임 의존성의 방향`
	- 위에서 아래로 ➡️ 굉장히 위험해짐💣

**Plugins 아키텍처**
- Boundary를 Plugin Interface로 다룬다.
- 의존성 역전이 SW 모듈간의 경계를 만드는 수단이 된다
	- 호출자가 어떤 것이 호출될지 모른채 호출하는 모듈을 `plugin`이라 함
	- plugin도 구현체이고, 클라이언트와 plugin 둘 다 인터페이스 의존
- `Main should be a plugin to the rest of the applications`
	- Main 파티션 :  플러그인 영역 (ex. 스프링에서 App 파티션에 의존성 주입)
	- App 파티션 : 사용자 정의 영역

> 재사용 가능한 프레임워크 (A Reusable Framework)


**The Furnace Example(용광로 예제)**
- DIP 위반 
	- 알고리즘이 low level detail에 의존 
- `HVAC`인터페이스를 중앙에 만들어서 필요한 함수를 재정의 
	- 의존성 방향이 인터페이스로 향함


## 15.2 SOLID Case Study

**Requirements and Use Cases**
- 요구사항을 분석하면서 Use Case/Entity List 작성
- Use Case List
	- AddEmployee
	- DeleteEmployee
	- ChangeEmployee
	- AddTimeCard
	- PayEmployees
	- AddSalesReceipt
- Entity(Data Element) List
	- Employee
		- CommissionedEmployee
		- HourlyEmployee
	- TimeCard
	- SalesReceipt


> Data Entity들은 내부에 데이터를 갖는다

> [!note] use case가 복잡해지는 것은 데이터가 변경되기 때문이다. (오퍼레이션이 변해서가 아님)

**SRP 시작**
- 누가 어플리케이션의 액터인가? 그들의 관심사는 ?
- Operations
	- 시스템을 운영 UI를 통해 Use Case를 사용
- Payroll (`Use Case`)
	- AddEmployee
	- DeleteEmployee
	- ChangeEmployee
	- AddTimeCard
	- PayEmployees
	- AddSalesReceipt
- Union (`Actor`)
	- 어떻게 조합비를 부과하나 조합비를 언제 공제하나 조합 회원에 관련된 모든 이슈
- Policy (`Actor`)
	- 직원이 얼마를 수령하나, 언제 수령하나
- 이 단계의 목적은 
	- **모듈들을 분리하는 것**
	- 각 **모듈은 반드시 하나의 액터만** 담당해야 한다
- 어려운 문제 
	- operations는 사용하는 UI를 가지고 
	- 여러 액터들과 연관된 데이터가 존재 
- Use Case들을 분해해서 SRP를 준수하는 모듈로 isolate

**AddEmployee Use Case**
- 다이어그램 기반 설명
- 이해가 잘 안됨.. 액터..

**Diagrams and YAGNI**
- 다이어그램 작성은 시간 낭비 
- 작성하는 이유
	- 생각하는 프로세스를 설명하기 위해서
	- 생각하는 프로세스의 상세함을 다른이들에게 전달할 때
- 큰 규모의 프로젝트를 팀원들과 수행한다면
	- 일련의 다이어그램을 화이트보드에 그릴 것
- 다이어그램을 상세하게 작성하는 것이 후에 다른 사람들이 시스템을 이해하는데 도움이 되지 않을까?
	- **지속적으로 갱신할 때만 의미를 가짐** 
	- 설계 단계에서는 적당히 하고 ㅋㅋ

**SRP의 의미** 
- 한 Module이 하나의 Actor를 위한 Responsibility를 갖도록 분리하는 설계를 한다는 의미
	- Architectural Framework를 만든 것
- `늘 Actor를 찾고 이에 기반하여 Module을 분리`한다

**OCP**
- 이미지에서 Controller가 DS(데이터 구조)를 UC(유즈 케이스)로 넘긴다
- DS와 UC의 detail에 의존성을 갖는다
- DS나 UC의 변화가 생기면 Controller도 재배포해야 함 💩
- 해결책
	- DS나 UC에서 Controller를 decoupling 
	- 인터페이스를 엄청 뽑아서 의존시키네 
		- 구현체 변경 발생시 컨트롤러에게 변경 전파가 되지 않음
		- 하지만, 코드 복잡도가 늘어나겠지 
		
**LSP**
- AddTimeCardUseCase 기준 설명
	- 메서드 오버라이드해서 OCP 위반을 해소 (TimeCard에 대해서만)
	- 하지만 Salary, Commissioned에서는 아무것도 안하도록 override 하는 것은 LSP 위반
	- Interface에 모든 파생클래스에 적용할 수 없는 메소드를 추가하는 것은 LSP 위반
		- 다른 서브 타입에 구현하지 않을 메소드를 추가한다는 거네👀
	- 코드의 문제 
		- Hourly를 사용할 때 down cast  (???)
		- LSP 준수 위해 down cast를 하는 것이 일반적
		- 주어진 파생클래스가 어떤 타입인지 정확히 안다면 down cast로 인한 피해는 없다

**ISP**
- 해결책1.
	- Dynamic interface
	- 파라미터명으로 처리하다보니 type 정보 유실
- 해결책2.
	- 특정 Controller가 사용하는 메소드만을 갖는 많은 Interface를 추가 
	- Type Safe 이슈 해소 

**DIP**
- `High Level policy should be independent of low level detail`
- E18. Component Case Study 
	- 📚 해외 개발 도서를 참고한 듯함
- 복잡해보지만, 변경에 대한 안정성/자유를 제공한다함

---
## 레거시 코드에 테스트 추가를 위한 3가지 기법

> GildRose 예제 사용 ➡️ Lift up conditionals 에도 있음

🔗 [원본 예제 저장소](https://github.com/emilybache/GildedRose-Refactoring-Kata)
- [한글 마크다운](https://github.com/emilybache/GildedRose-Refactoring-Kata/blob/main/GildedRoseRequirements_kr.md)

```java
class GildedRose {
    Item[] items;

    public GildedRose(Item[] items) {
        this.items = items;
    }

    public void updateQuality() {
        for (int i = 0; i < items.length; i++) {
            if (!items[i].name.equals("Aged Brie")
                    && !items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {
                if (items[i].quality > 0) {
                    if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {
                        items[i].quality = items[i].quality - 1;
                    }
                }
            } else {
                if (items[i].quality < 50) {
                    items[i].quality = items[i].quality + 1;

                    if (items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {
                        if (items[i].sellIn < 11) {
                            if (items[i].quality < 50) {
                                items[i].quality = items[i].quality + 1;
                            }
                        }

                        if (items[i].sellIn < 6) {
                            if (items[i].quality < 50) {
                                items[i].quality = items[i].quality + 1;
                            }
                        }
                    }
                }
            }

            if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {
                items[i].sellIn = items[i].sellIn - 1;
            }

            if (items[i].sellIn < 0) {
                if (!items[i].name.equals("Aged Brie")) {
                    if (!items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {
                        if (items[i].quality > 0) {
                            if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {
                                items[i].quality = items[i].quality - 1;
                            }
                        }
                    } else {
                        items[i].quality = items[i].quality - items[i].quality;
                    }
                } else {
                    if (items[i].quality < 50) {
                        items[i].quality = items[i].quality + 1;
                    }
                }
            }
        }
    }
}

```

### Characterization Test
- 수동으로 테스트를 추가하는 기법


### Approval test
- Characterization Test를 다양한 인자의 조합으로 작성을 돕는 라이브러리
- https://approvaltests.com
- 결과의 스냅샷을 만들고, 변경되지 않았음을 검증하여 단위 테스트에서 검증을 단순화함
- 인텔리제이 설정 수정하여 커버리지 테스트 색깔로 옆에 표시되도록 함
- 이 후 의존성 추가 ➡️ 테스트 생성 ➡️ 파일명을 수정해서 다시 테스트

### Mutation test
- 100%의 테스트 커버리지를 갖는 코드도 완전히 버그가 없는 것을 보장하지 못한다
- 고의로 버그를 유발(프로덕션 코드를 약간 수정)하고 테스트가 그 버그를 잡아내는지(실패하는지)를 확인하여 테스트의 완전성을 검증하는 기법
	- 이렇게 프로덕션 코드를 약간 변경하는 테스트를 `돌연변이 테스트(mutation test)`라고 함
	- 100% 커버리지를 갖는 경우도 테스트가 실패하지 않고 성공하는 경우가 있음 
	- 코드를 실행하는 것과 코드를 테스트 하는 것은 동일한 것이 아니어서 **PIT**를 이용해서 수행 
	- **PIT**은 런타임에 프로덕션 코드에 코드를 삽입(자동 생성)하여 돌연변이 테스트를 발생시킴
	- 살아남은 돌연변이 테스트가 있다는 것은 100% 커버리지를 갖는 테스트가 있다고 하더라도 결함(defect)을 완전히 방지하지는 못하는 것을 의미
	- 이런 결함을 유발하는 코드 패스를 갖는 테스트가 없음을 의미
- **의존성**과 **빌드 플러그인**을 추가해야 함
- 빌드 결과물에 보면 `index.html` 생성되서 확인 가능




---
## Refactoring - Lift Up Conditionals

> [!note] Lift Up Conditionals
> 길고 복잡한 조건문을 조작하여 특정 조건과 관련된 코드 블록을 그룹핑하는 기법

🔗 [원본 예제 저장소](https://github.com/emilybache/GildedRose-Refactoring-Kata)
- [한글 마크다운](https://github.com/emilybache/GildedRose-Refactoring-Kata/blob/main/GildedRoseRequirements_kr.md)

```java

class GildedRose {
    Item[] items;

    public GildedRose(Item[] items) {
        this.items = items;
    }

    public void updateQuality() {
        for (int i = 0; i < items.length; i++) {
            if (!items[i].name.equals("Aged Brie")
                    && !items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {
                if (items[i].quality > 0) {
                    if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {
                        items[i].quality = items[i].quality - 1;
                    }
                }
            } else {
                if (items[i].quality < 50) {
                    items[i].quality = items[i].quality + 1;

                    if (items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {
                        if (items[i].sellIn < 11) {
                            if (items[i].quality < 50) {
                                items[i].quality = items[i].quality + 1;
                            }
                        }

                        if (items[i].sellIn < 6) {
                            if (items[i].quality < 50) {
                                items[i].quality = items[i].quality + 1;
                            }
                        }
                    }
                }
            }

            if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {
                items[i].sellIn = items[i].sellIn - 1;
            }

            if (items[i].sellIn < 0) {
                if (!items[i].name.equals("Aged Brie")) {
                    if (!items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {
                        if (items[i].quality > 0) {
                            if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {
                                items[i].quality = items[i].quality - 1;
                            }
                        }
                    } else {
                        items[i].quality = items[i].quality - items[i].quality;
                    }
                } else {
                    if (items[i].quality < 50) {
                        items[i].quality = items[i].quality + 1;
                    }
                }
            }
        }
    }
}

```

- `alt + enter` 단축키 잘 활용하기
- 메소드 추출을 2번 해서 조건문으로 감싼 다음 인라인해서 중복 불필요한 조건을 처리해간다
- 스위치문을 다형성을 만들 때 
	- `push down members`로 사용해서 메서드를 하위 자식 클래스에 모두 복사 내림



## Refactoring - Split Phase
> 리팩터링 예제를 사용 
- [리팩터링.com](https://refactoring.com/catalog/splitPhase.html)
	- `6.11 Split Phase`

예제 코드 없어서 직접 타이핑
```java
record Product(double basePrice, double discountThreshold, double discountRate) {}  
  
record ShippingMethod(double discountThreshold, double discountedFee, Double feePerCase) {}  
  
public class Orders {  
    double priceOrder(Product product, int quantity, ShippingMethod shippingMethod) {  
        double basePrice = product.basePrice() * quantity;  
        double discount = Math.max(quantity - product.discountThreshold(), 0)  
                * product.basePrice() * product.discountRate();  
        double shippingPerCase = (basePrice > shippingMethod.discountThreshold())  
                ? shippingMethod.discountedFee() : shippingMethod.feePerCase();  
        double shippingCost = quantity * shippingPerCase;  
        double price = basePrice - discount * shippingCost;  
        return price;  
    }}

```
- shift 두번 누른 후 change signature로 중간 구조체 PricingData를 메서드 파라미터로 추가
- PricingData (중간 데이터 객체)에 이전 메서드에서 생성하거나 전달하는 파라미터를 넣어 전달

**리팩터링 후**
```java
record Product(double basePrice, double discountThreshold, double discountRate) {}  
  
record ShippingMethod(double discountThreshold, double discountedFee, Double feePerCase) {}  
  
record PricingData(double basePrice, double discount, int quantity) {}  
  
public class Orders {  
    double priceOrder(Product product, int quantity, ShippingMethod shippingMethod) {  
        PricingData pricingData = calculatePricingData(product, quantity);  
        return applyShippingCost(shippingMethod, pricingData);  
    }  
    private static PricingData calculatePricingData(Product product, int quantity) {  
        double basePrice = product.basePrice() * quantity;  
        double discount = Math.max(quantity - product.discountThreshold(), 0)  
                * product.basePrice() * product.discountRate();  
  
        return new PricingData(basePrice, discount, quantity);  
    }  
    private static double applyShippingCost(ShippingMethod shippingMethod, PricingData pricingData) {  
        double shippingPerCase = (pricingData.basePrice() > shippingMethod.discountThreshold())  
                ? shippingMethod.discountedFee() : shippingMethod.feePerCase();  
        double shippingCost = pricingData.quantity() * shippingPerCase;  
        return pricingData.basePrice() - pricingData.discount() * shippingCost;  
    }}

```


리팩터링 6.11 Split Phase
```java
public class App {  
    public static void main(String[] args) {  
        try {  
            if(args.length == 0) throw new RuntimeException("파일명을 입력하세요");  
  
            String fileName = args[args.length - 1];  
            File input = Paths.get(fileName).toFile();  
            ObjectMapper mapper = new ObjectMapper();  
            Order[] orders = mapper.readValue(input, Order[].class);  
            if(Stream.of(args).anyMatch(arg -> "-r".equals(arg))) {  
                System.out.println(Stream.of(orders)  
                        .filter(o -> "ready".equals(o.status()))  
                        .count()  
                );            } else {  
                System.out.println(orders.length);  
            }        } catch (Exception e) {  
            System.err.println(e.getMessage());  
        }    }}
```
- CommandLine 중간 구조체를 만드는게 포인트

**리팩터링 후**
```java
public class App {  
    public static void main(String[] args) {  
        try {  
            System.out.println(run(args));  
        } catch (Exception e) {  
            System.err.println(e.getMessage());  
        }    }  
    record CommandLine(String fileName, boolean onlyCountReady) {}  
  
    private static long run(String[] args) throws IOException {  
        CommandLine commandLine = parseCommandLine(args);  
        return countOrder(args, commandLine);  
    }  
    private static CommandLine parseCommandLine(String[] args) {  
        if(args.length == 0) throw new RuntimeException("파일명을 입력하세요");  
  
        String fileName = args[args.length - 1];  
        boolean onlyCountReady = Stream.of(args).anyMatch(arg -> "-r".equals(arg));  
        return new CommandLine(fileName, onlyCountReady);  
    }  
    private static long countOrder(String[] args, CommandLine commandLine) throws IOException {  
        File input = Paths.get(commandLine.fileName).toFile();  
        ObjectMapper mapper = new ObjectMapper();  
        Order[] orders = mapper.readValue(input, Order[].class);  
        if(commandLine.onlyCountReady()) {  
            return Stream.of(orders)  
                    .filter(o -> "ready".equals(o.status()))  
                    .count();  
        } else {  
            return orders.length;  
        }    }}
```

## 레거시 코드에 테스트 추가하는 또 하나의 방법- Subclass and Override Method 

🔗 [강의 자료](https://github.com/msbaek/refactoring-tools/blob/master/src/main/java/com/example/refactorings/splitphase/AuditManager.java)

**리팩터링 전**
```java
  
class Directory {  
    public static String[] getFiles(String directoryName) {  
        throw new IllegalStateException("Directory#getFiles is not implemented yet");  
    }}  
  
class Sorted {  
    public final int index;  
    public final String path;  
  
    Sorted(int index, String path) {  
        this.index = index;  
        this.path = path;  
    }}  
  
class File {  
    public static void writeAllText(String newFile, String newRecord) {  
        throw new IllegalStateException("File#writeAllText is not implemented yet");  
    }  
    public static String [] readAllLines(String currentFilePath) {  
        throw new IllegalStateException("File#readAllLines is not implemented yet");  
    }}  
  
class Path {  
    public static String combine(String directoryName, String fileName) {  
        return directoryName + java.io.File.pathSeparator + fileName;  
    }}  
  
public class AuditManager {  
    private final int maxEntriesPerFile;  
    private final String directoryName;  
  
    public AuditManager(int maxEntriesPerFile, String directoryName) {  
        this.maxEntriesPerFile = maxEntriesPerFile;  
        this.directoryName = directoryName;  
    }  
    public void addRecord(String visitorName, LocalDateTime timeOfVisit) {  
        String[] filePaths = Directory.getFiles(directoryName);  
        Sorted[] sorted = sortByIndex(filePaths);  
  
        String newRecord = visitorName + ';' + timeOfVisit;  
  
        if (sorted.length == 0) {  
            String newFile = Path.combine(directoryName, "audit_1.txt");  
            File.writeAllText(newFile, newRecord);  
            return;  
        }  
        int currentFileIndex = sorted[sorted.length - 1].index;  
        String currentFilePath = sorted[sorted.length - 1].path;  
        List<String> lines = new ArrayList<>(Arrays.asList(File.readAllLines(currentFilePath)));  
  
        if (lines.size() < maxEntriesPerFile) {  
            lines.add(newRecord);  
            String newContent = String.join("\n", lines);  
            File.writeAllText(currentFilePath, newContent);  
        } else {  
            int newIndex = currentFileIndex + 1;  
            String newName = "audit_" + newIndex + ".txt";  
            String newFile = Path.combine(directoryName, newName);  
            File.writeAllText(newFile, newRecord);  
        }    }  
    private Sorted[] sortByIndex(String[] filePaths) {  
        final Integer[] idx = {0};  
        return Arrays.stream(filePaths)  
                .map(s -> new Sorted(idx[0]++, s))  
                .toArray(Sorted[]::new);  
    }}
```
- 과거 이력에서 찾음
- 처음부터 테스트 작성함
- File 시스템과 같은 외부 의존성은 테스트 하기 힘드니깐 메소드 추출 후 아래와 같이 오버라이딩해서 테스트하는 방법이 있음 
	- 이것보다 인터페이스로 추출하는게 좀 더 나은 방식이라 함

```java
class AuditManagerTest {  
  class TestAuditManager extends AuditManager {  
      private String[] files;  
      private String[] lines;  
      private String record;  
      private String filePath;  
  
      public TestAuditManager(int maxEntriesPerFile, String directoryName) {  
          super(maxEntriesPerFile, directoryName);  
      }  
      @Override  
      protected String[] getFiles() {  
          return this.files;  
      }  
      @Override  
      protected String[] readAllLines(String currentFilePath) {  
          return this.lines;  
      }  
      @Override  
      protected void writeAllText(String filePath, String record) {  
          this.filePath = filePath;  
          this.record = record;  
      }  }  
  
  @Test  
  void addRecordWithNormalCase() {  
      String directoryName = "audits";  
      String[] files = {  
              directoryName + "\\audit_1.txt",  
              directoryName + "\\audit_2.txt"  
      };  
      String[] lines = {  
              "Peter; 2019-04-06T16:30:00",  
              "Jane; 2019-04-06T16:40:00",  
              "Jack; 2019-04-06T17:00:00"  
      };  
      LocalDateTime dateTime = LocalDateTime.of(2022, 3, 25, 14, 0);  
      String visitorName = "Alice";  
  
      TestAuditManager auditManager = new TestAuditManager(3, directoryName);  
      auditManager.files = files;  
      auditManager.lines = lines; // given (stubbing)  
  
      auditManager.addRecord(visitorName, dateTime);  
  
      // characterize test  
      assertThat(auditManager.record).isEqualTo(visitorName + ";" + dateTime.toString());  
      assertThat(auditManager.filePath).isEqualTo("audits:audit_2.txt");  
  }}
```


## Repeated Switched를 Polymorphic하게 리팩터링 하기

> 리팩터링 2판 예제를 사용
> 단축키와 인텔리제이에서 지원하는 리팩터링 기능을 연습하기 좋다
> shift + shift, alt + enter, alt + shift + 7 (사용 위치 찾기)

🔗 [예제 저장소](https://github.com/msbaek/refactoring-cases)
🔗 [Parrot 클래스](https://github.com/msbaek/refactoring-cases/blob/parrot/src/main/java/pe/msbaek/rfcases/repeating_switch/Parrot.java)
🔗 [강의에서 언급한 사이트](https://sammancoaching.org/code_smells/repeated_switches.html)

**리팩터링 전**
```java
public class Parrot {  
    private final ParrotTypeEnum type;  
    private final int numberOfCoconuts;  
    private final double voltage;  
    private final boolean isNailed;  
  
    public Parrot(ParrotTypeEnum type, int numberOfCoconuts, double voltage, boolean isNailed) {  
        this.type = type;  
        this.numberOfCoconuts = numberOfCoconuts;  
        this.voltage = voltage;  
        this.isNailed = isNailed;  
    }  
    
    public double getSpeed() {  
        return switch (type) {  
            case EUROPEAN -> getBaseSpeed();  
            case AFRICAN -> Math.max(0, getBaseSpeed() - getLoadFactor() * numberOfCoconuts);  
            case NORWEGIAN_BLUE -> (isNailed) ? 0 : getBaseSpeed(voltage);  
        };    
	}  
        
    private double getBaseSpeed(double voltage) {  
        return Math.min(24.0, voltage * getBaseSpeed());  
    }  
    
    private double getLoadFactor() {  
        return 9.0;  
    }  
    
    private double getBaseSpeed() {  
        return 12.0;  
    }  
    
    public String getCry() {  
        return switch (type) {  
            case EUROPEAN -> "Sqoork!";  
            case AFRICAN -> "Sqaark!";  
            case NORWEGIAN_BLUE -> voltage > 0 ? "Bzzzzzz" : "...";  
        };    
	}
}
```
- shift 두 번 눌러서 `Replace constructor with factory method` 생성 하는걸로 시작
- 점진적으로 리팩터링 하는 과정이 인상적이다
- 서브 클래스 생성 후 타입이 필요한 메서드는 `push member down`입력하여 서브 클래스 전체에 복사 붙여넣기 한다
	- 이때 접근제어자가 private인 경우 서브 클래스에서 접근 못하니 protected로 리팩터링함
- 타입별로 불필요한 부분을 제거한다 
	- switch에 타입을 지정하면 인텔리제이가 도달할 수 없는 브랜치를 삭제해준다
		- `remove unreachable branch`
- Parrot 추상 클래스에서 `numberOfCoconuts`, `voltage` , `isNailed`멤버의 사용처를 확인 
	- `alt + shift + 7`
	- `push member down` 통해 사용하는 서브 클래스로 이동
	- 그리고 서브 클래스에서 사용하지 않으면 제거

```java
public enum ParrotTypeEnum {  
    EUROPEAN,  
    AFRICAN,  
    NORWEGIAN_BLUE  
}
```


**리팩터링 후**
```java
public abstract class Parrot {  
    protected final ParrotTypeEnum type;  
  
    protected Parrot(ParrotTypeEnum type) {  
        this.type = type;  
    }  
    public static Parrot of(ParrotTypeEnum type, int numberOfCoconuts, double voltage, boolean isNailed) {  
        return switch (type) {  
            case EUROPEAN -> new EuropeanParrot();  
            case AFRICAN -> new AfricanParrot(numberOfCoconuts);  
            case NORWEGIAN_BLUE -> new NorwegianBlueParrot(voltage, isNailed);  
        };    }  
    protected double getBaseSpeed(double voltage) {  
        return Math.min(24.0, voltage * getBaseSpeed());  
    }  
    protected double getLoadFactor() {  
        return 9.0;  
    }  
    protected double getBaseSpeed() {  
        return 12.0;  
    }  
    public abstract double getSpeed();  
    public abstract String getCry();  
}
```
- 서브 클래스(타입) 3개는 생략 


---

Use Case란 
Actor
OO의 핵심

[Uncle Bob - Clean Coders](https://cleancoders.com/)
- 유료 강의였구나

[ocp 다른 예제](https://github.com/msbaek/practical-refactoring-cases)

[리팩터링 tools 예제](https://github.com/msbaek/refactoring-tools)
- 연습하기 좋을듯하다

[기술블로그](https://junuuu.tistory.com/764)


