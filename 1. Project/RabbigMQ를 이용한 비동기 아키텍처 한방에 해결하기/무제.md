
참고. 
- [AWS - RabbitMQ vs Kafka](https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/)
- [ZDNET korea - 아마존 CTO "이벤트 드리븐 아키텍처로 가라"](https://zdnet.co.kr/view/?no=20221202183934)
- [F-lab. 메시지 브로커와 이벤트 브로커: ..] (https://f-lab.kr/insight/message-broker-event-broker?gad_source=1&gbraid=0AAAAACGgUFeKgrz8-WR_U0x7Zupa8cKrf&gclid=Cj0KCQjw5azABhD1ARIsAA0WFUG1yOOiSHGGC-RXdc5Ua3iev4MphDgtYZGaK4CM969s4oJvMnP0tycaAn9DEALw_wcB)
- [RabbitMQ Tutorials](https://www.rabbitmq.com/tutorials)


Todo.
- RabbitMQ vs Kafka 비교 정리하기
- 주요 용어


## 섹션1. 쉽게 이해하는 RabbitMQ 개요과 비동기 아키텍처

slack에 notification 날린다는데 없네? ㅋㅋㅋ

### 3. RabbitMQ 설치


**도커로 설치** 
```shell
$ docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management
```
- `--rm` : ctrl + c 로 종료할 경우 컨테이너 삭제 됨
- default 로그인 정보 : `guest` / `guest`
	- 최초 계정은 guest이기 때문에 admin 권한을 갖는 다른 계정을 추가해주고 default user 는 삭제 해주는게 보안상 권고
- [도커 허브 - RabbitMQ](https://hub.docker.com/_/rabbitmq)

> RabbitMQ 콘솔 주소
> localhost:15672 

> [!info] F-lab 참조 게시글
> RabbitMQ : 메시지 브로커, 비유하자면 택배 서비스
> Kafka: 이벤트 브로커, 비유하자면 도서관


**Mac 설치**
```text
// brew install 
[https://brew.sh/](https://brew.sh/)

// 설치 전에 brew 업데이트 
brew update 

// rabbitmq 설치 
brew install rabbitmq

// starts a local RabbitMQ node 
brew services start rabbitmq 

// stops the locally running RabbitMQ node 
brew services stop rabbitmq

// 삭제
brew uninstall rabbitmq

// 삭제 후 관련 디렉터리도 삭제 해줘야 함
rm -r /opt/homebrew/etc/rabbitmq 
rm -r /opt/homebrew/var/lib/rabbitmq 
rm -r /opt/homebrew/var/log/rabbitmq
```


**다른 운영체제**
```markdown
// 바이너리나 인스톨러 등을 활용해서 설치 [https://www.rabbitmq.com/docs/download(https://www.rabbitmq.com/docs/download)

// 윈도우의 경우 환경 변수에서 RabbitMQ 실행 bin 폴더를 지정해주면 됨
C:\Program Files\RabbitMQ Server\rabbitmq_server-4.0.3\sbin
```


### 4. AMQP의 이해

> Advanced Message Queing Protocal의 약자
> MQ의 오픈소스에 기반한 표준 프로토콜을 의미


**메세지큐를 사용하는 이유**
- 비동기 처리가 가능한 분야에서는 메세지 큐를 통해 느슨한 결합을 가지고 처리하도록 한다
	- 비동기 메시지를 사용하여 다른 응용프로그램 사이에 데이터를 송수신
- 복잡한 프로세스를 동기로 처리시 병목 현상, 장애전파, 확장성 제한 등의 문제 발생가능
	- 클라이언트에 대한 동기 처리는 병목의 요인으로 비동기로 처리해도 될 영역에 대해서는 큐를 통해 분리해서 처리한다
- 결국 분산환경에서 응용프로그램들을 분리하고 독립적으로 확장하기 위해서 사용, 기능별로 모듈 구성이 용이하다 (**Scalability**)
- 요청에 대한 응답을 기다릴 필요 ❌
	- 각 영역의 역할만 신경쓰면 된다
	- 어플리케이션 레벨에서 분리 할 수 있다
- 데이터를 메모리 대신에 디스크에 저장하여 데이터 유실을 방지(**Reliability**)
	- 즉시 처리하지 않아도 나중에 다시 처리가 가능하다 
	- 메시지 영구 저장, 메시지 확인, 장애 복구 메커니즘을 통해 메시지의 신뢰성을 보장
- **확장성**
	- 여러 노드에 걸쳐 쉽게 확장할 수 있어 높은 가용성 제공
	- 필요에 따라 메시지를 클러스터링하거나 페더레이션(federation) 방식으로 확장할 수 있다
- **유연성**
	- 다양한 exchange 유형과 라우팅 규칙을 지원하여 메시지를 효과적으로 라우팅하고 관리할 수 있다.
	- **광범위한 프로토콜 지원**: 기본적으로 AMQP 사용, STOMP, MQTT, HTTP 등을 포함한 다양한 프로토콜을 지원
	- **풍부한 클라이언트 라이브러리**:  Java, Python, Ruby, .NET 등 다양한 언어로 클라이언트 라이브러리를 제공하여 다양한 애플리케이션에서 사용할 수 있다

<img src="./AMQP1.png"/>

- 여기서 말하는 exchange의 `one-to-one fanout`의 경우 
	- 여러 큐에 메시지를 브로드 캐스트하지만, 각 큐에 연결된 소비자는 한 명이므로 **메시지는 각각의 큐에서 하나의 소비자에게만 전달**되므로 1:1 방식의 메시지 소비를 뜻한다
	- **여러 소비자에게 동시에 메시지를 전달하되 각 메시지가 단일 소비자에게만 전달되도록 보장하고 싶은 경우를 의미**한다고 보면 된다

**AMQP 특징**
이전에도 상용화된 MQ 제품들이 많았지만, 대부분 플랫폼 종속적이라 서로 다른 이기종간에 메시지를 교환하기 위해 메시지 포맷 컨버전(속도 저하 발생)을 위한 메시지 브릿지를 이용하거나 시스템 자체를 통일시켜야 하는 불편함과 비효율성이 있었다. 즉, **AMQP의 목적**은 서로 다른 시스템 간에 (비용/기술/시간 측면에서)효율적으로 메시지를 교환하기 위한 MQ 프로토콜로 특징은 다음과 같다
- 모든 broker들은 똑같은 방식으로 동작할 것  
- 모든 client들은 똑같은 방식으로 동작할 것 
- 네트워크 상으로 전송되는 명령어 표준화
- 프로그래밍 언어 중립적



**메모.**
exchange 방식은 여러가지 
큐는 버퍼의 역할 (생산자와 소비자 사이)

// 로그를 logback, ELK 활용해서 수집하는 방법도 있고
// 메시지 큐를 활용해서 수집 모듈(소비자)에서 따로 저장하는 방식도 생각할 수 있겠네

### 5. 주요용어와 Exchange의 이해 

**메모.**
가장 눈에 띄는게 consumer가 메세지를 처리한 이후에 ACK를 보내야 한다.
보내지 않는 경우 RabbitMQ에서 메시지를 다시 큐에 넣어 다른 소비자가 처리하도록 할 수 있다
<-> Kafka는 최신 offset 기준으로 조회하고 갱신(?)해주는걸로 알고 있음

Prdocuer -> Exchange로 갈때는 `routing key`가 사용됨
Exchange -> Queue로 갈때는 `binding key`가 사용됨
// 모호하네 ..  키 두 개를 구분 지어라는 건가?

**🤔 그러면 "생산자 모듈에서 두 키를 지정하나요?" 에 대해 (Chat-gpt)**

> ❌ **아니요! 생산자는 `routing key`만 지정합니다.**  
> ✅ **`binding key`는 큐 바인딩 시 서버 또는 인프라 레벨에서 설정합니다.**

- **Producer**:  
    `convertAndSend(exchangeName, routingKey, message)`  
    (👉 routing key만 신경 씀)
    
- **Consumer**:  
    큐와 exchange를 바인딩할 때 **binding key를 지정**




**Routing Model Components**
AMQP의 라우팅 모델은 아래와 같은 3개의 중요한 component로 구성된다
- **Exchange**
	- producer에서 보낸 메시지를 적절한 큐 또는 다른 exchange로 분배하는 라우터의 기능을 함
- **Binding**
	- exchange와 큐와의 관계를 정의한 **일종의 라우팅 테이블**
	- 같은 큐가 여러 개의 exchange에 bind 될 수 도 있고, 하나의 exchange 에 여러 개의 큐가 binding 될 수 있다
- **Queue**
	- 메모리나 디스크에 메시지를 저장하고, consumer에게 전달하는 역할을 함


![[Pasted image 20250426132410.png]]


**RabbitMQ의 주요 용어 정리**
- Producer (생산자)
	- 메시지를 생성하고 RabbitMQ에 전송하는 애플리케이션
	- 특정 Exchange에 메시지를 전송하고 Exchange는 메시지를 라우팅하여 큐에 배치
- Exchange
	- Producer로부터 받은 메시지를 큐에 전달하는 역할 
	- 유형
		- Direct: 특정 라우팅 키와 정확히 일치하는 큐에 메시지를 전송 
		- Fanout: 모든 큐에 메시지를 브로드캐스트 
		- Topic: 라우팅 키 패턴을 기반으로 메시지를 특정 큐에 전달 
		- Headers: 메시지 헤더 속성에 따라 메시지를 라우팅 
	- 메시지가 Exchange로 전송될때, Routing Key가 함께 전달
- Routing Key
	- 메시지를 전송할 때 Producers가 Exchange에 전달하는 키
	- Exchange는 이 Routing Key를 참고하여 어떤 큐에 메시지를 전달할지 결정
- Queue
	- 메시지를 일시적으로 저장하는 버퍼 역할
	- RabbitMQ의 큐는 FIFO 방식으로 동작하며, 메시지가 소비자에게 전달될 때까지 보관
	- 각 큐는 여러 Consumer가 구독(수신)할 수 있으며, 메시지는 큐에 들어온 순서대로 전달
	- 비동기적으로 동작하며, 여러 컨슈머가 동시에 메시지를 소비할 수 있다
		- 단, 하나의 메시지가 여러 소비자에게  중복으로 전달될 수 없음
		- 동일한 메시지를 수신하려면 fanout Exchange 방식으로 동작해야만 함
- Binding
	- exchange와 큐 간의 관계를 정의
	- 바인딩은 메시지를 라우팅할 때 어떤 조건으로 큐에 보낼지 정의하고 이를 위해 binding key가 사용됨 
	- Binding Key와 Routing Key가 일치하면 해당 큐로 메시지가 전달 (패턴 매칭 지원)
- Consumer (소비자)
	- 큐에서 메시지를 가져와 처리하는 애플리케이션
	- RabbitMQ는 여러 소비자에게 메시지를 로드 밸런싱 할 수 있다
	- Consumer는 큐에서 메시지를 받아 처리하면 메시지에 대한 확인(ACK, acknowledgment)을 브로커에 전송함
	- 확인을 보내지 않으면, 브로커는 메시지를 재전송하거나 설정한 다른 Consumer에게 전달할 수 있다
- Message Acknowledgment (메세지 확인)
	- 메시지가 성공적으로 처리되었음을 RabbitMQ에 알리는 과정
	- 만약 소비자가 메시지를 성공적으로 처리하지 못했다면, 메시지를 다시 큐에 넣어 다른 소비자가 처리하도록 할 수 있다


**절차 요약**
```text
1. Producer가 메시지와 Routing Key를 Exchange에 전송
2. Exchange가 Routing Key를 사용해 Binding Key가 일치하는 큐에 메시지를 라우팅
3. Consumer가 큐에서 메시지를 가져와 처리하고, 성공적으로 처리되었음을 acknowledgment로 RabbitMQ에 알림
```


**추가 용어**
- Prefetch Count
	- 소비자가 받을 수 있는 최대 메시지 수 설정
	- 한 번에 많은 양의 메시지를 처리하지 않도록 해 소비자의 성능 최적화
- Virtual Host (가상 호스트)
	- RabbitMQ 서버 내의 논리적인 구획으로, 메시지 큐, 익스체인지, 사용자 권한 등을 구분 
	- 하나의 RabbitMQ 서버 내에 여러 개의 가상 호스트를 설정하여 서로 다른 애플리케이션의 메시지를 격리 할 수 있다
- Dead Letter Queue (DLQ)
	- 메시지가 처리되지 못하거나 유효 기간이 지난 경우 별도의 큐로 이동하는 구조도 설정할 수 있다

**Exchange 유형에 따른 처리**
- 1. Direct Exchange
	- 메시지가 routing key에 따라 특정 큐로 하나씩 전달되는 방식
	- 메시지 발행시 사용하는 라우팅 키와 동일한 키로 익스체인지에 바인딩 된 모든 큐에 메시지를 전달
	- 해당 라우팅 키와 일치하는 큐에만 메시지가 전달되는 방식이기 때문에 Direct Exchange 라고 함
	- 예시. 주문에 따른 상태 지시
		- 활용: 주문 상태별로 **라우팅 키**를 정의, 각 상태에 해당하는 큐가 메시지를 받는다. 매핑이 정확하게 되는 한 개의 키만 있으니깐 1:1로 가능할 거 같은데, **하나의 라우팅 키**에 대해 **여러 큐**가 바인딩 될 수 있기 때문에 **1:N** 매칭이 가능하다.
			- 메시지가 명확하게 특정 큐로 전달되어야 할 때
			- 큐마다 고유한 라우팅 규칙을 적용하여 메시지를 분류해야 할 때
	- **예시 업무**: 주문 상태 처리, 결제 처리, 사용자 알림 시스템 등
- 2. Topic Exchange
	- 라우팅 키를 **패턴 기반**으로 정의하여 여러 큐에 유연하게 전달할 수 있는 방식
	- 라우팅 키에 와일드카드(`*, #`) 매칭을 사용하여 더 복잡한 라우팅이 가능하다
		- 와일드카드 \* 의 경우 하나의 단어를 대체하는 의미로 log.info, log.warn과 같은 패턴의 메시지를 수신할 때 log.\*로 매칭되어 전부 수신가능 
		- \#의 경우 0개 이상의 단어를 대체하므로 app.order.success, app.payment.sucess와 같은 라우팅 키를 \#.success로 다 수신할 수 있다
	- 예시: 동적이고 유연한 라우팅이 필요할 때 사용 ()

---

