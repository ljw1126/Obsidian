
참고. 
- [AWS - RabbitMQ vs Kafka](https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/)
- [ZDNET korea - 아마존 CTO "이벤트 드리븐 아키텍처로 가라"](https://zdnet.co.kr/view/?no=20221202183934)
- [F-lab. 메시지 브로커와 이벤트 브로커: ..] (https://f-lab.kr/insight/message-broker-event-broker?gad_source=1&gbraid=0AAAAACGgUFeKgrz8-WR_U0x7Zupa8cKrf&gclid=Cj0KCQjw5azABhD1ARIsAA0WFUG1yOOiSHGGC-RXdc5Ua3iev4MphDgtYZGaK4CM969s4oJvMnP0tycaAn9DEALw_wcB)
- [RabbitMQ Tutorials](https://www.rabbitmq.com/tutorials)


Todo.
- RabbitMQ vs Kafka 비교 정리하기
- 주요 용어


## 섹션1. 쉽게 이해하는 RabbitMQ 개요과 비동기 아키텍처

slack에 notification 날린다는데 없네? ㅋㅋㅋ

### 3. RabbitMQ 설치


**도커로 설치** 
```shell
$ docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management
```
- `--rm` : ctrl + c 로 종료할 경우 컨테이너 삭제 됨
- default 로그인 정보 : `guest` / `guest`
	- 최초 계정은 guest이기 때문에 admin 권한을 갖는 다른 계정을 추가해주고 default user 는 삭제 해주는게 보안상 권고
- [도커 허브 - RabbitMQ](https://hub.docker.com/_/rabbitmq)

> RabbitMQ 콘솔 주소
> localhost:15672 

> [!info] F-lab 참조 게시글
> RabbitMQ : 메시지 브로커, 비유하자면 택배 서비스
> Kafka: 이벤트 브로커, 비유하자면 도서관


**Mac 설치**
```text
// brew install 
[https://brew.sh/](https://brew.sh/)

// 설치 전에 brew 업데이트 
brew update 

// rabbitmq 설치 
brew install rabbitmq

// starts a local RabbitMQ node 
brew services start rabbitmq 

// stops the locally running RabbitMQ node 
brew services stop rabbitmq

// 삭제
brew uninstall rabbitmq

// 삭제 후 관련 디렉터리도 삭제 해줘야 함
rm -r /opt/homebrew/etc/rabbitmq 
rm -r /opt/homebrew/var/lib/rabbitmq 
rm -r /opt/homebrew/var/log/rabbitmq
```


**다른 운영체제**
```markdown
// 바이너리나 인스톨러 등을 활용해서 설치 [https://www.rabbitmq.com/docs/download(https://www.rabbitmq.com/docs/download)

// 윈도우의 경우 환경 변수에서 RabbitMQ 실행 bin 폴더를 지정해주면 됨
C:\Program Files\RabbitMQ Server\rabbitmq_server-4.0.3\sbin
```


### 4. AMQP의 이해

> Advanced Message Queing Protocal의 약자
> MQ의 오픈소스에 기반한 표준 프로토콜을 의미


**메세지큐를 사용하는 이유**
- 비동기 처리가 가능한 분야에서는 메세지 큐를 통해 느슨한 결합을 가지고 처리하도록 한다
	- 비동기 메시지를 사용하여 다른 응용프로그램 사이에 데이터를 송수신
- 복잡한 프로세스를 동기로 처리시 병목 현상, 장애전파, 확장성 제한 등의 문제 발생가능
	- 클라이언트에 대한 동기 처리는 병목의 요인으로 비동기로 처리해도 될 영역에 대해서는 큐를 통해 분리해서 처리한다
- 결국 분산환경에서 응용프로그램들을 분리하고 독립적으로 확장하기 위해서 사용, 기능별로 모듈 구성이 용이하다 (**Scalability**)
- 요청에 대한 응답을 기다릴 필요 ❌
	- 각 영역의 역할만 신경쓰면 된다
	- 어플리케이션 레벨에서 분리 할 수 있다
- 데이터를 메모리 대신에 디스크에 저장하여 데이터 유실을 방지(**Reliability**)
	- 즉시 처리하지 않아도 나중에 다시 처리가 가능하다 
	- 메시지 영구 저장, 메시지 확인, 장애 복구 메커니즘을 통해 메시지의 신뢰성을 보장
- **확장성**
	- 여러 노드에 걸쳐 쉽게 확장할 수 있어 높은 가용성 제공
	- 필요에 따라 메시지를 클러스터링하거나 페더레이션(federation) 방식으로 확장할 수 있다
- **유연성**
	- 다양한 exchange 유형과 라우팅 규칙을 지원하여 메시지를 효과적으로 라우팅하고 관리할 수 있다.
	- **광범위한 프로토콜 지원**: 기본적으로 AMQP 사용, STOMP, MQTT, HTTP 등을 포함한 다양한 프로토콜을 지원
	- **풍부한 클라이언트 라이브러리**:  Java, Python, Ruby, .NET 등 다양한 언어로 클라이언트 라이브러리를 제공하여 다양한 애플리케이션에서 사용할 수 있다

<img src="./images/AMQP1.png"/>

- 여기서 말하는 exchange의 `one-to-one fanout`의 경우 
	- 여러 큐에 메시지를 브로드 캐스트하지만, 각 큐에 연결된 소비자는 한 명이므로 **메시지는 각각의 큐에서 하나의 소비자에게만 전달**되므로 1:1 방식의 메시지 소비를 뜻한다
	- **여러 소비자에게 동시에 메시지를 전달하되 각 메시지가 단일 소비자에게만 전달되도록 보장하고 싶은 경우를 의미**한다고 보면 된다

**AMQP 특징**
이전에도 상용화된 MQ 제품들이 많았지만, 대부분 플랫폼 종속적이라 서로 다른 이기종간에 메시지를 교환하기 위해 메시지 포맷 컨버전(속도 저하 발생)을 위한 메시지 브릿지를 이용하거나 시스템 자체를 통일시켜야 하는 불편함과 비효율성이 있었다. 즉, **AMQP의 목적**은 서로 다른 시스템 간에 (비용/기술/시간 측면에서)효율적으로 메시지를 교환하기 위한 MQ 프로토콜로 특징은 다음과 같다
- 모든 broker들은 똑같은 방식으로 동작할 것  
- 모든 client들은 똑같은 방식으로 동작할 것 
- 네트워크 상으로 전송되는 명령어 표준화
- 프로그래밍 언어 중립적



**메모.**
exchange 방식은 여러가지 
큐는 버퍼의 역할 (생산자와 소비자 사이)

// 로그를 logback, ELK 활용해서 수집하는 방법도 있고
// 메시지 큐를 활용해서 수집 모듈(소비자)에서 따로 저장하는 방식도 생각할 수 있겠네

### 5. 주요용어와 Exchange의 이해 

**메모.**
가장 눈에 띄는게 consumer가 메세지를 처리한 이후에 ACK를 보내야 한다.
보내지 않는 경우 RabbitMQ에서 메시지를 다시 큐에 넣어 다른 소비자가 처리하도록 할 수 있다
<-> Kafka는 최신 offset 기준으로 조회하고 갱신(?)해주는걸로 알고 있음

Prdocuer -> Exchange로 갈때는 `routing key`가 사용됨
Exchange -> Queue로 갈때는 `binding key`가 사용됨
// 모호하네 ..  키 두 개를 구분 지어라는 건가?

**🤔 그러면 "생산자 모듈에서 두 키를 지정하나요?" 에 대해 (Chat-gpt)**

> ❌ **아니요! 생산자는 `routing key`만 지정합니다.**  
> ✅ **`binding key`는 큐 바인딩 시 서버 또는 인프라 레벨에서 설정합니다.**

- **Producer**:  
    `convertAndSend(exchangeName, routingKey, message)`  
    (👉 routing key만 신경 씀)
    
- **Consumer**:  
    큐와 exchange를 바인딩할 때 **binding key를 지정**




**Routing Model Components**
AMQP의 라우팅 모델은 아래와 같은 3개의 중요한 component로 구성된다
- **Exchange**
	- producer에서 보낸 메시지를 적절한 큐 또는 다른 exchange로 분배하는 라우터의 기능을 함
- **Binding**
	- exchange와 큐와의 관계를 정의한 **일종의 라우팅 테이블**
	- 같은 큐가 여러 개의 exchange에 bind 될 수 도 있고, 하나의 exchange 에 여러 개의 큐가 binding 될 수 있다
- **Queue**
	- 메모리나 디스크에 메시지를 저장하고, consumer에게 전달하는 역할을 함


![[Pasted image 20250426132410.png]]


**RabbitMQ의 주요 용어 정리**
- Producer (생산자)
	- 메시지를 생성하고 RabbitMQ에 전송하는 애플리케이션
	- 특정 Exchange에 메시지를 전송하고 Exchange는 메시지를 라우팅하여 큐에 배치
- Exchange
	- Producer로부터 받은 메시지를 큐에 전달하는 역할 
	- 유형
		- Direct: 특정 라우팅 키와 정확히 일치하는 큐에 메시지를 전송 
		- Fanout: 모든 큐에 메시지를 브로드캐스트 
		- Topic: 라우팅 키 패턴을 기반으로 메시지를 특정 큐에 전달 
		- Headers: 메시지 헤더 속성에 따라 메시지를 라우팅 
	- 메시지가 Exchange로 전송될때, Routing Key가 함께 전달
- Routing Key
	- 메시지를 전송할 때 Producers가 Exchange에 전달하는 키
	- Exchange는 이 Routing Key를 참고하여 어떤 큐에 메시지를 전달할지 결정
- Queue
	- 메시지를 일시적으로 저장하는 버퍼 역할
	- RabbitMQ의 큐는 FIFO 방식으로 동작하며, 메시지가 소비자에게 전달될 때까지 보관
	- 각 큐는 여러 Consumer가 구독(수신)할 수 있으며, 메시지는 큐에 들어온 순서대로 전달
	- 비동기적으로 동작하며, 여러 컨슈머가 동시에 메시지를 소비할 수 있다
		- 단, 하나의 메시지가 여러 소비자에게  중복으로 전달될 수 없음
		- 동일한 메시지를 수신하려면 fanout Exchange 방식으로 동작해야만 함
- Binding
	- exchange와 큐 간의 관계를 정의
	- 바인딩은 메시지를 라우팅할 때 어떤 조건으로 큐에 보낼지 정의하고 이를 위해 binding key가 사용됨 
	- Binding Key와 Routing Key가 일치하면 해당 큐로 메시지가 전달 (패턴 매칭 지원)
- Consumer (소비자)
	- 큐에서 메시지를 가져와 처리하는 애플리케이션
	- RabbitMQ는 여러 소비자에게 메시지를 로드 밸런싱 할 수 있다
	- Consumer는 큐에서 메시지를 받아 처리하면 메시지에 대한 확인(ACK, acknowledgment)을 브로커에 전송함
	- 확인을 보내지 않으면, 브로커는 메시지를 재전송하거나 설정한 다른 Consumer에게 전달할 수 있다
- Message Acknowledgment (메세지 확인)
	- 메시지가 성공적으로 처리되었음을 RabbitMQ에 알리는 과정
	- 만약 소비자가 메시지를 성공적으로 처리하지 못했다면, 메시지를 다시 큐에 넣어 다른 소비자가 처리하도록 할 수 있다


**절차 요약**
```text
1. Producer가 메시지와 Routing Key를 Exchange에 전송
2. Exchange가 Routing Key를 사용해 Binding Key가 일치하는 큐에 메시지를 라우팅
3. Consumer가 큐에서 메시지를 가져와 처리하고, 성공적으로 처리되었음을 acknowledgment로 RabbitMQ에 알림
```


**추가 용어**
- Prefetch Count
	- 소비자가 받을 수 있는 최대 메시지 수 설정
	- 한 번에 많은 양의 메시지를 처리하지 않도록 해 소비자의 성능 최적화
- Virtual Host (가상 호스트)
	- RabbitMQ 서버 내의 논리적인 구획으로, 메시지 큐, 익스체인지, 사용자 권한 등을 구분 
	- 하나의 RabbitMQ 서버 내에 여러 개의 가상 호스트를 설정하여 서로 다른 애플리케이션의 메시지를 격리 할 수 있다
- Dead Letter Queue (DLQ)
	- 메시지가 처리되지 못하거나 유효 기간이 지난 경우 별도의 큐로 이동하는 구조도 설정할 수 있다

**Exchange 유형에 따른 처리**
- 1. Direct Exchange
	- 메시지가 routing key에 따라 특정 큐로 하나씩 전달되는 방식
	- 메시지 발행시 사용하는 라우팅 키와 동일한 키로 익스체인지에 바인딩 된 모든 큐에 메시지를 전달
	- 해당 라우팅 키와 일치하는 큐에만 메시지가 전달되는 방식이기 때문에 Direct Exchange 라고 함
	- 예시. 주문에 따른 상태 지시
		- 활용: 주문 상태별로 **라우팅 키**를 정의, 각 상태에 해당하는 큐가 메시지를 받는다. 매핑이 정확하게 되는 한 개의 키만 있으니깐 1:1로 가능할 거 같은데, **하나의 라우팅 키**에 대해 **여러 큐**가 바인딩 될 수 있기 때문에 **1:N** 매칭이 가능하다.
			- 메시지가 명확하게 특정 큐로 전달되어야 할 때
			- 큐마다 고유한 라우팅 규칙을 적용하여 메시지를 분류해야 할 때
	- **예시 업무**: 주문 상태 처리, 결제 처리, 사용자 알림 시스템 등
- 2. Topic Exchange
	- 라우팅 키를 **패턴 기반**으로 정의하여 여러 큐에 유연하게 전달할 수 있는 방식
	- 라우팅 키에 와일드카드(`*, #`) 매칭을 사용하여 더 복잡한 라우팅이 가능하다
		- 와일드카드 \* 의 경우 하나의 단어를 대체하는 의미로 log.info, log.warn과 같은 패턴의 메시지를 수신할 때 log.\*로 매칭되어 전부 수신가능 
		- \#의 경우 0개 이상의 단어를 대체하므로 app.order.success, app.payment.sucess와 같은 라우팅 키를 \#.success로 다 수신할 수 있다
	- 동적이고 유연한 라우팅이 필요할 때 사용 
	- 예시: 로그 수집 시스템, 이벤트 기반 모니터링 등
- 3. Fanout Exchange
	- 브로드캐스트 방식으로 메시지를 모든 바인딩된 큐에 전달한다
	- 한 번의 메시지 발행으로 모든 큐가 동일한 메시지를 받는다
		- 이벤트가 발생하면 모든 서비스가 동일한 메시지를 받는 서비스에서 유용
	- 예시. 시스템 점검 공지 등 
- 4. Headers Exchange
	- 메시지의 속성(헤더)에 기반한 복잡한 라우팅이 필요할 때 사용 
	- 메시지 헤더에 `language: "ko"`등의 값을 설정하여 헤더 기반 라우팅 수행
		- `language: "ko"`로 설정된 메시지는 한국어 이메일 서비스에서 처리 
		- `language: "en"`로 설정된 메시지는 영어 이메일 서비스에서 처리 


**메시지 전송 단계별 프로세스**
![[메시지단계별flow.png]]
1. 메시지 전송 
	1. Producer ➡️ Broker (RabbitMQ)
	2. 이때 메시지는 큐에 저장되며, Exchange와 Binding 설정에 따라 적절한 큐로 라우팅
2. 메시지 전달 
	1. Broker ➡️ Consumer
	2. Consumer는 **큐에서 메시지를 가져가거나(Polling) 메시지를 푸시(Push)** 받는 방식으로 수신
3. 메시지 확인(ACK) 또는 커절(NACK)
	1. **ACK** : 
		1. Consumer가 메시지를 성공적으로 처리 후 Broker에게 ACK 전송
		2. 이 경우 Broker는 해당 메시지를 큐에서 제거하고 Producer에게 **Message Acknowledged** 응답을 전송 (Producer가 Publisher Confirms 사용시 활용)
	2. **NACK** : 
		1. Consumer가 메시지 처리에 실패하거나 메시지를 거절당할 경우 NACK을 전송
		2. NACK에는 메시지를 다시 큐로 보내야 할지(requeue) 또는 폐기해야 할지 (discard) 설정 가능 
			1. Requeue(재전송) : 메시지를 다시 큐로 보내고 재처리할 수 있도록 설정
			2. Discard(폐기) : 메시지를 큐에서 제거하고 폐기
4. Producer에 응답 (Message Acknowledged / Message Rejected)
	1. Producer가 Publisher Confirms를 활성화한 경우 Broker는 ACK또는 NACK 결과를 Producer에게 전송
	2. ACK를 받은 경우 메시지가 성공적으로 소비된 것으로 간주
	3. NACK를 받는 경우 Producer는 메시지 실패를 기록하거나 재전송

---

## 섹션2. RabbitMQ 기본 튜토리얼 

### 6~7. 단순 메시지 전송 (Producer to Consumer)

```shell
docker run -it -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management
```

계정 추가하면 Can access virtual hosts가 No access 확인됨 (접근 권한 x 상태)

<img src="./images/console1.png">

➡️ Name을 누르고 설정 이동하면 Set Permission 버튼을 눌러줌
➡️ 이전 화면으로 돌아가면 No access 사라짐 

<img src="./images/console2.png"/>

인텔리제이 프로젝트 설치
- HelloMessageQueue
	- JDK17
	- 의존성: Spring Boot Dev Tools, Spring Web, Spring for RabbitMQ, Lombok

application.yml 작성
```shell
spring:
  rabbitmq:
    host: localhost
    port: 5672  // 기본 통신 포트, 15672는 주로 관리 및 모니터링(admin) 용도로 사용
    username: guestuser
    password: guestuser
  application:
    name: HelloWorldMessageQueue
server:
  port: 8080

```

`RabbitMQConfig` Bean 생성
- `Queue queue()` 
	- Bean은 Queue 인스턴스를 생성하고, 애플리케이션이 사용할 RabbitMQ를 정의
	- 첫번째 인자 QUEUE_NAME: 메시지가 쌓이고 처리할 큐의 이름을 정의
	- 두번째 인자 durable (boolean) : 큐가 휘발성(volatile)인지 영속성(persistent)인지 여부 지정
- `RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory)`
	- RabbitMQ 통신을 위한 템플릿 클래스, 메시지를 보내고 받을 때 사용
	- RabbitTemplate은 Spring의 JdbcTemplate과 비슷하게, RabbitMQ와 상호작용하기 위한 간단한 API를 제공합니다. 
	- 주로 메시지 전송을 담당
	- **ConnectionFactory** : RabbitMQ와의 연결을 관리하는 객체로, rabbitTemplate에 주입하여 메시지를 전송할 떄 사용할 커넥션을 제공
	- **사용 용도**: 메시지를 전송하는 Sender가 `rabbitTemplate.convertAndSend()` 메서드를 사용해 큐에 메시지를 넣는데 사용
- `SimpleMessageListenerContainer container(ConnectionFactory connectionFactory, MessageListenerAdapter listenerAdapter)`
	- 이 Bean은 RabbitMQ 메시지를 비동기적으로 수신하기 위해 리스너를 생성함
	- 이 컨테이너는 특정 큐를 지속적으로 모니터링하고, 메시지 수신하며 지정된 리스너(MessageListenerAdapter)를 통해 처리함
	- `ConnectionFactory` : RabbitMQ와 연결을 유지하며, 수신하는 메시지를 이 연결을 통해 가져옴
	- `setQueueName(QUEUE_NAME)`: 특정 큐 이름을 설정, 이 컨테이너는 해당 큐에서 수신되는 메시지를 모니터링
	- `setMessageListener(listenerAdapter)`: listenerAdapter를 설정하여, 메시지가 수신될 때 호출할 리스너를 지정
	- Spring AMQP에서 메시지를 자동으로 수신하려면 SimpleMessageListenerContainer가 필요
		- 메시지 수신과 관련된 스레드 관리, 연결 유지, 큐 모니터링 작업을 자동으로 처리함
		- 만약 없이 구현한다면
			- RabbitTemplate의 `receiveAndConvert()` 메서드를 수동 호출하여 메시지를 가져오는 동기적 방식으로 구현해야 함
			- 이는 비효율적이며, 큐의 상태를 주기적으로 확인(polling)해야 하기 때문에 자원을 낭비할 수 있습니다.
- `MessageListenerAdapter listenerAdapter(Receiver receiver)`
	- `MessageListenerAdapter`: 수신한 메시지를 특정 클래스의 특정 메서드로 전달하는 어댑터 역할을 함
		- receiver 객체는 메시지를 처리하는 역할을 하는 빈 (사용자 정의 컴포넌트 빈)
		- receiveMessage 메서드를 호출합니다 (default 명칭 **"handleMessage"**, 문자열 지정 가능) ➡️ MessageListenerAdapter 생성자 확인
		- MessageListenerAdapter는 RabbitMQ에서 수신된 메시지를 특정 메서드에 전달할 수 있도록 해 줌
			- 이 경우 `receiveMessage()`가 자동 호출되며, 메시지 내용을 인자로 받음
			- Receiver 클래스의 receiveMessage()가 메시지를 수신하여 처리하도록 설정
	- RabbitMQ에서 수신된 메시지가 `receiver.receiveMessage(String message)`로 전달된다

step1 생성 후 http 호출 테스트 
```text
###  
POST http://localhost:8080/api/messages/send  
Content-Type: application/json  
  
"hello world"


-------------------------

POST http://localhost:8080/api/messages/send

HTTP/1.1 200 
Content-Type: text/plain;charset=UTF-8
Content-Length: 44
Date: Sat, 26 Apr 2025 07:24:16 GMT

[#] Message sent successfully! "hello world"
```

```text
// 콘솔 
[#] Sent : "hello world"
[#] Received message: "hello world"
```

**참고.** [기억보단 기록을 - 인텔리제이 http](https://jojoldu.tistory.com/266)

---
### 8 ~ 9. Consumer간 작업 분배

**Competing Consumers Pattern**
> [!info] 
> 메시지를 여러 Consumer(소비자) 간에 분배하여 작업을 분산 처리하는 구조
> 작업 부하를 효율적으로 분산하고, 병렬 처리를 가능하게 만들어 처리 속도를 향상시킴
- `Round-Robin `방식과 `Fair Dispatch` 방식을 사용하여 메시지를 Consumer 간에 분배
- `Fair Dispatch` 방식은 메시지 수동 확인(Manual Acknowledgement) 모드로 개발하고 메시지 처리 비중 (Prefetch Count) 설정 등을 통해 조정 가능 (기본값은 AUTO를 많이 씀)

**주요 특징**
- 1. 경쟁적인 메시지 소비 
	- 여러 Consumer가 동일한 메시지 큐에서 메시지를 가져가 처리 
	- 특정 메시지는 한 번에 하나의 Consumer에 의해 처리되므로 메시지 중복 처리 방지
- 2. 작업 분산
	- 메시지가 여러 Consumer 간에 분배되어 병렬로 처리되므로 작업 부하를 효율적으로 분산
- 3. 확장성
	- Consumer를 추가하거나 제거함으로써 작업 처리 능력을 동적으로 확장하거나 축소
- 4. 내결함성
	- Consumer 중 하나가 실패하더라도 다른 Consumer가 작업을 이어받아 처리할 수 있어 시스템이 중단 없이 작동


> step2 예시

```java
package com.example.hellomessagequeue.step2;  
  
import org.springframework.amqp.core.AcknowledgeMode;  
import org.springframework.amqp.core.Queue;  
import org.springframework.amqp.rabbit.connection.ConnectionFactory;  
import org.springframework.amqp.rabbit.core.RabbitTemplate;  
import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;  
import org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;

@Configuration  
public class RabbitMQConfig {  
  
    public static final String QUEUE_NAME = "work-queue";  
  
    @Bean  
    public Queue queue() {  
        return new Queue(QUEUE_NAME, true);  
    }  
    @Bean  
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {  
        return new RabbitTemplate(connectionFactory);  
    }  
    @Bean  
    public SimpleMessageListenerContainer container(ConnectionFactory connectionFactory, MessageListenerAdapter listenerAdapter) {  
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();  
        container.setConnectionFactory(connectionFactory);  
        container.setQueueNames(QUEUE_NAME);  
        container.setMessageListener(listenerAdapter);  
        container.setAcknowledgeMode(AcknowledgeMode.AUTO);  
        return container;  
    }  
    @Bean  
    public MessageListenerAdapter listenerAdapter(WorkQueueConsumer workQueueConsumer) {  
        return new MessageListenerAdapter(workQueueConsumer, "workQueueTask");  
    }}
```
- `Queue` 에서 durable(영속성)을 **true** 설정
- `SimpleMessageListenerContainer`에서 `setAcknowledgeMode(..)` 추가
	- `AcknowledgeMode.AUTO` : consumer에서 메시지 처리 후 RabbitMQ에 ACK 전달
	- RabbitMQ에서 AcknowledgmentMode는 메시지가 처리 완료되었음을 RabbitMQ에 알리는 방식
	- Round-Robin 방식이며 별도 설정을 하지 않아도 기본으로 동작함
	- AcknowledgeMode는 AUTO이외에 MANUAL 과 NONE 이 있음


Queue and Sterems 탭에서 **purge message**버튼 누르면 ready 상태 메시지를 초기화한다(복구 불가)

**에러상황**
- **durable(영속성)** 상태가 **true**로 빈에 설정해 둔 상태
- producer 에서 message 를 넘길 때 공백을 파이프 라인에 붙여주면 아래와 같은 에러가 발생하며 어드민상에 **unacked** 를 확인할 수 있음
- 일부러 컨슈머에서 파싱할 때 공백 추가 `split("| ")`
	- 컨슈머가 파싱 에러가 나서 unacked를 보내게 된다
	- 에러를 고치고 메시지를 소비할 수 있도록 해야 한다

⚠️ 메시지 처리가 안되는 경우, 어드민에서 확인해야 할 사항 
- **ready**
	- 메시지가 큐에 있지만 아직 컨슈머에게 전달되지 않은 상태를 의미
	- 이 상태의 메시지는 대기 중이며, 컨슈머가 연결되면 전달될 준비가 됨
	- 큐의 적재량이 많아지면 ready 메시지 수가 증가
- **unacked**
	- 메시지가 컨슈머에게 전달되었으나 아직 확인되지 않은 상태
	- 컨슈머가 메시지를 처리하고 확인(ACK)을 보내면, RabbitMQ는 해당 메시지를 삭제
	- 컨슈머가 확인을 보내지 못하거나 연결이 끊어지면, 메시지는 다시 ready 상태로 되돌아감 (설정에 따라 다름)
- unacked 상태에서 consumer가 제대로 소비하도록 수정하면 unacked에서도 처리가 되어 삭제된다
- 메시지 삭제
	- **purge**
		- purge 명령은 큐에 있는 ready 메시지를 삭제
		- 삭제된 메시지는 복구되지 않으며, 데이터는 소실됨
		- unacked 메시지는 purge로 삭제되지 않음
		- unacked 메시지를 삭제하려면 컨슈머가 연결을 끊거나 RabbitMQ 큐를 재시작해야 함
		- 컨슈머가 연결을 끊으면 unacked 메시지는 다시 ready 상태로 돌아감
- 일반적인 문제 해결 방법
	- ready가 많을 경우: consumer 수를 늘리거나, 메시지 처리 속도를 최적화 해야 함
	- unacked가 많을 경우
		- consumer 코드 수정 (프로그램 에러 가능성이 높음)
		- consumer 연결 상태를 확인하여 재연결 혹은 재시작 필요

**정상 상황**
<img src="./images/9-1.png"/>



> 9에서 build 한 jar 파일을 다른 포트로 해서 2개 어플리케이션 실행시킴
> 라운드 로빈 방식으로 consumer가 메시지를 소비하는 것을 확인함


cURL(컬) 테스트
```shell
curl -X POST "http://localhost:8080/api/workqueue?message=Task1&duration=2000" curl -X POST "http://localhost:8080/api/workqueue?message=Task2&duration=4000" curl -X POST "http://localhost:8080/api/workqueue?message=Task3&duration=5000"
```


빌드 후 서버 실행 ➡️ cURL 호출로 각 소비자가 메시지를 순서대로 처리함을 확인 (라운드 로빈 방식)
```shell
java -jar HelloMessageQueue-0.0.1-SNAPSHOT.jar --server.port=8080 
java -jar HelloMessageQueue-0.0.1-SNAPSHOT.jar --server.port=8081
```

<img src="./images/9-2.png">

---

### 10 ~ 12 Pub/Sub 모델을 이용한 실시간 알림 

- 10, 11의 경우 step3 브랜치 
	- websocket으로 서버에 연결하면, 메시지가 도착할 경우 사용자 화면에 출력하는 예시를 다룬다
	- stomp로 클라이언트에서 서버로 인풋 메시지 보냄
	- 1. RabbitMQ로 연결되어 있기 때문에 소비자에서 `/topic/notifications` 로 브로드 캐스팅 하는 구나
	- 2. 클라이언트 화면에서 stomp로 직접 서버에 메시지를 보내(`/app/send`) `/topic/notifications`로 브로드 캐스팅
- 12의 경우 step4 브랜치
	- 구독 서비스처럼 콤보 박스 선택해서 메시지 받는 형태로




```java
@Configuration  
public class RabbitMQConfig {  
    public static final String QUEUE_NAME = "notification-queue";  
    public static final String FANOUT_EXCHANGE = "notification-exchange";  
  
    @Bean  
    public Queue notificationQueue() {  
        return new Queue(QUEUE_NAME, false); // 메시지는 volatile로 설정  
    }  
  
    @Bean  
    public FanoutExchange fanoutExchange() {  
        // 메시지를 수신하면 연결된 모든 큐로 브로드캐스트  
        return new FanoutExchange(FANOUT_EXCHANGE);  
    }  
    
    @Bean  
    public Binding bindNotification(Queue notificationQueue, FanoutExchange fanoutExchange) {  
        // BindingBuilder.bind().to() 를 통해 큐와 익스체인지를 연결  
        return BindingBuilder.bind(notificationQueue).to(fanoutExchange);  
    }}
```
- `Binding` : exchange와 queue를 바인딩(연결) 해준다
	- 애플리케이션 시작시 
		- Spring Boot AMQP AutoConfiguration이 동작합니다 
		- RabbitAdmin이라는 컴포넌트가 작동해서 **등록된 Bean(Queue, Exchange, Binding)들을 RabbitMQ 서버에 직접 API 호출해서 생성합니다** 


RabbitMQ로 메시지를 발행하면, `NotificationSubscriber` 에서 메시지를 소비하여 `/topic/notifications`로 메시지를 전달함
```shell
curl -X POST 'http://localhost:8080/notifications' -H 'Content-Type: application/json' -d '"Hello! Subscriber!!!"'
```


```java
@Component  
@RequiredArgsConstructor  
public class NotificationSubscriber {  
    public static final String CLIENT_URL = "/topic/notifications";  
  
    // WebSocket으로 메시지를 전달하기 위한 Spring의 템플릿 클래스.  
    private final SimpMessagingTemplate simpMessagingTemplate;  
  
    @RabbitListener(queues = RabbitMQConfig.QUEUE_NAME)  
    public void subscriber(String message) {  
        // RabbitMQ Queue에서 메시지 수신  
        // String message = (String) rabbitTemplate.receiveAndConvert(RabbitMQConfig.QUEUE_NAME);  
        System.out.println("Received Notification: " + message);  
        // convertAndSend 를 통해 특정 경로로 메시지를 전달함  
        simpMessagingTemplate.convertAndSend(CLIENT_URL, message); // 클라이언트에 브로드캐스트  
    }  
}
```


사용자 화면에서 인풋 박스 통해 `/app/send`발송하게 되면 마찬가지로 `/topic/notifications`로 발행

```java
@Controller  
@RequiredArgsConstructor  
public class StompController {  
    private final SimpMessagingTemplate messagingTemplate;  
  
    @MessageMapping("/send")  
    public void sendMessage(NotificationMessage notificationMessage) {  
        // 수신된 메시지를 브로드 캐스팅  
        String message = notificationMessage.message();  
  
        System.out.println("[#] message = " + message);  
  
        // 클라이언트에 메시지 브로드캐스트  
        messagingTemplate.convertAndSend("/topic/notifications", message);  
    }  
}
```

**사용자 화면**
<img src="./images/10-11.png"/>

**notification pub/sub 개발 순서**
- RabbitMQConfig : 3개의 Bean(Queue, Exchange, Binding)을 설정
	- FanoutExchange 설정
	- QueueName 설정
	- BindingBuilder를 통해 생성한 큐와 익스체인지(fanout exchange) 연결
- Publisher
	- RabbitTemplate을 이용해 convertAndSend
	- RabbitMQ에 메시지 발행
- Subscriber
	- `@RabbitListener(queues = RabbitMQConfig.QUEUE_NAME)`
		- 내부적으로 Spring의 MessageListenerContainer를 사용하여 Queue를 지속적으로 모니터링
		- Spring이 메시지 수신을 자동화하고, 비동기적으로 처리. 코드가 간결
		- 메시지 수신, 메서드 호출과 변환, Ack 전송 등의 역할
	- SimpMessageingTemplate을 통해 특정 경로에 메시지 전달
		- WebSocket 메시지 브로커와 통신하며, 클라이언트가 구독하는 특정 경로로 메시지를 전송
		- 특정 클라이언트나, 클라이언트 그룹에게 메시지 전송 가능
		- STOMP의 경로를 지정
- WebSocketConfig
	- WebSocketMessageBroker 활성화
	- WebSocketMessageBrokerConfigurer를 구현
	- Spring에서 WebSocket 메시지 브로커를 구성하기 위한 인터페이스로 웹소켓 연결, 메시지 브로커 설정 및 라우팅 등의 웹 소켓 관련 확장기능을 제공함

```java
@Override
public void registerStompEndpoints(StompEndpointRegistry registry) {
    registry.addEndpoint("/ws") // WebSocket 연결 엔드포인트
            .setAllowedOriginPatterns("*") // CORS 설정
            .withSockJS(); // SockJS 지원
}

@Override
public void configureWebSocketTransport(WebSocketTransportRegistration registry) {
    registry.setMessageSizeLimit(2048); // 메시지 크기 제한 (2 KB)
    registry.setSendTimeLimit(5 * 1000); // 전송 제한 시간 (5초)
    registry.setSendBufferSizeLimit(512 * 1024); // 버퍼 크기 제한 (512KB)
}

```
기타 메시지 변환을 위한 converter나 메시지 전송 브로커 경로 등을 설정할 수 있음 


- 클라이언트 구독 경로 설정
	- `config.enableSimpleBroker("/topic");` // 클라이언트 구독 경로
- 서버의 발행 경로 설정
	- `config.setApplicationDestinationPrefixes("/app");` // 서버 발행 경로
- Websocker endpoint 설정 
	- `registry.addEndpoint("/ws").setAllowedOriginPatterns("*").withSockJS();`
- Controller 생성 
- HTML 작성 
	- sock.js : WebSocket 연결을 지원하지 않는 브라우저에서도 동작하도록 폴백(fallback) 기능을 제공하는 라이브러리로 아래와 같은 전송 타입을 지원
		- WebSocket
		- HTTP Streaming
		- HTTP Long Polling
	- stomp.js
		- STOMP(Simple/Streaming Text Oriented Messaging Protocol) 프로토콜을 지원하는 JavaScript 클라이언트 라이브러리
		- [https://stomp.github.io/stomp-specification-1.2.html](https://stomp.github.io/stomp-specification-1.2.html)
		- 텍스트 기반 프로토콜로, 메시지의 유형, 내용을 정의하여 클라이언트와 서버간 메시지를 주고 받음
		- RabbitMQ와 같은 브로커와 통신하는 데 사용
		- 각 프레임은 명령(Command), 헤더(Header), 바디(Body)로 구성
		- 이기종 시스템 간의 메시징에 유용


**WebSocket**
- WebSocket은 **양방향 통신**을 가능하게 하는 표준 프로토콜(RFC 6455)로 클라이언트와 서버 간에 **실시간 데이터**를 주고받는 데 적합하다.
- 데이터를 프레임 단위로 전송하며, 오버헤드가 낮음.
	- 기존의 HTTP 기반 통신과 달리, 연결이 초기화된 후에는 **상태를 유지**하며 데이터 교환이 가능
	- ws://호스트:포트/경로 형태로 작성 (ws://example.com/chat)

**WebSocket 특징**
**1. 실시간성**
- 클라이언트와 서버 간 실시간으로 데이터를 주고받을 수 있음
- 예: (주식거래, 채팅, 실시간 알림)

**2. 효율성:**
- HTTP 기반 폴링(Polling)보다 네트워크 자원과 대역폭을 절약.
- 연결이 열려 있는 동안 별도의 요청/응답 없이 데이터를 지속적으로 전송 가능.

**3. 양방향 통신 (Full-Duplex)**:
- 클라이언트에서 서버로 요청을 보낼 필요 없이, 서버가 클라이언트로 데이터를 푸시.

**4. 낮은 지연 시간:**
- 한 번 연결이 설정되면 데이터 전송 속도가 매우 빠름

**5. 상태 유지 (Persistent Connection)**:
- 연결이 끊기지 않는 동안 클라이언트의 상태를 서버에서 유지 가능.


**NotificationPublisher 부터의 전체 흐름**

> publisher는 exchange에 메시지를 보냄 ➡️ exchange는 binding으로 인해 queue와 연결되어 있음
> ➡️ subscriber에서 RabbitListener에 의해 QUEUE_NAME을 바라보다가 exchange에 메시지가 도착하면 Queue로 발행되고 메시지를 수신

- `Binding`
	- RabbitMQ에서 Exchange와 Queue 간의 관계를 정의 
	- 메시지가 Exchange에 도착했을때, 어떤 Queue로 전달할지를 결정
- `BindingBuilder.bind(notificationQueue).to(fanoutExchange)`
	- notificationQueue를 fanoutExchange에 연결
	- fanout Exchange의 메시지를 해당 queue로 전달하도록 설정



**pub/sub의 활용 영역 예시**
- 실시간 채팅
- 실시간 알림 (실시간 상태 변경 및 수신)
- IoT 데이터 스트리밍 (중앙 서버에 발행)
- 위치 추적, 이벤트 트래킹, 분산 이벤트 통신 (메시지 전달)
- SNS의 좋아요, 새 게시물, 댓글, 팔로워 등

---

step4의 경우 소켓 통신을 바꿔가면서 메시지를 소비하는 예시를 다룬다 
- 개발 뉴스 레터 구독시 관심사 체크(Java/Spring/Vue)
- 각각의 관심사별 Exchange 연결에 따른 메시지 발행과 구독 

