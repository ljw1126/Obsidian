

p38 지식 노동자 

피터 드러커의 프로페셔널의 조건
> 지식 노동자는 시대적 소명임과 동시에 지식 사회인 현대의 가장 기본적인 생산 요소

반면에 개발자는 그 자신이 생산 시설의 일부입니다. 개별 개발자는 기업의 성과에 큰 영향을 끼치는 존재이고 개인으로 어느 정도 협상력을 가집니다. 설사 회사에서 나가게 되더라도 전통적인 노동자에 비해서 쉽게 새로운 직장을 구할 수 있습니다. 그 자신이 그런 가치를 가지고 있기 때문입니다.

..

무엇보다 개인이 스스로 목표를 설정하고 이 목표를 달성하려면 자신을 경영해야 한다는 가르침을 깊이 받아들였습니다.

피터 드러커는 지식은 과업과 연결되어야만 생상적인 것일 수 있고 조직은 끊임없이 자기 혁신을 추구하며 불안전해야 한다"고 하면서 이렇게 말합니다 

> [!note] 
> 지식 근로자는 스스로 성과의 방향을 설정해야 하기 때문에, 자신에게 어떤 성과가 기대되고 있는지 그리고 자신에게 그러한 성과가 기대되고 있는 이유가 무엇인지를 이해하지 않으면 안된다 - 피터드러커


p44

팀워크가 좋은 팀은 의미 있는 성과를 지속적으로 내며 늘 더 높은 목표에 도전합니다. 공동의 목표를 위해 협력할 줄 알고, 서로 배우고 가르치며, 개인과 팀 모두 성장합니다. 

>[!note]
>뛰어난 팀 없이 뛰어난 소프트웨어는 얻을 수 없다. 그리고 대부분의 소프트웨어 팀은 역기능가정 같이 움직인다


p46
<기술자 히포크라테스 선서>
>[!note]
>나는 내가 관물을 지키는 사람임을 안다. 권위에 복종하기보다 내가 만든 기술의 결과에 훨씬 더 관심을 둔다. 내가 이 선서를 어기지 않는다면, 나는 삶과 내 기술을 즐기며, 내가 사는 동안 존중받고 그 후에는 기억될 것이다.


저는 아직도 우리 개발자가 전문가로 인정받지도, 그렇게 행동하고 있지도 않다고 생각합니다. 

..

무엇보다 개발자를 양성하는 교육 과정과 개발이라는 행위는 여전히 흑마법 같습니다. 제가 보기에 어떤 대학도 이렇다 할 개발자 양성 교과 과정을 제시하지 못하고 있습니다. 애초에 개발자가 누구인지 분명하게 말하지도 못하는 것 같습니다.  개발 과정에 대해서도 이제 막 이해하기 시작한 수준이지 않나 싶습니다. 

`스티브 맥코넬`은 우리 업계에 주기적으로 골드 러시가 일어난다고 말합니다. 이런 호황기에는 그냥 아무렇게나 일을 해도 돈을 벌 수 있습니다. 하지만 골드 러시가 끝나고 나면, 그래서 진짜 실력으로 평가되고 경쟁해야 하는 때가 오면 엔지니어링 전문성이 중요해질 것이라고 말합니다.


**📚 도서추천** 
- 드라이브
- 테크니컬 리더
- 프로페셔널의 조건
- 성공하는 사람들의 7가지 습관
- 만화로 보는 댄 에리얼리 최고의 선택


## 02. 오류를 만날 때가 가장 성장하기 좋을 때다

오류를 만나는 일은 개발자에게 즐겁지 않은 일입니다 
하지만 백엔드 엔지니어로서 저는 "백엔드 엔지니어의 실력은 얼마나 많은 오류가 장애를 만나고 이를 해결했는지 여부에 따라 갈린다"라고 말합니다.

..

오류를 만날 때 좌절하지 않고 끝내 해결하고 어떻게 더 나은 개발자로 나알갈 수 있었는지 저만의 두 가지의 우너칙을 소개해보겠습니다.

원칙1. 오류가 발생하면 소스 코드 레벨에서 이해하자

// 레디스에서 버그를 코드 레벨에서 찾아 내고 컨트리 뷰터가 되었다는 얘기

p55
서비스를 운영하다보면 많은 툴을 사용하고, 많은 에러를 마주치게 됩니다. 이때 해당 오류를 스택오버플로에서 검색하면 대부분은 손쉽게 해결책을 얻을 수 있습니다. 하지만 단순히 여기서 끝내버리면, 실제로 깊은 지식을 얻기가 어렵습니다. 한발 더 나아가서 해당 툴의 소스 코드를 확인하는 것으로 관련 에러가 왜 발생하는지 해결하려면 어떻게 해야 하는지 같은 깊은 지식을 얻을 수 가 있습니다. 파생되거나 비슷한 문제를 예방할 수도 있게 됩니다. 이것이 바로 소스 레벨에서 오류를 확인하라는 주장하는 이유입니다. 

원칙2. 알아낸 지식을 글로 공개하라
소스레벨에서 이해한 내용을 이해했다면 결과물로 남기는 것이 중요합니다.  .. 개발자로서 성장하는 데 좋은 정보를 뇌에 입력하는 것도 좋지만, 제대로 이해하고 있는지 확인받는 것도 중요합니다. 아예 모르는 것보다 잘못 아는 것이 더 위험합니다. 그러므로 가급적이면 결과물을 공개해 다른 사람의 조언을 들을 기회로 삼아보시길 바랍니다. 

.. 
온라인에는 고수가 여럿 계십니다. 온라인에 공개하면 그분들을 스승으로 삼아 잘못된 지식을 바로 잡을 수 있고, 오픈 소스에 기여하며 커뮤니티 고수들에게 배울 수 있습니다. 이런 기회를 꼭 잡길 빕니다.


p56
**오래된 오류와의 만남**
- C/C++로 데이터를 주고 받는 TCP 서버를 수정한 적이 있습니다. 현재 서버의 생존을 확인하는 응답을 주는 API 서버릁 테스트하는데 서비스 패킷이 늦게 전달되는 일이 자주 발생했습니다. 
	- `tcpdump` 이용해서 패킷을 분석하는데 마지막 몇 바이트가 계속 오지 x
	- 동료가 네이글 알고리즘을 언급해줌
		- 네이글 - : 네트워크의 효율성을 높이기 위해서, 출력할 데이터가 도착할 때마다 매번 보내는 것이 아니라, 지정된 크기를 모아서 보내는 방식입니다. 
	- TCP 역시 네이글 알고리즘을 사용하고 있으므로 지정된 크기만큼 데이터 쌓이기 않았을 때 늦게 전송되는 현상이 나타난 겁니다


[라인 봇 sdk python](https://github.com/line/line-bot-sdk-python?tab=readme-ov-file)

p68
개발자라면 어떻게 하면 더 능력 있는 개발자가 될 수 있을까를 늘 고민합니다. 어딘가에 숨겨 잇을지도 모를 은탄환을 찾아보는 심정으로 다양한 방법을 시도해봅니다. 아무리 좋은 학습 방법이라도 나한테 안 맞으면 씋모가 없는 거라고 생각합니다. .. 저를 성장시킨건 8할이 `호기심`이었습니다

p69
..
그래서 '왜 안되지?' 또는 그반대로 '왜 되지?'라는 질문을 던지는 일이 저에게 아주 즐겁습니다. 질문이 던져지면 호기심에 깊이 파고 깊이 파면 그만큼 더 알게 되기 때문입니다 (😂)

..
코드를 분석하는데 적지 않은 공력이 듭니다. 지속적으로 코드를 분석하면 어느 순간 도서백편의자현이라는 말처럼 조금씩 코드를 분석하는 힘이 쌓일 겁니다. 저처럼 오류를 통해서 새로운 것을 배우고, 호기심을 충적시키는 학습이 즐거움이 되길 바랍니다.

**📚 도서추천**
- 학문의 즐거움
- 리눅스 그냥 재미로
- Release It


## 03. 소프트웨어 디자인 원칙 

우리는 소프트웨어 설계에 관한 한 정말 잘못 배웠습니다.  처음부터 끝까지 완전히 관계 없는걸 배웠습니다. 
이전 몇 세대부터 고착되어 어떻게 해볼 수 없이 커져버린 이론들과 잘못도니 모범 사례들이 고착되었습니다. 

프로그램을 작성하는 행위인 코딩 자체에 대한 원칙, 그중에서도 아주 작은 단위의 코드에 적영되는 원칙을 많이 들어봤을 겁니다. 

- `KISS`: 제발 간단하게 클래스나 메서드를 만들라는 법칙
- `DRY`: 반복되는 기능이나 객체를 하나로 만들어서 관리하라는 법칙 
- `YAGNI`: 코드를 적어나가다 보면 갑자기 머릿속에서 떠오르는 필요한 기능이 있어서 막 적지만 결국 안 쓴다는 법칙

// 이러한 원칙이 무조건 맞다고는 할 수 없다. 언제가는 유연성, 확작성, 유지보수성을 위한 다섯가지 원칙의 앞 글자만 따서 

로버트 C.마틴 SOLID <클린 소프트웨어>에서 주장한 프로그램의 유연성, 확장성, 유지보수성을 위한 다섯 가지 원칙의 앞글자만 따서 마이클 페더스가 명명한 원칙이다 

- `SRP` : 단인책임원칙, 각 클래스는 하나의 정보만을 가지게 만들어야 되고, 각 클래스에서 공통적인 특성을 뽑아낼 수 있다면 하나의 슈퍼세트 클래스로 옮긴 다음 변화하는 특성만 상속이나 구현으로 처리하는 원칙 
- `OCP`: 확장에는 열려 있으며 변경에는 닫혀 있어야 한다는 개방 폐쇄 원칙
- `LSP`: 인터페이스의 서브타이핑은 인터페이스에 정의된 형태를 최대한 유지해야 한다는 리스코프 치환원칙
- `ISP`: 인터페이스는 최소환으로 유지하라는 인터페이스 분리 원칙 
- `DIP`: 상위 레벨의 모듈이나 인터페이스가 서브 클래스나 타이핑에 영향을 받아서는 안된다는 의존 관계 역전 원칙 

이 다섯 가지 원칙은 소프트웨어의 유연성, 확장성, 유지보수성을 갖추게 하는 데  필요합니다. 이러한 원칙으로 이루어지지 않은 소프트웨어가 가지는 문제점을 <클린 소프트웨어>에서는 '디자인 악취'로 부르며 다음과 같은 특성이 있다고 말합니다. 

- **경직성** : 프로그램 변경이 어렵습니다. 변경하려면 시스템의 다른 부분까지 많이 변경해야 하기 때문입니다. 
- **취약성** : 프로그램을 변경하면 변경 부분과 개념적으로 아무런 연관이 없는 부분에서 장애가 발생합니다.
- **부동성**: 프로그램에서 재사용할 수 있는 컴포넌트로 구분하기가 어렵습니다. 
- **점착성** : 기존 디자인에 적용된 철학이나 방식을 지속적으로 유지하는 게 어렵거나, 개발 환경 자체가 느리고 비효율적인 경우를 말합니다. 
- **불필요한 복잡성** : 직접적인 효용이 전혀 없는 기반 구조가 디자인에 포함되어 있습니다. 
- **불필요한 반복**: 단일 추상 개념으로 통합할 수 있는 반복적인 구조가 디자인에 포함되어 있습니다. 
- **불투명성** : 직접 만든 사람이 아닌 다른 사람이 코드를 읽고 이해하기 어렵습니다. 


p76
디자인 악취를 제거하려면 .. 정말로 원인을 제거해야 합니다. 
이런 디자인에 악취가 나는 소프트웨어 제품이 나온 이유를 이해하려면 s/w 제품을 만들 때 즈음에 발생하는 다음과 같은 가정을 고려해야 합니다. 

- s/w는 제대로 디자인하고 만들기에는 늘 시간과 사람과 돈이 부족합니다 
- s/w는 한 사람이나 팀이 처음부터 끝까지 개발하지 않고, 언젠가는 전혀 히스토리를 모르는 사람이 개발을 맡게 됩니다. 
- s/w는 한번 만들어지고 나면 아주 오랫동안 사용됩니다
- 이미 릴리즈된 s/w는 다음 버전이나 개선 때 더 빨리 만들 수 잇다고 믿습니다. 
- s/w 세계에서 변하지 않는 건 '시간/사람/돈에 대한 결핍' 외에는 아무것도 없습니다 
- s/w에 대한 요구사항은 의도적이든 아니면 자연적이든 시간이 지남에 따라 늘 변합니다. ⏰


p77
소프트웨어나 프로그램을 둘러싼 상황이 늘 가변적이고 리소스가 계속 부족한 상태에서 코드를 만들어 완성해야 하는 일이 세상 모든 곳에서 발생합니다. 그리고 많은 사람이 망각의 축복을 만끽하는 바람에 하나의 기능이나 완결된 버전의 소프트웨어를 만들고 나면 그 이후에 발생하는 많은 요구샇오가 복잡한 기능을 더 적은 리소스를 투입해 해결하려고 합니다. **왜냐하면 이미 적은 리소스를 가지고 만든 효율적인 경험이 있기 때문에 그 담은 더 쉬울거라고 상상합니다** ☠️
한번 릴리즈 된 소프트웨어는 시간이 지날수록 <릴리즈가 되면 될수록> 커집니다. 
.. 그래서 굉장히 당연하게도 그 다음 버전이나 기능의 완성은 느려질 수 밖에 없는데도 다음 버전을 만들 땐 더 빨리 더 효과적으로 만들수 있다고 생각합니다 >> 착각이네 
