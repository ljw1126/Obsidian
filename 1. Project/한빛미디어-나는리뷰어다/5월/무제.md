
- 멀티패러다임 프로그래밍


- 반복자 패턴에 대해 설명해보자 
- NodeList와 Array, Set, Map 자료구조에 대한 내용이 인상 깊다 
	- 상속을 사용하면 복잡한 의존성으로 인해 고유의 특성이 사라지게 된다함
	- 인터페이스 규격을 정해 놓고 구현을 함으로써 다형성 유지
		- 이때 인터페이스가 이터러블 프로토콜
		- 그리고 이터러블 프로토콜은 반복자 패턴을 기반으로 함
	- 이터러블 프로토콜로 구현되어 있기 때문에 고차 함수 통해 활용 가능하다는 거네
		- 규격이 맞춰져 있으니!!

p110

인터페이스 관계를 살펴보고 Array, Map, Set이 이터러블로 조회가능한 것을 확인한다
첫 `next()` 호출한 이후에 반복문 통해 조회하면 순서를 기억하고 있어 다음거 값이 출력됨

p118
구조 분해 할당 
- map의 entries() 호출하면 `const [key, value]` 형태로 구조할당 가능

`naturals()` ? 뭐지 typscript, js 둘다 검색이 안됨😂

코드1-33 map 함수를 직접 구현
- `yield` 키워드와 `function*` 표시를 모르겠음
- MDN
	- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*
	- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/yield
		- yield 키워드는 제네레이터 버전의 return이라 할 수 있다 함

일반 함수 ➡️ 이터레이터
제네레이터 ➡️ 이터레이터
일반 함수로 만든 이터레이터를 제네레이터에 전달하거나 반대로도 가능하다는 것을 확인함


**1.4 이터러블을 다루는 함수형 프로그래밍**
- forEach, map, filter를 직접 구현 해 봄

✨**keyword**. 이터러블 프로토콜

> 패턴에 익숙해지면 함수형 프로그래밍의 고차 함수를 구현할 수 있다

참고. [고차 함수에 대해 ](https://velog.io/@thyoondev/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98higher-order-function%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)


> 이터레이터는 평가가 지연된 객체입니다

지금까지 foreach, map, filter 통해 이터레이터와 고차 함수를 깊이 살펴봄


**1.5 이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유**
- 상속과 인터페이스의 차이에 대한 내용이 유익

**1.5.2 이터러블을 사용하는 이유**

p153 NodeList나 다른 자료구조가 Array 상속하지 않고 인터페이스를 구현하는 이유에 대해 각 개별로 특성이 다르기 때문에 Array 상속에 의존하면 불필요한 의존성이 생기고 최적화가 어려울 수 있다 함 ✅✨

Array, Set, Map의 특성을 간단히 살펴보고 구조적 차이로 인해 Array에 의존하는건 부자연스럽고 비효율적이라는  결론이 너무 부드럽네 


**공통 로직을 공유하는 방법**
- 이터러블 프로토콜 사용 ! 
	- 유연한 확장성을 제공한 
	- NodeList와 Map,Set,Array 자료구조는 다른 구현체
- 이터러블 프로토콜은 **반복자 패턴**을 기반으로 한다


**1.5.3 인터페이스와 상속**
- 인터페이스와 상속의 비교 👍 (내용 좋다)
- 인터페이스와 상속의 목적이 다르다는걸 설명하고 결국 목적과 상황에 맞게 적절한 선택을 하는게 좋은 코드로 나아가는 첫걸음이라 한다✨


**1.6 요약 정리**
p161 감탄의 연속이다 

---
p170
