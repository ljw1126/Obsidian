
- 멀티패러다임 프로그래밍


- 반복자 패턴에 대해 설명해보자 
- NodeList와 Array, Set, Map 자료구조에 대한 내용이 인상 깊다 (`1.5.2`)
	- 상속을 사용하면 복잡한 의존성으로 인해 고유의 특성이 사라지게 된다함
	- 인터페이스 규격을 정해 놓고 구현을 함으로써 다형성 유지
		- 이때 인터페이스가 이터러블 프로토콜
		- 그리고 이터러블 프로토콜은 반복자 패턴을 기반으로 함
	- 이터러블 프로토콜로 구현되어 있기 때문에 고차 함수 통해 활용 가능하다는 거네
		- 규격이 맞춰져 있으니!!
- p200 `[Symbol.iterator]()` 메서드를 통해 이터러블을 이터레이터 함수로 변환
	- 이터러블, 이터레이터에 대한 개념 정리 앞장에 있었는데 서술형인거 찾기!

// p175 책을 읽으면서 부드럽다는 느낌을 받음 . 이런게 있고 이러해서 이러한 장점이 있다.

```typescript
interface IteratorYieldResult<T> {
	done?: false;
	value: T;
}

interface IteratorRetunResult {
	done: true;
	value: undefined;
}

interface Iterator<T> {
	next(): IteratorYieldResult<T> | IteratorRetunResult;
}

interface Iterable<T> {
	[Symbol.iterator](): Iterator<T>;
}

interface IterableIterator<T> extends Iterator<T> {
	[Symbol.iterator](): IterableIterator<T>
}
```
- `iterator`
	- `{value, done}` 객체를 반환하는 next() 메서드를 가진 값(?)
- `iterable`
	- 이터레이터를 반환하는 `[Symbol.iterator]()` 메서드를 가진 값
- `IterableIterator`
	- 이터레이터이면서 이터러블인 값
- `이터레이션 프로토콜`
	- 이터러블을 for...of문, 전개 연산자 등과 함께 동작하도록 한 규약 



p110

인터페이스 관계를 살펴보고 Array, Map, Set이 이터러블로 조회가능한 것을 확인한다
첫 `next()` 호출한 이후에 반복문 통해 조회하면 순서를 기억하고 있어 다음거 값이 출력됨

p118
구조 분해 할당 
- map의 entries() 호출하면 `const [key, value]` 형태로 구조할당 가능

`naturals()` ? 뭐지 typscript, js 둘다 검색이 안됨😂

코드1-33 map 함수를 직접 구현
- `yield` 키워드와 `function*` 표시를 모르겠음
- MDN
	- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*
	- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/yield
		- yield 키워드는 제네레이터 버전의 return이라 할 수 있다 함

일반 함수 ➡️ 이터레이터
제네레이터 ➡️ 이터레이터
일반 함수로 만든 이터레이터를 제네레이터에 전달하거나 반대로도 가능하다는 것을 확인함


**1.4 이터러블을 다루는 함수형 프로그래밍**
- forEach, map, filter를 직접 구현 해 봄

✨**keyword**. 이터러블 프로토콜

> 패턴에 익숙해지면 함수형 프로그래밍의 고차 함수를 구현할 수 있다

참고. [고차 함수에 대해 ](https://velog.io/@thyoondev/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98higher-order-function%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)


> 이터레이터는 평가가 지연된 객체입니다

지금까지 foreach, map, filter 통해 이터레이터와 고차 함수를 깊이 살펴봄


**1.5 이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유**
- 상속과 인터페이스의 차이에 대한 내용이 유익

**1.5.2 이터러블을 사용하는 이유**

p153 NodeList나 다른 자료구조가 Array 상속하지 않고 인터페이스를 구현하는 이유에 대해 각 개별로 특성이 다르기 때문에 Array 상속에 의존하면 불필요한 의존성이 생기고 최적화가 어려울 수 있다 함 ✅✨

Array, Set, Map의 특성을 간단히 살펴보고 구조적 차이로 인해 Array에 의존하는건 부자연스럽고 비효율적이라는  결론이 너무 부드럽네 


**공통 로직을 공유하는 방법**
- 이터러블 프로토콜 사용 ! 
	- 유연한 확장성을 제공한 
	- NodeList와 Map,Set,Array 자료구조는 다른 구현체
- 이터러블 프로토콜은 **반복자 패턴**을 기반으로 한다


**1.5.3 인터페이스와 상속**
- 인터페이스와 상속의 비교 👍 (내용 좋다)
- 인터페이스와 상속의 목적이 다르다는걸 설명하고 결국 목적과 상황에 맞게 적절한 선택을 하는게 좋은 코드로 나아가는 첫걸음이라 한다✨


**1.6 요약 정리**
p161 감탄의 연속이다 

---
p170
## 2장

**2.1 타입 추론과 함수 타입 그리고 제네릭**
- TS는 
	- JS에 강력한 타입 시스템을 추가하여 코드 안정성과 가독성을 높임
	- 타입 추론을 통해 개발자는 명시적인 타입 선언 없이도 안전한 코드를 작성 가능
	- 고차 함수와 제네릭을 활용하면 복잡한 함수형 프로그래밍 패턴을 구현할 수 있다
	- 또한, 객체 지향 클래스와 함수형 함수의 결합을 통해 더욱 유연하고 강력한 코드를 작성 가능


변수, 객체 속성, 함수 인자 타입 추론 

고차 함수에서도 타입 추론이 동작하므로 인자로 전달받은 함수의 인자 타입을 추론할 수 있다 
이를 통해 애로우 함수로 간결하게 작성 가능 (간결함 + 타입 안정성 확보)

제네릭을 통한 타입 추록

> TS의 타입 추론은 코드의 가독성과 안정성을 높이는데 중요한 역할을 합니다
> 이러한 방식 덕분에 개발자는 타입 시스템을 도입하고도 높은 생산성을 유지할 수 있습니다.


함수의 타입을 정의하는 여러 가지 방법 
- 먼저 함수에 명시적으로 지정
	- 함수 `오버로드`를 지원하여 동일한 함수명으로 다양한 시그니처를 정의
		- 입력과 반환 타입을 여러 가지로 지정할 수 있다

> TS에서는 타입 가드에 의한 타입 좁히기로 타입을 정확히 구분하고 추론 (`typeof` 키워드로 조건문 분기)


constant와 제네릭에서 
- 함수를 선언해서 변수에 넣음 
- 함수는 반환값을 함수로 반환함 
	- 구조가 특이하네 👀


**2.2 멀티패러다임 언어에서 함수형 타입 시스템**
- 이터러블 헬퍼 함수에 타입 시스템을 적용하면서 멀티- 언어에서의 함수형 타입 시스템에 대해 알아봄 


`Symbol.iterator`
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator

**2.2.1 이터레이션 프로토콜과 타입 다시 보기** (인터페이스 규격 다시 살펴봄👀)

**2.2.2 함수형 고차 함수와 타입 시스템**
반복자 패턴을 활용한 함수형 고차 함수들은 이터러블 자료구조를 중심으로 구성되므로 
이를 `이터러블 헬퍼 함수`라고 부를 수 있..

함수의 타입을 정의할 떄 반환 타입만 작성하는게 눈에 띈다 (코드 2-18)
```typescript
function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {
	for(const a iterable) {
		f(a);
	}
}
```


제네레이터 `funtion*` 과 한쌍이 `yield` 이고, yield는 제네레이터 안의 return 문 역할


forEach, map, filter에 대한 고차 함수(=함수를 값으로 사용하여 인자에 주입 가능) 다룸
- map, filter는 제네레이터 선언을 통해 yield 에서 결과 반환
- `제네릭` 선언 하는게 눈에 띈다

p196 r**educe와 타입** (직접 해보기👍, 타입추론 생각하는게 재미있네)

코드 2-22에서 reduce 오버로드 여러가지를 보여준다
- 첫 고비 😂 코드가 읽기 쉽지 않다
- `Iterable<A>` 타입인자를 받아 `[Symbol.iterator]()` 메서드를 실행해 이터레이터로 변환 ✅
	- 이터레이터와 이터러블에 대한 개념 정리가 앞장에 있었는데 추가하면 좋을 듯하다

reduce에서 에러를 타입는 방법을 살펴봄 (4가지)

코드 2-23. map + filter + forEach


**2.3 멀티패러다임 언어와 메타프로그래밍 - LISP로부터**

이번 절에서는 제네릭, 일급 함수, 클래스, 이터러블 프로토콜 등 다양한 언어 기능을 조합해 
유연하고 확장성 높은 추상화를 구축하는 과정을 살펴봄

> [!info]메타프로그래밍
> 프로그램이 자기 자신이나 다른 프로그램을 데이터처럼 바라보며 분서, 변형, 생성하거나 실행하는 프로그래밍 기법을 의미

p213 고차함수 인자 순서도 다 설계 된 거구나 👀


**2.3.2 클래스와 고차 함수, 반복자, 타입 시스템을 조합하기**

필드 정의하는 코드와 값을 할당하는 코드를 생략 가능 ➡️ iterable 필드가 클래스 내부에 자동으로 생성됨
```typescript
class FxIterable<A> {
	constructor(private iterable: Iterable<A>) {}
}
```

코드 2-32에서 함수 중첩, 파이프 오퍼레이터, 체이닝 방식을 살펴보는데 구조가 동일하다 
- 체이닝 방식: 직관적인 메서드 호출 통해 가독성 높음(직관적이고)
	- 그리고 유지보수할 부분도 메서드별로 명확하네

// 이터러블 생성해주는 팩터리 헬퍼 함수와 map, filter, forEach를 클래스 멤버 함수로 다뤄봄 (+제네릭)
// 직접 해보기

p222 **reduce 메서드 만들기**
// 직접 해보기

코드 2-34해서 함수 오버로드는 여러개이고 구현은 하나네?! (신기하다, 알아보자)
// reduce는 자체 함수인가?? 구현이 없는데?


**2.3.3 LISP(클로저)에서 배우기 - 코드가 데이터, 데이터가 코드**
- LISP 특징은 
	- `코드가 데이터이고 데이터가 코드`라는 개념
	- 결과적으로 프로그램이 동적으로 새로운 코드를 생성하고 실행할 수 있어 메타 프로그래밍을 비롯한 다양한 고급 기법을 손쉽게 구현 가능
	- 코드의 유연성과 확장성을 극대화하는 기반이 됨
- 클로저는
	- 블라블라

👀클로저 시작하기 - S - 표현식


p232 2.3.4 클로저에서 map이 실행될 때
- **리더 매크로**
	- 클로저와 같은 언어가 소스 코드를 읽는 단계에서 특정 기호나 패턴을 미리 정해진 

2.3.6 LISP의 확장성 .. 
- 문법 도저히 모르겠다 ㅋㅋ 

test body는 매크로로 전달되는 `'코드 조각'` 이며 unless 매크로는 코드 조각들을 재구성하여 컴파일 타임에 새로운 코드를 `'뱉어내는'` 역할을 합니다

> [!note] LISP 계열의 언어 특성으로 프로그램의 구문을 데이터 구조로 표현하고 이를 지연된 값처럼 다룰 수 있다. >> 컴파일 타임에 코드를 데이터로 보고 


p245
- reject 메서드를 FxIterable에 추가하기 
- 타입스크립트 코드와 클러저 코드를 비교한다 👀


코드, 객체, 함수가 협력하여 구현한 언어의 확장 
- 구조 분해 할당 : 명령형 문법
- 메서드 체이닝 패턴 : 객체 지향 디자인 패턴
- 고차함수 : 함수형 

> 이터레이션 프로토콜을 매개로 긴밀하게 협력하여 마치 언어를 확장한 것 같은 높은 수준의 추상화와 유연성을 확보하는 과정을 삼펴봄


p251
toArray()와 같이 기능 확장을 위한 to 메서드 예시 👀

코드 2-55 chain + Set 예시 코드 좋다 👍 (직접 해보기)

p263 정리하자면
- 클래스 기반 반복자 패턴에 최근 일급 함수가 결합되면서 다양한 언어들이 멀티패러다임 언어로 진화
- 또한 이터레이션 프로토콜의 도입으로 일관되고 표준화된 방식으로 언어 기능을 확장할 수 있게 됨
- 그 결과 개발자는 언어 스펙이나 컴파일러를 변경하지 않고도 클래스와 함수형 고차 함수, 객체지향 패턴, 제네릭, 커링, 이터러블 프로토콜 등을 유기적으로 결합하여 고도화된 추상화와 언어 확장 효과를 얻을 수 있다.

마지막 말이 좋네 `결과적으로` 이후 (생략)

**2.4 요약 정리**
p265

---
## 3장 코드:객체:함수 = Generator:Iterator:LISP = IP:OOP:FP
- `IP` : 명령형 프로그래밍
- `FP` : 함수형 프로그래밍

| 제네레이터는 명령형 코드로 이터레이터 생성 
- `function*` , `yield` 말하는 듯 
- 효과에 대해 설명 ✅

| 이터레이터는 반복자 패턴의 구현체 
// 생략 

| 이터러블 이터레이터는 명령형, 객체 지향형, 함수형으로 다룰 수 있음

| 이터레이터 생성방식의 다양화 
- 직접 이터레이터 객체를 구현하거나 명령형 스타일로 (제네레이터 사용, 위에) 생성 가능 
- 또한 .. 함수형 스타일도 가능(3장에서 다룰 예정)


>[!note] 이터레이터 만드는 방식 
>- 명령형 방식(IP) : 제네레이터를 통한 이터레이터 생성
>- 객체지향적 방식(OOP) : 이터레이터 객체 직접 구현 
>- 함수형 방식(FP) : 리스트 프로세싱 함수 조합으로 이터레이터 생성 


### 3.1 코드가 곧 데이터 - 로직이 담긴 리스트 
// **리스트로 사고** 한다는게 키워드네 .. 
// 이터러블 이터레이터 개념 정리를 잘해두면 나중에 봐도 안 잊어 버릴 듯하다 


코드 3-1. n개의 홀수를 제곱하여 모두 더하기 (시작)

코드 3-2. if를 filter로 대체 
- `if(a % 2 === 1) {}`로 코드의 실행을 제어하는 '코드 문장'을 filter가 적영된 '리스트'로 변경

코드 3-3 map으로 대체한 코드 
- 홀수 제곱처리를 map으로 대체 

코드 3-4. Scheme 코드 (LISP 계열, 위에 예시와 비교)

p281
> 즉 리스트는 코드이고 코드는 리스트이며 중첩된 리스트는 알고리즘이자 로직입니다 (기가 막히네)
> - 중첩된 리스트는 앞서 살펴보면 map(filter( list )) 요런 구조

// 언어를 이러한 철학을 기반으로 해석할 수 있다는게 놀랍다 

주 언어로 사용하는 TS는 LISP와 문법만 약간 다를 뿐 이터러블과 이터레이터를 활용한 이터레이션 프로토콜을 기반으로 이러한 패러다임을 그대로 적용 가능 ..


코드 3-5. break를 take로 대체
- take 제네레이터 함수 내부에서 이터레이터를 호출해서 처리를 하네
- 여기서는 take를 통해 break와 같은 제어문 마저도 리스트로 사고할 수 있음 확인 (크...)

코드 3-6. 합산을 reduce로 대체 

코드 3-7. 체이닝으로 변경


p288 지금까지 명령형 코드를 함수형 프로그래밍 방식으로 변경 해봄 ✅ **(직접 해보기)**


3.1.2 현대 언어에서 리스트 프로세싱 .. 
- 다른 언어에서 동일한 코드를 어떻게 구현하는지 살펴봄 👀 (눈으로만)

**클로저**는 함수형 프로그래밍 패러다임에 중점을 둔 언어

> 와 .. 언어를 8개나 아네 .. 
> JS, TS, Java, Kotlin, Swift, Scala, Closure, C#

p301 
결국 객체지향, 명령형, 함수형 패러다임을 결합한 멀티패러다임적 사고와 문제 해결 능력은 특정 언어에 국한되지 않습니다. (..) 책에서 다루는 개념과 원칙 역시 이러한 언어 전반에 적용할 수 있으며 다양한 환경에서 더욱 안전하고 효율적인 코드를 구현하는 데 기여할 것입니다. 

// 이 사람들은 전혀 다른 세계에 살고 있구나 .. 작성한 코드를 해석해서 변환해주는 컴파일러까지 섭렵한 사람이네..


### 3.2 하스켈로 배우기 
- 순수 함수형 프로그래밍 언어로 평가됨
- 함수형 패러다임을 잘 반영하록 설계된 문법을 가짐
- 순수 함수와 함수합성을 강조
- 커링 기본, 지연 평가 지원, 부수 효과를 특별하게 관리함 


---
2.3.5 띄어쓰기 오타 p235