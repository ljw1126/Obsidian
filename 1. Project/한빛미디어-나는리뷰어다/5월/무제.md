
- 멀티패러다임 프로그래밍


- 반복자 패턴에 대해 설명해보자 
- NodeList와 Array, Set, Map 자료구조에 대한 내용이 인상 깊다 (`1.5.2`)
	- 상속을 사용하면 복잡한 의존성으로 인해 고유의 특성이 사라지게 된다함
	- 인터페이스 규격을 정해 놓고 구현을 함으로써 다형성 유지
		- 이때 인터페이스가 이터러블 프로토콜
		- 그리고 이터러블 프로토콜은 반복자 패턴을 기반으로 함
	- 이터러블 프로토콜로 구현되어 있기 때문에 고차 함수 통해 활용 가능하다는 거네
		- 규격이 맞춰져 있으니!!
- p200 `[Symbol.iterator]()` 메서드를 통해 이터러블을 이터레이터 함수로 변환
	- 이터러블, 이터레이터에 대한 개념 정리 앞장에 있었는데 서술형인거 찾기!

// p175 책을 읽으면서 부드럽다는 느낌을 받음 . 이런게 있고 이러해서 이러한 장점이 있다.

p110

인터페이스 관계를 살펴보고 Array, Map, Set이 이터러블로 조회가능한 것을 확인한다
첫 `next()` 호출한 이후에 반복문 통해 조회하면 순서를 기억하고 있어 다음거 값이 출력됨

p118
구조 분해 할당 
- map의 entries() 호출하면 `const [key, value]` 형태로 구조할당 가능

`naturals()` ? 뭐지 typscript, js 둘다 검색이 안됨😂

코드1-33 map 함수를 직접 구현
- `yield` 키워드와 `function*` 표시를 모르겠음
- MDN
	- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*
	- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/yield
		- yield 키워드는 제네레이터 버전의 return이라 할 수 있다 함

일반 함수 ➡️ 이터레이터
제네레이터 ➡️ 이터레이터
일반 함수로 만든 이터레이터를 제네레이터에 전달하거나 반대로도 가능하다는 것을 확인함


**1.4 이터러블을 다루는 함수형 프로그래밍**
- forEach, map, filter를 직접 구현 해 봄

✨**keyword**. 이터러블 프로토콜

> 패턴에 익숙해지면 함수형 프로그래밍의 고차 함수를 구현할 수 있다

참고. [고차 함수에 대해 ](https://velog.io/@thyoondev/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98higher-order-function%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)


> 이터레이터는 평가가 지연된 객체입니다

지금까지 foreach, map, filter 통해 이터레이터와 고차 함수를 깊이 살펴봄


**1.5 이터러블 프로토콜이 상속이 아닌 인터페이스로 설계된 이유**
- 상속과 인터페이스의 차이에 대한 내용이 유익

**1.5.2 이터러블을 사용하는 이유**

p153 NodeList나 다른 자료구조가 Array 상속하지 않고 인터페이스를 구현하는 이유에 대해 각 개별로 특성이 다르기 때문에 Array 상속에 의존하면 불필요한 의존성이 생기고 최적화가 어려울 수 있다 함 ✅✨

Array, Set, Map의 특성을 간단히 살펴보고 구조적 차이로 인해 Array에 의존하는건 부자연스럽고 비효율적이라는  결론이 너무 부드럽네 


**공통 로직을 공유하는 방법**
- 이터러블 프로토콜 사용 ! 
	- 유연한 확장성을 제공한 
	- NodeList와 Map,Set,Array 자료구조는 다른 구현체
- 이터러블 프로토콜은 **반복자 패턴**을 기반으로 한다


**1.5.3 인터페이스와 상속**
- 인터페이스와 상속의 비교 👍 (내용 좋다)
- 인터페이스와 상속의 목적이 다르다는걸 설명하고 결국 목적과 상황에 맞게 적절한 선택을 하는게 좋은 코드로 나아가는 첫걸음이라 한다✨


**1.6 요약 정리**
p161 감탄의 연속이다 

---
p170


**2.1 타입 추론과 함수 타입 그리고 제네릭**
- TS는 
	- JS에 강력한 타입 시스템을 추가하여 코드 안정성과 가독성을 높임
	- 타입 추론을 통해 개발자는 명시적인 타입 선언 없이도 안전한 코드를 작성 가능
	- 고차 함수와 제네릭을 활용하면 복잡한 함수형 프로그래밍 패턴을 구현할 수 있다
	- 또한, 객체 지향 클래스와 함수형 함수의 결합을 통해 더욱 유연하고 강력한 코드를 작성 가능


변수, 객체 속성, 함수 인자 타입 추론 

고차 함수에서도 타입 추론이 동작하므로 인자로 전달받은 함수의 인자 타입을 추론할 수 있다 
이를 통해 애로우 함수로 간결하게 작성 가능 (간결함 + 타입 안정성 확보)

제네릭을 통한 타입 추록

> TS의 타입 추론은 코드의 가독성과 안정성을 높이는데 중요한 역할을 합니다
> 이러한 방식 덕분에 개발자는 타입 시스템을 도입하고도 높은 생산성을 유지할 수 있습니다.


함수의 타입을 정의하는 여러 가지 방법 
- 먼저 함수에 명시적으로 지정
	- 함수 `오버로드`를 지원하여 동일한 함수명으로 다양한 시그니처를 정의
		- 입력과 반환 타입을 여러 가지로 지정할 수 있다

> TS에서는 타입 가드에 의한 타입 좁히기로 타입을 정확히 구분하고 추론 (`typeof` 키워드로 조건문 분기)


constant와 제네릭에서 
- 함수를 선언해서 변수에 넣음 
- 함수는 반환값을 함수로 반환함 
	- 구조가 특이하네 👀


**2.2 멀티패러다임 언어에서 함수형 타입 시스템**
- 이터러블 헬퍼 함수에 타입 시스템을 적용하면서 멀티- 언어에서의 함수형 타입 시스템에 대해 알아봄 


`Symbol.iterator`
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator

**2.2.1 이터레이션 프로토콜과 타입 다시 보기** (인터페이스 규격 다시 살펴봄👀)

**2.2.2 함수형 고차 함수와 타입 시스템**
반복자 패턴을 활용한 함수형 고차 함수들은 이터러블 자료구조를 중심으로 구성되므로 
이를 `이터러블 헬퍼 함수`라고 부를 수 있..

함수의 타입을 정의할 떄 반환 타입만 작성하는게 눈에 띈다 (코드 2-18)
```typescript
function forEach<A>(f: (a: A) => void, iterable: Iterable<A>): void {
	for(const a iterable) {
		f(a);
	}
}
```


제네레이터 `funtion*` 과 한쌍이 `yield` 이고, yield는 제네레이터 안의 return 문 역할


forEach, map, filter에 대한 고차 함수(=함수를 값으로 사용하여 인자에 주입 가능) 다룸
- map, filter는 제네레이터 선언을 통해 yield 에서 결과 반환
- `제네릭` 선언 하는게 눈에 띈다

p196 r**educe와 타입** (직접 해보기👍, 타입추론 생각하는게 재미있네)

코드 2-22에서 reduce 오버로드 여러가지를 보여준다
- 첫 고비 😂 코드가 읽기 쉽지 않다
- `Iterable<A>` 타입인자를 받아 `[Symbol.iterator]()` 메서드를 실행해 이터레이터로 변환 ✅
	- 이터레이터와 이터러블에 대한 개념 정리가 앞장에 있었는데 추가하면 좋을 듯하다

reduce에서 에러를 타입는 방법을 살펴봄 (4가지)

코드 2-23. map + filter + forEach


**2.3 멀티패러다임 언어와 메타프로그래밍 - LISP로부터**

이번 절에서는 제네릭, 일급 함수, 클래스, 이터러블 프로토콜 등 다양한 언어 기능을 조합해 
유연하고 확장성 높은 추상화를 구축하는 과정을 살펴봄

> [!info]메타프로그래밍
> 프로그램이 자기 자신이나 다른 프로그램을 데이터처럼 바라보며 분서, 변형, 생성하거나 실행하는 프로그래밍 기법을 의미

p213 고차함수 인자 순서도 다 설계 된 거구나 👀


**2.3.2 클래스와 고차 함수, 반복자, 타입 시스템을 조합하기**

필드 정의하는 코드와 값을 할당하는 코드를 생략 가능 ➡️ iterable 필드가 클래스 내부에 자동으로 생성됨
```typescript
class FxIterable<A> {
	constructor(private iterable: Iterable<A>) {}
}
```

코드 2-32에서 함수 중첩, 파이프 오퍼레이터, 체이닝 방식을 살펴보는데 구조가 동일하다 
- 체이닝 방식: 직관적인 메서드 호출 통해 가독성 높음(직관적이고)
	- 그리고 유지보수할 부분도 메서드별로 명확하네

// 이터러블 생성해주는 팩터리 헬퍼 함수와 map, filter, forEach를 클래스 멤버 함수로 다뤄봄 (+제네릭)
// 직접 해보기

p222 **reduce 메서드 만들기**
// 직접 해보기

코드 2-34해서 함수 오버로드는 여러개이고 구현은 하나네?! (신기하다, 알아보자)
// reduce는 자체 함수인가?? 구현이 없는데?


**2.3.3 LISP(클로저)에서 배우기 - 코드가 데이터, 데이터가 코드**
- LISP 특징은 
	- `코드가 데이터이고 데이터가 코드`라는 개념
	- 결과적으로 프로그램이 동적으로 새로운 코드를 생성하고 실행할 수 있어 메타 프로그래밍을 비롯한 다양한 고급 기법을 손쉽게 구현 가능
	- 코드의 유연성과 확장성을 극대화하는 기반이 됨
- 클로저는
	- 블라블라

👀클로저 시작하기 - S - 표현식