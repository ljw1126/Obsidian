
| 1일  | ~60p  |
| --- | ----- |
| 2일  | ~100p |
| 3일  | 150p  |
| 4일  | 200p  |
| 5일  | ~250p |



파이썬으로 예제 작성

p26 
**실행 시간(running time)**
원하는 숫자를 찾을 때
- **선형 시간 (linear time)** : 100개 원소 중 100번 추측, 만약 40억개면 40억 번 추측
- **로그 시간(logarithmic time)** : 100개가 있다면 <u>7번</u>만 추측 

p29
**빅오 표기법**
- 알고리즘이 얼마나 빠른지 말해줌
- 연산 횟수를 비교하기 위한 것이므로 수행해야 할 일이 많아질 때 알고리즘에 걸리는 시간이 어떤 식으로 증가하는지 알 수 있습니다.
- 선형 탐색 : O(N) , 이진탐색: O(logN)
- 최악의 경우에 대한 표기

p33 빅오 표기법 그림이 귀엽다
p34 외판원 문제 (traveling salesperson problem)
p37 연습 문제 
1-1. 2^128 = 7 
1-2. 8
2-1. O(logN)
2-2. O(N) // 최악의 경우를 고려?
2-3. O(N)
2-4. ~~O(1)~~ > O(N) 


## Ch2. 선택 정렬
p41 
배열과 리스트는 각각 장단점이 있습니다. 두 방식의 차이점을 잘 알고 있어야 경우에 맞게 선택하여 사용할 수 있습니다. 

배열 - 고정 길이, 런타임 변경 불가능, 직접 새로 생성해야 복사해야함
리스트 - 동적 길이, 런타임 변화가능, copy and shift 비용 발생, 기본 사이즈랑 증가 사이즈가 몇이었지

p43
연결리스트(linked list)를 극장 좌석 예약으로 설명하는게 not bad
내가 생각하는 장단점
- 장점: 공간 제약이 없다, 추가/삭제의 경우 연결 노드의 포인터만 변경하면 되서 대부분 O(1) // 이때 조회 시간이 필요하기도 하다
- 단점: 검색시 순차적으로 조회해야 해서 O(N), 힙 메모리에 저장되는데 메모리 해제를 잘 하지 못하면 memory leak 발생 가능

배열 단점을 고양이 그림으로 귀엽게 설명하네 ㅋㅋ

배열은 인덱스로 바로 빠르게 접근가능

p46
원소의 위치를 **인덱스** 라고 한다
배열과 리스트의 시간 복잡도 

p47
중간에 데이터 삽입하는데 배열과 리스트를 비교함 
<u>그런데 리스트가 연결리스트라서 혼동있어보임 (ArrayList도 있고 구현체는 다른데)</u>

p49
배열과 리스트의 읽기/삽입/삭제에 대한 시간 복잡도 비교 표

배열과 연결 리스트 중 더 자주 쓰는것은?
- 임의 접근(random access) 가능한 배열이 더 자주 사용
	- 연결리스트는 순차 접근(sequential access)을 해야 하니
	- <u>배열은 순차 접근도 빠르다!</u>
- 공간 측면에서는 연결 리스트가 포인터만 가지고 있으면 되서 나음 (배열은 불필요한 공간 예약)
	- *근데 어떤 경우에서는 연결 리스트가 배열보다 많다네 ?*

p56
```py
def findSmallest(arr):
	smallest = arr[0] // 0번 인덱스와 값으로 초기화
	smallest_index = 0 
	for i range(1, len(arr)):
       if arr[i] < smallest:
         smallest = arr[i]
         smallest_index = i
	
    return smallest_index;

// 선택 정렬, 오름차순
def selectionSort(arr): 
  newArr = []
  copiedArr = list(arr)
  for i in range(len(copiedArr)):
	smallest = findSmallest(copiedArr)
	newArr.append(copiedArr.pop(smallest))

  return newArr

print(selectionSort([5, 3, 6, 2, 10]))
```


p57 2장에서 배운 내용
- 컴퓨터 메모리는 거대한 서랍장과 같습니다
- 여러 항목을 저장하고 싶을 때는 배열이나 연결리스트를 사용하세요
- 배열을 쓰면 모든 항목은 이웃하는 위치에 저장됩니다
- 연결 리스트를 쓰면 모든 항목이 흩어지지만, 각 항목이 다음 항목의 주소를 저장합니다
- 배열은 읽기가 빠릅니다 
- 연결 리스트는 삽입, 삭제가 빠릅니다

**연습문제**
1-1. 연결 리스트 사용 
1-2. 연결 리스트 사용 >> 근데 ArrayDeque에서 최적화 되면서 배열에 포인터를 사용하는 형태가 됨
2-1. 배열 사용 (임의 접근, 정렬해서 이진 탄색)
2-2. 삽입을 위한 배열에서 발생하는 단점은 공간이 부족한 경우 copy and shift 연산이 발생하겠지
이진 탐색으로 이름 검색하는 경우 범위가 늘어나겠지만 O(logN)에 찾을 수 있음
<u>추가로 신규 유저가 추가되면 정렬을 해야 하는 단점이 있음</u>
2-3. ~~26개라는 공간이 지정되어 있다면 검색과 삽입은 배열이 빠르다고 생각함. (삽입이 빠르다구?)~~
(풀이 답변)이 복합 자료구조는 검색의 경우 배열보다 느리고 연결 리스트보다는 빠릅니다. 삽입의 경우 배열보다 빠르고 연결리스트와는 같은 시간이 걸립니다. 그러니까 배열보다는 검색 시간 측면에서만 느리고 연결 리스트보다는 모든 면에서 좋거나 최소한 같습니다. (복합 자료구조 = 해시 테이블)

<u>배열과 연결리스트는 이러한 복잡한 자료구조를 만드는 기초가 됩니다</u>


## Ch3 재귀(recursion)

하나의 문제를
- 기본 단계
- 재귀 단계
- 분할 정복 전략

>[!note] 리 콜드웰 (Leigh Caldwell) - 스택 오버플로
>"프로그램에 반복문을 사용하면 프로그램의 성능을 향상시킬 수 있지만, 재귀를 사용하면 프로그래머의 능력을 향상시킬 수 있습니다. 상황에 따라 적절한 방법을 골라 사용하세요"


```python
def countdown(i):
  print(i)
  if i <= 1: // 기본 단계 
	return
  else:   // 재귀 단계
	countdown(i - 1);

countdown(3)
```
- 기본단계 (base case)
	- 함수가 자기 자신을 다시 호출하지 않는 경우
	- 종료 조건
- 재귀단계(recursive case)
	- 함수가 자기 자신을 호출하는 부분

```javascript 
const greet = (name) => { console.log(`hello, ${name}`); greet2(name); bye();}
const greet2 = (name) => {console.log('greet2');}
const bye = () => {console.log('say goodbye');}

greet('tester');

/*
hello, tester
greet2
say goodbye
*/
```

큰 상자안에 작은 상자들이 있고 열쇠를 찾는 예시를 들어서 재귀 설명

스택을 사용하면 편리하기는 하지만 그만큼의 대가를 치러야 합니다. 모든 정보를 저장해야하므로 메모리를 많이 소비하죠. 함수를 호출할 때마다 메모리를 사용하게 됩니다. 스택이 너무 커졌다는 것은 컴퓨터가 과다한 함수 호출 정보를 저장하고 있다는 뜻입니다. (stack overflow)

예제1. greet2가 마지막에 호출되고 name 변수값을 가짐, greet가 제일 처음 호출되고 name값을 가짐 >> 더이상 호출할게 없으면 greet2 -> greet  스택에서 꺼내 함수 실행 결과 반환
예제2. 스택 오버플로우가 발생

// 재귀가 중요한데.. 너무 심플하기도 하면서도 중요한 개념을 언급하고 가네

## Ch4. 퀵 정렬
- 분할 정복 전략이랑 관련있구나 
- 분할 정복 알고리즘 == 재귀 알고리즘 

>[!tip] 유클리드 알고리즘
>"만약 나머지 크기의 농장에 맞는 가장 큰 정사각형을 찾으면 이 정사각형 토지 모양으로 전체 농작을 나눌 수 있습니다"라는 말이 정말인지 명확하게 증명할 수 없어도 걱정하지 마세요
>
>유클리드 호제법 > 칸 아카데미에 좋은 설명이 있습니다
>https://www.khanacademy.org/math/geometry/hs-geo-transformations/hs-geo-intro-euclid/v/euclid-as-the-father-of-geometry


>[!tip] 함수형 프로그래밍
>(..) 재귀 함수를 잘 이해하고 있으면 함수형 프로그래밍 언어를 익히는 것이 더 쉬워집니다


퀵 정렬에서 분할(partitioning)
- 기준 원소보다 작은 숫자들로 이루어진 하위 배열 
- **기준 원소**
- 기준 원소보다 큰 숫자들로 이루어진 하위 배열
이때 배열 크기가 1인 경우 바로 반환 (종료 조건)
기준 원소를 어떻게 선별하고, 파티셔닝을 나누는지가 중요할 뿐이네  👍

p98
>[!tip] 귀납적 증명



컬렉션을 사용하는 경우 공간 복잡도는 더 잡아먹겠지만, 포인터 방식 보다는 이해가 쉽다
```java
import java.util.*;

public class QuickSortList {
    public static List<Integer> quickSort(List<Integer> list) {
        if (list.size() <= 1) {
            return list;
        }

        int pivot = list.get(list.size() / 2); // 중간값을 피벗으로 선택
        List<Integer> left = new ArrayList<>();
        List<Integer> right = new ArrayList<>();
        List<Integer> equal = new ArrayList<>();

        for (int num : list) {
            if (num < pivot) {
                left.add(num);
            } else if (num > pivot) {
                right.add(num);
            } else {
                equal.add(num);
            }
        }

        List<Integer> sorted = new ArrayList<>();
        sorted.addAll(quickSort(left));  // 재귀 호출
        sorted.addAll(equal);
        sorted.addAll(quickSort(right));
        return sorted;
    }

    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(3, 6, 8, 10, 1, 2, 1);
        List<Integer> sortedList = quickSort(new ArrayList<>(list));
        System.out.println(sortedList);
    }
}

```


**4.빅오 표기법 복습**
만약 <u>두 알고리즘의 실행 시간이 서로 다른 빅오 표기법이라면 상수는 크게 문제가 되지 않기 때문에 이런 상수는 보통 무시합니다</u>

다음과 같은 시간 복잡도를 가진 알고리즘이 있을 때
- 단순 탐색 : 10ms * n
- 이진 탐색: 1s * logn

단순히 상수만 보면 단순 탐색이 훨씬 빠를꺼라 생각하지만, 원소의 개수가 4억개 인 경우 
- 단순 탐색: 10ms * 4억개 = 463일
- 이진 탐색: 1s * 32개 = 32초
이진 탐색이 훨씬 빠른 것을 알 수 있다.👍


**평균적인 경우와 최악의 경우 비교**
- 퀵 정렬, 병합 정렬 둘다 O(nlogn) 시간 복잡도를 가짐

logN 개의 단계를 거칠 수도 있고 최악의 경우 n개의 단계를 거칠 수도 있다
이때 매번 O(n)개의 원소를 비교해야 한다. 
고로 최악의 경우 O(n^2)


p107
**4장에서 배운 내용**
- 분할 정복은 문제를 더 작은 조각으로 나누어 풉니다. 만약 리스트에 분할 정복을 적용한다면 기본단계는 원소가 없는 빈 배열이거나 원소를 하나만 가진 배열이 된다
- 퀵 정렬을 구현하려면 기준 원소를 무작위로 선택합니다. 퀵 정렬의 평균적인 실행 시간은 O(n log n)이다.
- 빅오 표기법에서 가끔씩 상수가 중요해질 때도 있습니다. 퀵 정렬이 병합 정렬보다 빠른 이유도 상수 때문이다.
- 단순 탐색과 이진 탐색을 비교할 때는 상수가 전혀 문제가 되지 않습니다. 왜냐하면 리스트가 길어지면 O(log n)이 O(n) 보다 훨씬 빨라지니까요.

**연습 문제**
1-1. 처음 나왔던 sum 함수를 작성해 보세요
```java
private int sum(int[] arr, int idx, int total) {
    if(arr.length == idx) return total;

    return sum(arr, idx + 1, total + arr[idx]);
}
```

1-2. 리스트에 포함된 원소의 숫자를 세는 재귀 함수를 작성해 보세요
```java

private int count(int[] arr, int idx) {
	if(arr.length == idx) return 0;

    return 1 + count(arr, idx + 1);
}

```


1-3. 리스트에서 가장 큰 수를 찾아보세요
```java

private int max(int[] arr, int idx, int max) {
	if(arr.length == idx) return max;

    return max(arr, idx + 1, Math.max(max, arr[idx]));
}

```


1-4. 이진 탐색에 대해 기본 단계와 재귀 단계를 찾을 수 있나요? (**??**)

2-1. O(N)
2-2. O(N)
2-3. ~~O(N)~~ , O(1)
2-4. O(N^2), 배열의 모든 원소 조합에 대해 곱셈표 만들기

## Ch5. 해시 테이블
- O(1) 시간복잡도로 조회 보장
- 임의 키값을 해시로 바꿔, 해시 주소로 값을 저장

매장에서 상품과 가격을 예시로 해시 테이블을 설명하네
### 2. 해시 함수 
예시에서 해시함수는 문자열(string, 여기에서 문자열은 임의의 데이터, 즉 바이트 열을 뜻합니다)을 받아서 숫자를 반환하는 함수입니다. // 변환해서 해시키를 반환한다는 의미인듯


> 해시 함수 + 배열 = 해시 테이블(hash table)

해시 테이블은 해시 함수를 사용해서 더 총명하게 어디에 원소를 저장할지 결정합니다
해시 테이블은<u> 해시 맵, 맵, 딕셔너리, 연관 배열</u> 이라는 이름으로도 알려져 있습니다. // 이건 처음이네
해시 테이블은 **키**(key)와 **값**(value)을 가집니다


###  3. 해시 테이블을 사용하는 예
- 이름과 전화번호 
- 도메인 주소와 ip 주소 : DNS 확인 작업과 DNS 캐시 언급

해시 테이블은 중복은 덮어 씌워지는데, 해시 키 충돌이 발생할 수 있다는건 설명안하네

**해시 테이블을 캐시로 사용하기**
캐싱의 장점 (페이스북 예시)
- 웹 페이지를 더 빨리 보여줍니다. 마치 달까지의 거리를 외우고 있을 때 처럼요. 외우고 있으면 조가가 또 물어볼 때 구글에 검색할 필요 없이 바로 대답할 수 있습니다. 
- 페이스북이 일을 덜 할 수 있습니다.
모든 대형 웹사이트는 캐싱을 사용합니다. 그리고 그 자료는 바로 <u>해시 테이블에 저장</u>됩니다

**해시 테이블의 장점**
- 어떤 것과 다른 것 사이의 관계를 모형화할 수 있습니다
- 중복을 막을 수 있습니다 
- 서버에 작업을 시키지 않고 자료를 캐싱할 수 있습니다

### 4. 충돌
예. 26개의 알파벳으로 구성된 배열이 있을 때 
- APPLES 저장 후 AVOCADOS 저장하면 키 충돌 발생

충돌을 해결하는 방법은 여러가지
- 같은 공간에 여러 키를 연결리스트로 만들어 넣는다 (체이닝 방식*, 자바 컬렉션 프레임워크에서도 사용)

a로 시작하는 단어만 추가한다면 나머지 25개 공간은 남아 돌게 된다
-> 그냥 연결 리스트에 넣는 것이나 다름없어서, 결국 해시 테이블이 느려지게 된다

**교훈**
- 이상적으로 해시 함수는 키를 해시 테이블 전체에 고르게 할당해야 합니다
- 만약 연결 리스트가 길어지면 해시 테이블의 속도도 느려집니다. 하지만 좋은 해시 함수가 있다면 일은 발생하지 않습니다.

### 5. 성능 

|     | 평균   | 최악   |
| --- | ---- | ---- |
| 탐색  | O(1) | O(n) |
| 삽입  | O(1) | O(n) |
| 삭제  | O(1) | O(n) |

참고로 단순 탐색은 선형시간, O(N)이 걸린다 

**p137 해시 테이블, 배열, 연결리스트 성능 비교 표**

최악의 경우 해시 테이블은 배열이나 연결리스트 보다 느릴 수 있다
충돌을 피하고 골고루 버킷에 데이터가 저장되려면 다음 같은 것이 필요 
- 낮은 사용률 
- 좋은 해시 함수 

**사용률 (load factor)**
- 해시 테이블에 있는 항목의 수 / 공간의 수


사용률이 1보다 크다는 것은 배열에 공간의 수보다 항목의 수가 많다는 뜻 
사용률이 커지기 시작하면 해시 테이블의 공간을 추가해야 한다
이를 리사이징(**resizing**)이라고 합니다
<u>보통은 사용률이 0.7보다 커지면 리사이징 합니다</u> // !!!!!!!!!!! 소름 돋네
해시 테이블은 리사이징해도 평균적으로 **O(1)** 시간이 걸림

**좋은 해시 함수란**
- 굳이 직접 고민할 필요 없다
- 많은 사람이 어두컴컴한 방에 앉아 좋은 해시 함수를 만들기 위한 고민을 거듭하고 있거든요
- 정말 호기심이 생긴다면 CityHash 해시 함수를 찾아보세요

p140 5장에서 배운 내용 정리

연습문제 
1번. 1-4, 입력에 대한 출력 결과가 항상 일정하다// len, 길이인게 흠이지만


2번 
2-1. D
2-2. B 문자열 길이를 인덱스로 사용하면 건전지 사이즈마다 잘 분배될 듯
2-3. D

## Ch6. 너비 우선 탐색(BFS)

- 문제를 그래프로 모형화한다  // 그래프로 정의하는게 중요, 간선과 정점
- 너비 우선 탐색이나 최단 경로 알고리즘으로 풀이한다
- 위상 정렬도 다룰 예정

p150
망고 판매상 찾기하는 예시가 귀엽네 , 큐에 다가 친구 목록을 추가한다도 인상 깊다

3촌 관계보다는 2촌 관계를, 2촌 관계보다는 1촌 관계를 선호하겠죠.
그러니깐 만약 1촌 관계인 망고 판매상이 없는 경우에만 2촌 관계를 탐색할 것이다


- 방향 그래프 (directed graph)
- 무방향 그래프(undirected graph)
- 큐를 갱신할 때
	- enqueue(삽입)
	- dequeue(삭제)

p163
중복 탐색을 피하기 위해서 set 자료구조를 사용하네

p164 실행시간
`O(사람의 수 + 간선의 수) = O(V + E)`

p168 연습 문제


## Ch7. 트리
- 깊이 우선 탐색
- 트리를 활용한 압축 알고리즘인 허프만 코딩(Huffman coding)을 배웁니다

허프만 코딩은 이진 트리를 사용합니다 
대부분 데이터베이스는 B-트리와 균현 트리(balanced tree)를 사용합니다

p171
**파일 디렉터리**를 예시로 트리를 설명

너비 우선 탐색은 **순회 알고리즘(traversal algorithm)**

p176👍
최단 경로를 찾을때 왜 너비 우선 탐색을 사용하는지 깊이 우선 탐색과 비교하여 설명

**트리에 대한 더 나은 정의**
> 트리는 엄밀하게 말해 연결된 비순환 그래프(connected acyclic graph)

p185 허프만 코딩
이진트리를 사용하는 좋은 예시

p186 👍
>[!tip] 문자 인코딩
>읽어보기, 아스키 코드(7 bit, 2^7), ISO-8859-1(8bit, 2^8가지), 유니코드 (149186개, 이모지 포함)

허프만 코딩은 사용되는 문자를 살펴보고 8비트보다 적은 비트를 사용하려고 시도합니다
```text
t = 00
i = 01
l = 10
```

허프만 코딩에서는 문자가 리프 정점에만 나타나기 때문에 문제가 되지 않습니다.
그리고 루트에서 각 리프 정점까지의 경로는 유일합니다. (경로상에 다른 알파벳이 있는 경우는 없다)

또한 각 문자에 하나의 코드만 존재하도록 보장할 수 있습니다. 하나의 문자에 대응하는 경로가 여럿이면 각 문자에 여러 코드가 할당될 수 있습니다.

**허프만 코딩**은 **트리**를 사용하므로 사이클도 없고 최종적으로 하나의 문자에 도달합니다


## Ch8. 균형 트리
- 이진 탐색 트리(BST, binary search tree)
- 균형 트리(balanced tree)에 대해 알아보고 균형 트리가 배열이나 연결 리스트보다 더 나은 성능을 보이는 이유를 알아봄
- 균형 트리의 일종인 AVL 트리에 대해서도 알아봅니다.

p196
BST는 이진 트리의 한 유형입니다
최대 두 개의 자식을 가짐
이때 왼쪽 자식은 항상 부모 정점의 값보다 작고, 오른쪽 자식은 부모 정점의 값보다 크다

평균 시간 복잡도는 O(log N) 이다. (이때 N의 트리의 높이에 해당함)
최악의 경우 한쪽으로 몰려서 O(N) 만큼의 시간 복잡도가 소요됨
-> 이를 해결하기 위해 나온게 AVL트리

### 4. AVL (균형 잡힌 BST)
p200
AVL 트리의 높이가 2가 될때 한쪽으로 쏠리는 경우 **회전**을 한다네?? 🤔

p206 AVL 트리는 언제 회전해야 하는지 어떻게 알 수 있나요?
- 트리가 스스로 균형을 잡을 시기를 알기 위해서는 몇 가지 추가 정보를 저장해야 합니다.
- 각 정점은 **높이** 또는 **균형 인수(balance factor)** 라는 두 가지 정보 중 하나를 저장합니다 
	- 이때 균형 인수의 값은 `-1, 0, 1`이 될 수 있습니다

**요약**
- 이진 트리는 트리의 한 유형입니다
- 이진 트리에서는 각 정점이 최대 두 개의 자식을 가질 수 있습니다.
- BST는 왼쪽 하위 트리의 모든 값이 정점 값보다 작고, 오른쪽의 모든 값이 정점 값보다 큰 이진 트리의 한 유형입니다
- BST는 높이가 O(log n)이 되도록 보장할 수 있다면 우수한 성능을 제공할 수 있습니다.
	- 한쪽 쏠림 현상이 발생할 경우 O(n) // 이때 n은 트리의 높이라는 듯
- AVL 트리는 자가 균형을 이루는 BST로, 높이가 `O(log n)`이 되도록 보장합니다
- AVL 트리는 **회전**을 통해 스스로 균현을 잡습니다.

### 5. 스플레이 트리
- 균형 트리의 다른 버전
- 장점은 최근에 항목을 조회한 적이 있으면 다음에 조회할 때 조회 속도가 빨라진다는 것
	- 최근 조회한 어떤 정점을 새로운 루트 정점으로 만들기 때문에 다시 조회하면 즉각적으로 조회할 수 있다
- 단점은 트리가 균형을 이룬다는 보장이 없다는 것이빈다. 
	- 그래서 일부 탐색이 O(log n) 보다 더 오래 걸릴 수 있다. 
	- 최악의 경우 선형 시간O(n)만큼 오래 걸릴 수도 있다
	- 또한 탐색을 수행하는 동안 정점이 루트가 아닌 경우 루트까지 회전해야 할 수 도 있는데, 이때도 시간이 소요됩니다.

### 6. B 트리
- 이진 트리의 일반화 형태 
- 주로 데이터베이스를 만드는 데 사용됨
- 이진 트리와 달리 B트리는 자식을 두 개 이상 가질 수 있다
- 또한 대부분의 정점이 이전에 다룬 트리와 다르게 두 개의 **키** 값을 가지고 있다
- 따라서 B 트리의 정점은 자식을 2개 이상 가질 수 있을 뿐 아니라 키도 2개 이상 가질 수 있다
	- 자식의 수가 키의 수보다 하나 더 많다 (`p215 예시`)
	- 루트 정점은 한 개의 키와 두 개의 자식이 있고, 다른 자식 정점들은 두 개의 키와 세 개의 자식이 있음
- 이것이 바로 B 트리를 이진 탐색 트리의 일반화 형태라고 말한 이유

기본 아이디어
- 탐색을 완료한 후에는 한 번에 여러 정보를 메모리에 저장할 수 있다는 것
	- 즉, 일단 가게에 도착하면 집까지 반복해서 오가는 대신 필요한 모든 것을 구매하는게 더 낫다는 거죠
- B 트리의 각 정점은 이진 트리보다 많은 키와 자식을 가질 수 있으므로 크기가 더 큽니다.
- 따라서 각 정점을 읽는 데 더 많은 시간을 소비합니다.
- 하지만 <u>한 번에 더 많은 데이터를 읽을 수 있기 때문에 검색 횟수는 줄어듭니다</u>


## Chapter9. 다익스트라 알고리즘
정리하자면 다익스트라 알고리즘은 다음 4단계로 이루어집니다
- 가장 가격이 싼(=가중치가 적은) 정점, 즉 도달하는 데 시간이 가장 적게 걸리는 정점을 찾습니다.
- 이 정점의 이웃 정점에 대해 현재 가격보다 더 싼 경로가 존재하는지 확인합니다. 만약 존재한다면 가격을 수정합니다.
- 그래프의 모든 정점에 대해 이러한 일을 반복합니다
- 최종 경로를 계산합니다

다익스트라 알고리즘에 사용되는 용어
- 가중치 (weight)
- 가중 그래프 (weighted graph) : 가중치를 가지는 그래프
- 균일 그래프(unweighted graph) : 가중치가 없는 그래프
- 방향(단방향) 그래프 or 무방향(양방향) 그래프

<u>다익스트라 알고리즘은 모든 간선의 가중치가 음의 가중치를 갖지 않으며, 사이클이 없는 그래프에서만 동작함</u>

음의 가중치가 있는 경우? `벨만-포드 알고리즘`이 필요

물물교환 예시를 통해 최단 경로라는 것이 반드시 거리를 최소화하는 거시 아니라는 것을 알게 된다
최단이라는 말은 무언가를 최소화한다는 의미입니다 (비용을 최소화)

### 5. 간선의 가중치가 음수인 경우
https://www.youtube.com/watch?v=Ppimbaxm8d8

---
오타 149
나가는 이웃 out인데 in이라고 되어 있네
p175 예시가 반대가 됨 
첫번째 에시는 깊이우선인데 설명은 너비 우선으로 설명하네
