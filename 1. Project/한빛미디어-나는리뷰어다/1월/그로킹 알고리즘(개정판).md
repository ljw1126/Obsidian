
| 첫날  | ~60p  |
| --- | ----- |
| 둘째날 | ~100p |



파이썬으로 예제 작성

p26 
**실행 시간(running time)**
원하는 숫자를 찾을 때
- **선형 시간 (linear time)** : 100개 원소 중 100번 추측, 만약 40억개면 40억 번 추측
- **로그 시간(logarithmic time)** : 100개가 있다면 <u>7번</u>만 추측 

p29
**빅오 표기법**
- 알고리즘이 얼마나 빠른지 말해줌
- 연산 횟수를 비교하기 위한 것이므로 수행해야 할 일이 많아질 때 알고리즘에 걸리는 시간이 어떤 식으로 증가하는지 알 수 있습니다.
- 선형 탐색 : O(N) , 이진탐색: O(logN)
- 최악의 경우에 대한 표기

p33 빅오 표기법 그림이 귀엽다
p34 외판원 문제 (traveling salesperson problem)
p37 연습 문제 
1-1. 2^128 = 7 
1-2. 8
2-1. O(logN)
2-2. O(N) // 최악의 경우를 고려?
2-3. O(N)
2-4. ~~O(1)~~ > O(N) 


## Ch2. 선택 정렬
p41 
배열과 리스트는 각각 장단점이 있습니다. 두 방식의 차이점을 잘 알고 있어야 경우에 맞게 선택하여 사용할 수 있습니다. 

배열 - 고정 길이, 런타임 변경 불가능, 직접 새로 생성해야 복사해야함
리스트 - 동적 길이, 런타임 변화가능, copy and shift 비용 발생, 기본 사이즈랑 증가 사이즈가 몇이었지

p43
연결리스트(linked list)를 극장 좌석 예약으로 설명하는게 not bad
내가 생각하는 장단점
- 장점: 공간 제약이 없다, 추가/삭제의 경우 연결 노드의 포인터만 변경하면 되서 대부분 O(1) // 이때 조회 시간이 필요하기도 하다
- 단점: 검색시 순차적으로 조회해야 해서 O(N), 힙 메모리에 저장되는데 메모리 해제를 잘 하지 못하면 memory leak 발생 가능

배열 단점을 고양이 그림으로 귀엽게 설명하네 ㅋㅋ

배열은 인덱스로 바로 빠르게 접근가능

p46
원소의 위치를 **인덱스** 라고 한다
배열과 리스트의 시간 복잡도 

p47
중간에 데이터 삽입하는데 배열과 리스트를 비교함 
<u>그런데 리스트가 연결리스트라서 혼동있어보임 (ArrayList도 있고 구현체는 다른데)</u>

p49
배열과 리스트의 읽기/삽입/삭제에 대한 시간 복잡도 비교 표

배열과 연결 리스트 중 더 자주 쓰는것은?
- 임의 접근(random access) 가능한 배열이 더 자주 사용
	- 연결리스트는 순차 접근(sequential access)을 해야 하니
	- <u>배열은 순차 접근도 빠르다!</u>
- 공간 측면에서는 연결 리스트가 포인터만 가지고 있으면 되서 나음 (배열은 불필요한 공간 예약)
	- *근데 어떤 경우에서는 연결 리스트가 배열보다 많다네 ?*

p56
```py
def findSmallest(arr):
	smallest = arr[0] // 0번 인덱스와 값으로 초기화
	smallest_index = 0 
	for i range(1, len(arr)):
       if arr[i] < smallest:
         smallest = arr[i]
         smallest_index = i
	
    return smallest_index;

// 선택 정렬, 오름차순
def selectionSort(arr): 
  newArr = []
  copiedArr = list(arr)
  for i in range(len(copiedArr)):
	smallest = findSmallest(copiedArr)
	newArr.append(copiedArr.pop(smallest))

  return newArr

print(selectionSort([5, 3, 6, 2, 10]))
```


p57 2장에서 배운 내용
- 컴퓨터 메모리는 거대한 서랍장과 같습니다
- 여러 항목을 저장하고 싶을 때는 배열이나 연결리스트를 사용하세요
- 배열을 쓰면 모든 항목은 이웃하는 위치에 저장됩니다
- 연결 리스트를 쓰면 모든 항목이 흩어지지만, 각 항목이 다음 항목의 주소를 저장합니다
- 배열은 읽기가 빠릅니다 
- 연결 리스트는 삽입, 삭제가 빠릅니다

**연습문제**
1-1. 연결 리스트 사용 
1-2. 연결 리스트 사용 >> 근데 ArrayDeque에서 최적화 되면서 배열에 포인터를 사용하는 형태가 됨
2-1. 배열 사용 (임의 접근, 정렬해서 이진 탄색)
2-2. 삽입을 위한 배열에서 발생하는 단점은 공간이 부족한 경우 copy and shift 연산이 발생하겠지
이진 탐색으로 이름 검색하는 경우 범위가 늘어나겠지만 O(logN)에 찾을 수 있음
<u>추가로 신규 유저가 추가되면 정렬을 해야 하는 단점이 있음</u>
2-3. ~~26개라는 공간이 지정되어 있다면 검색과 삽입은 배열이 빠르다고 생각함. (삽입이 빠르다구?)~~
(풀이 답변)이 복합 자료구조는 검색의 경우 배열보다 느리고 연결 리스트보다는 빠릅니다. 삽입의 경우 배열보다 빠르고 연결리스트와는 같은 시간이 걸립니다. 그러니까 배열보다는 검색 시간 측면에서만 느리고 연결 리스트보다는 모든 면에서 좋거나 최소한 같습니다. (복합 자료구조 = 해시 테이블)

<u>배열과 연결리스트는 이러한 복잡한 자료구조를 만드는 기초가 됩니다</u>


## Ch3 재귀(recursion)

하나의 문제를
- 기본 단계
- 재귀 단계
- 분할 정복 전략

>[!note] 리 콜드웰 (Leigh Caldwell) - 스택 오버플로
>"프로그램에 반복문을 사용하면 프로그램의 성능을 향상시킬 수 있지만, 재귀를 사용하면 프로그래머의 능력을 향상시킬 수 있습니다. 상황에 따라 적절한 방법을 골라 사용하세요"


```python
def countdown(i):
  print(i)
  if i <= 1: // 기본 단계 
	return
  else:   // 재귀 단계
	countdown(i - 1);

countdown(3)
```
- 기본단계 (base case)
	- 함수가 자기 자신을 다시 호출하지 않는 경우
	- 종료 조건
- 재귀단계(recursive case)
	- 함수가 자기 자신을 호출하는 부분

```javascript 
const greet = (name) => { console.log(`hello, ${name}`); greet2(name); bye();}
const greet2 = (name) => {console.log('greet2');}
const bye = () => {console.log('say goodbye');}

greet('tester');

/*
hello, tester
greet2
say goodbye
*/
```

큰 상자안에 작은 상자들이 있고 열쇠를 찾는 예시를 들어서 재귀 설명

스택을 사용하면 편리하기는 하지만 그만큼의 대가를 치러야 합니다. 모든 정보를 저장해야하므로 메모리를 많이 소비하죠. 함수를 호출할 때마다 메모리를 사용하게 됩니다. 스택이 너무 커졌다는 것은 컴퓨터가 과다한 함수 호출 정보를 저장하고 있다는 뜻입니다. (stack overflow)

예제1. greet2가 마지막에 호출되고 name 변수값을 가짐, greet가 제일 처음 호출되고 name값을 가짐 >> 더이상 호출할게 없으면 greet2 -> greet  스택에서 꺼내 함수 실행 결과 반환
예제2. 스택 오버플로우가 발생

// 재귀가 중요한데.. 너무 심플하기도 하면서도 중요한 개념을 언급하고 가네

## Ch4. 퀵 정렬
- 분할 정복 전략이랑 관련있구나 
- 분할 정복 알고리즘 == 재귀 알고리즘 

>[!tip] 유클리드 알고리즘
>"만약 나머지 크기의 농장에 맞는 가장 큰 정사각형을 찾으면 이 정사각형 토지 모양으로 전체 농작을 나눌 수 있습니다"라는 말이 정말인지 명확하게 증명할 수 없어도 걱정하지 마세요
>
>유클리드 호제법 > 칸 아카데미에 좋은 설명이 있습니다
>https://www.khanacademy.org/math/geometry/hs-geo-transformations/hs-geo-intro-euclid/v/euclid-as-the-father-of-geometry


>[!tip] 함수형 프로그래밍
>(..) 재귀 함수를 잘 이해하고 있으면 함수형 프로그래밍 언어를 익히는 것이 더 쉬워집니다


퀵 정렬에서 분할(partitioning)
- 기준 원소보다 작은 숫자들로 이루어진 하위 배열 
- **기준 원소**
- 기준 원소보다 큰 숫자들로 이루어진 하위 배열
이때 배열 크기가 1인 경우 바로 반환 (종료 조건)
기준 원소를 어떻게 선별하고, 파티셔닝을 나누는지가 중요할 뿐이네  👍

p98
>[!tip] 귀납적 증명



컬렉션을 사용하는 경우 공간 복잡도는 더 잡아먹겠지만, 포인터 방식 보다는 이해가 쉽다
```java
import java.util.*;

public class QuickSortList {
    public static List<Integer> quickSort(List<Integer> list) {
        if (list.size() <= 1) {
            return list;
        }

        int pivot = list.get(list.size() / 2); // 중간값을 피벗으로 선택
        List<Integer> left = new ArrayList<>();
        List<Integer> right = new ArrayList<>();
        List<Integer> equal = new ArrayList<>();

        for (int num : list) {
            if (num < pivot) {
                left.add(num);
            } else if (num > pivot) {
                right.add(num);
            } else {
                equal.add(num);
            }
        }

        List<Integer> sorted = new ArrayList<>();
        sorted.addAll(quickSort(left));  // 재귀 호출
        sorted.addAll(equal);
        sorted.addAll(quickSort(right));
        return sorted;
    }

    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(3, 6, 8, 10, 1, 2, 1);
        List<Integer> sortedList = quickSort(new ArrayList<>(list));
        System.out.println(sortedList);
    }
}

```