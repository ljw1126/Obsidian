- 도서 정보: 한빛미디어](https://www.hanbit.co.kr/store/books/look.php?p_code=B6249658359)
- 마감일: `4월 25일 금요일`


도커 다이어그램 
- 용어 정리
- OS별 설치 방법 설명

마지막에 `요약 정리` 제공

컨테이너 서비스가 docker 말고도 있고, OCI 표준에 따른다 

컨테이너 특징과 `cheat sheet` 공개 

p87 컨테이너 명령어 전체 

ps -> ls 로 변경됨 p101 (언제부터 변경되었는지 찾아보기)

p118 긴 옵션과 짧은 옵션에 대한 설명 

-p가 포트가 아니라 publish라서 충격 

10.2 detach 옵션 

nginx, mysql, postgresql 컨테이너 설치 및 client, docker exec  통해 접속 방법 설명함 

p140 컨테이너 로그 확인, 주의점
처음 사용하는 이미지의 경우 detach (백그라운드 실행), --rm 옵션을 함께 사용하지 말기 
logs로 원인 트래킹을 할 수 없음 

p153 명령어 비교

(..)

Dockerfile에서 대표적으로 사용하는 4가지 명령어에 대해 살펴봄
- MySQL Replica 생성시 Dockerfile 확인해보기 
- AWS ECS 에서 쓴 Dockerfile 확인해보기

(..)

// 4장에 레이어 확인하기 

비슷하지만 다른 것들을 비교해주는게 좋네 
- 볼륨과 마운트의 차이
	- prometheus 설정했을떄 사용한 방식이 바인드 마운트
	- 데이터 베이스 데이터 저장해서 관리하는 주체가 컨테이너인게 볼륨
- p267 `바인드 마운트`와 COPY의 차이

p269
네트워크 종류가 여러가지인데 브릿지 네트워크를 대표적으로 사용하네 

p272 네트워크 통신
- 예전에 Jenkins 도커로 깔고 배포 프로세스 했던게 생각나네

p280 기본 브릿지 네트워크를 사용했을때의 불편함 
- ip를 매번 알아야 함 
- 브릿지 네트워크 생성해서 지정할 경우 컨테이너명으로 통신 가능

6부에서는 웹 서비스를 구축해본다 
p290 개략적인 구성도

docker-compose로 컨테이너 서비스 3개 정리 
그리고 docker 사용시 주의 사항을 마지막 장에서 살펴보고 끝나는데 내용이 빈약하다.

---

실무 경험 
- AWS ECS 에서 사용한 Dockerfile
토이 프로젝트 
- docker-compose만 사용하고 있다. 

도커가 등장하기 전에는 무거운 VMware, VM 버츄어박스 구동하여 가상화
이미지를 굽고 실행되기까지 인내의 시간을 보냈던 기억이 나네 .

도커 영상
https://www.youtube.com/watch?v=wW9CAH9nSLs

전반적인 명령어에 대한 설명
Dockerfile 활용해 기본 이미지에 확장해보기 (4개 명령어 만 사용)
커맨드 명령어로 컨테이너 서비스 올리기
docker-compose 

공식 문서를 부분적으로 읽지, 세부적으로 읽은 기억이 많지 않음 
책을따라 하나하나 찾아보는 재미가 있네 

Docker 공식홈에 cli cheat sheet 제공

비슷하지만 다른 것 // COLUMN으로 비교해주는 것도 좋네 
- 볼륨과 바인드 마운트 // 22장
- 긴 옵션과 짧은 옵션 
- container run과 container exec 차이
- `container commit 과 container export + image import 차이`
- (Dockerfile의) ENV와 container run --env
- 기본 브릿지 네트워크와 사용자 정의 브릿지 네트워크 // 네트워크 종류가 뭐가 더 있을까??
- 비슷하지만 다른것#4 - 바인드 마운트와 COPY (22장)

그리고 마지막에 `요점 정리`👍
### 4장

명령어와 프로세스 
- `ls` 명령어를 실행하면 `ls 명령어의 프로세스`가 실행되고 종료됨
- `bash` 명령어를 실행하면 exit 하기 전까지 종료하지 않음

OS 가동할 때 생성된 최초 프로세스는 부모 프로세스가 존재하지 x
최초의 프로세스는 다른 모든 프로세스를 가동하는 역할을 담당 
OS에 다라 다르지만 init, systemd, launchd 명령어에서 생성됨

OS는 프로세스 관리 목적으로 프로세스 ID라는 식별 번호를 프로세스에 배정합니다

(..) 하지만 앞서 소개한 모든 프로세스의 부모가 되는 systemd 등의 프로세스 ID는 언제나 1입니다 
책에서는 프로세스 ID1을 특별하게 `PID1`로 표기합니다. 모든 프로세스는 부모를 거슬러 올라가면 PID1에 도달합니다. // 근본이네 
도커 컨테이너는 이런 PID1에 주목하면 이해가 쉬워집니다.

// 컨테이너 명령어를 통해 ls나 top을 실행하면 얘네가 PID1이 된다는 의미구나 


**4.3 이미지**

특징
- 컨테이너 실행에 필요한 패키지를 말하고, 다수의 `레이어(layer)`로 구성됩니다
	- 이미지는 레이어의 집합이라는 거네
	- 각 구성 요소가 레이어이다
	- ex. 우분투 레이어, php 설정 파일 레이어, php 설치 레이어 (이미지 참고)
- 이미지는 이런 파일을 모아서 하나의 파일 시스템처럼 다룬다
	- 레이어는 이미지 끼리 공유할 수 있다

**4.4 도커 파일**
- 도커 파일은 이미지에 레이어를 (직접 커스텀) 추가/확장하는 설정 파일
- 도커 파일은 텍스트 파일이므로 깃으로 일반 텍스트 파일과 같은 방법으로 공유 가능
	- 기본(베이스) 이미지는 도커 허브에서 가져옴

[공식 래퍼런스](https://docs.docker.com/reference/)

**4.6 명령어 치트 시트**

### 5장 
**5.1 컨테이너 상태와 프로세스**

- 컨테이너 정지와 PID1 종료는 한세트
	- 컨테이너 내부에서 실행되는 **해당 명령어의 프로세스(ex. ls)** 는 컨테이너 내부에서 PID1로 다룹니다
	- PID1은 컨테이너와 운명을 함께 합니다

**5.2 컨테이너 명령어**
// 표 정리 되어 있음 


### 6장

p98 기존 명령어와 새로운 명령어의 호환성 문제 
[docker container ls / docker ps](https://docs.docker.com/reference/cli/docker/container/ls/)
[docker image ls / docker images](https://docs.docker.com/reference/cli/docker/image/ls/)
[docker image rm / docker rmi](https://docs.docker.com/reference/cli/docker/image/rm/)

// https://www.docker.com/blog/whats-new-in-docker-1-13/
// 짧은거만 있었는데 Docker 1.13 이후 정식 명령어가 된듯하다 
// 사진 찍어서 비교해줘도 괜찮을듯

p100
가동중인 컨테이너 강제 삭제하기 
container rm --force = container stop + container rm 

p101
COLUMN
- 작업 절차서나 스크립트처럼 다른 사람도 봐야 한다명 `새로운 명령어 + 긴 옵션`
- 개인적인 용도라면 `기존 명령어 + 짧은 옵션`을 사용
// 저자의 팁인듯하다 


### 7장
[container run](https://docs.docker.com/reference/cli/docker/container/run/)
container run -rm 

// 이미지를 내려 받기 + 컨테이너 start 인듯 ?
### 8장
container run --interactive --tty
// 여기서 나오는구나 `docker exec -it 컨테이너명 /bin/bash`

p115
COLUMN 짧은 옵션과 긴 옵션 (👍)

### 9장 Nginx 서버를 가동해서 브라우저에서 접속하기 
--publish 옵션 추가만 설명 

### 10장 MySQL 서버를 백그라운드로 가동하기 
10.1container run --env 

// mysql 허브에 환경변수 확인하고 싶은데 무한 로딩 중..

10.2 container run --detch


### 11장 PostgreSQL 서버를 가동해서 이것저것 확인해보기 

11.1 containers logs

`docker containers logs --follow 컨테이너명`
- 옵션 통해 계속 로그 확인 가능

11.2 container exec

container run 과 container exec 차이 
- container run은 컨테이너를 가동해서 컨테이너에서 PID1을 생성  // 해당 명령어를 PID1
- container exec는 PID1이 이미 존재하는 컨테이너에서 새로운 명령어 프로세스를 실행함 

// 문법적 차이를 보여주네

11.3 PostgreSQL 서버에 접속하는 방법 정리하기 
// 3가지 방법을 비교하는데 

p150
COLUMN 비슷하지만 다른 것 - container exec와 container attach 와 container run


### 12장

**12.3 레이어와 메타데이터** 
이미지는 레이어라는 tar 아카이브 파일을 겹쳐서 만든 것
레이어에 있는 파일을 중첩해서 하나의 파일 시스템으로 만든다


- **컨테이너 레이어** 
	- 컨테이너 구동시 생성되는 쓰기 영역
	- 이미지의 레이어는 읽기 전용 
- 메타데이터
	- 이미지에는 레이어와 별도로 메타데이터 정보가 있음
	- 겹쳐서 파일 시스템을 변경하는 레이어와 다르게 이미 전체의 속성

**12.4 이미지 명령어**
// 표 정리 잘됨


### 13장 이미지 기본 조작

COLUMN 
container run에서 호스트머신에서 존재하지 않는 IMAGE를 지정하면 우선 image pull이 실행되고 그후에 컨테이너가 가동됩니다.


`13.3 image inspect`

p174 ContainerConfig는 해당 이미지를 작성한 컨테이너 정보이므로 이미지로 컨테이너 가동에는 아무런 관계 없습니다. (샘플 코드..) ContainerConfig와 Config는 다소 차이가 있으므로 컨테이너 사용시 Config 쪽을 참조한다고 기억하길 바람 


### 14장 
// 태그를 사용해서 다른 버전의 MySQL 컨테이너를 설치해몸


### 15장 vi를 설치한 우분투 이미지를 작성하고 공유하기

**15.1** 
docker container run 실행시 bash 를 실행 
이후 vim을 직접 설치 

**15.2**
container commit
vi가 설치된 우분투 이미지를 신규 생성 

**15.3 컨테이너를 tar로 이미지화하기 container export + image inport**
tar 파일로 만들어서 이미지를 import 가능하네 

p191 
`container commit 과 container export + image import 차이`
- 레이어 수와 메타데이터 취급이 다름 
- `container export + image import` 로 작성한 이미지는 레이어가 하나 (= 병합)
	- 또한, 이미지 메타 데이터가 모두 사라짐 
	- 그래서 컨테이너 가동시 `[COMMAND]`를 생략하면 오류가 발생
- container commit은 메타 데이터를 보존 하는듯??

**15.4** 이미지를 tar로 만들고 다시 이미지화하기 image save + image load 


## 4부 도커 파일 
**16.1 도커 파일이 필요한 이유**


**16.3 도커 파일 명령어 목록** 
// 표 👍

요점 정리 
- 수작업 기반의 운영은 재현성이 없습니다 (직접 명령어 하나하나 다 실행해서 컨테이너 만드는 경우)
- 도커파일을 사용한 이미지 확장은 명시적이고 재현성이 었습니다
- 도커파일은 FROM으로 베이스 이미지를 지정해서 레이어와 메타데이터를 추가할 수 있습니다


### 17장. vi를 사용할 수 있는 우분투 이미지 만들기 
// Dockerfile에 우분투 베이스 이미지로 vi 추가하는 내용인듯 

**17.1 베이스 이미지 지정 FROM**

**17.2 도커파일로 이미지 빌드하기 image build**

**17.3 명령어를 실행해서 레이어 확장하기 RUN**
- RUN 명령은 리눅스 명령어를 실행하고 그 결과를 레이어로 확정
- RUN 명령에 지정한 명령어는 image build 할때 실행된다
	- 필자에게는 image build 실행은 RUN 명령어 적힌 명령어를 작동시킨다는 느낌보다, 복사해서 붙인 명령어에 실수가 없는지 최종 확인하는 느낌에 더 가깝습니다. p222

- RUN 명령어에 && 을 사용해 실행 명령어를 줄일 수 있다
	- 익숙해지면 이미지 용량을 줄이거나, 빌드 시 레이어 캐시를 알아보는 등 응용해서 활용해 봅시다

### 18장. 시간대와 로그 출력이 설정된 MySQL 이미지 만들기 

**18.1 이미지 환경 변수 지정하기 ENV**
- ENV 명령은 메타데이터에 환경 변수를 추가

// MySQL에서 time_zone 은 UTC로 되어 있어 한국과 시차가 9시간 난다 
// ENV 설정통해 환경변수 설정하여 time_zone 맞출 수 있다

p231 COLUMN 
비슷하지만 다른것 #2 - ENV와 container run --env
- ENV 명령은 이미지에 설정 
- 컨테이너를 가동할 때 환경 변수 설정을 빠뜨리거나 실수할 일이 없고, KST가 설정된 이미지라는 식으로 확정된 형태로 사용
- 반면에 container run의 --env는 컨테이너 가동 시 옵션이므로 컨테이너 단위로 설정합니다
	- 개별로 유연하게 설정 가능하다는 뜻


**18.2 호스트머신의 파일을 이미지에 추가하기 COPY**
- COPY 명령은 호스트 머신의 파일을 이미지에 복사해서 레이어를 작성합니다 
- [COPY 명령어](https://docs.docker.com/reference/dockerfile/#copy)

// MySQL 설정 파일을 카피하고, 컨테이너 실행시 로그 확인하는 방법을 알려준다 


```shell
docker container exec db ls /var/log
docker container exec db tail -n 5 /var/log/query.log
```


### 19장 가동할 때 웹서버를 실행하는 파이썬 이미지 만들기

**19.1 컨테이너 가동 시 명령어 지정하기 CMD**
- CMD 명령은 메타데이터에 컨테이너 가동 시 명령어를 지정

// 파이썬 컨테이너를 실행 후 웹 서버를 하나 실행하네 예시로 


## 5부 고급 도커 컨테이너 활용 

### 20장 볼륨과 네트워크 기초 
p246
컨테이너를 삭제한 후에도 남기고 싶은 데이터는 볼륨에 보관하고, 다른 컨테이너를 가동할 때 동일한 볼륨을 마운트하면 새로운 컨테이너에서 데이터를 이어서 사용할 수 있습니다. 볼륨을 이용하면 데이터를 컨테이너 존재 여부에 상관없이 계속 보관할 수 있습니다.

// docker volumn 하위 명령어 표 (몇개 없네)


**20.2 네트워크** 
네트워크 드라이버에는 몇 가지 종류가 있는데 책에서는 `브릿지 네트워크`만 설명함
- [docker network](https://docs.docker.com/reference/cli/docker/network/)
브릿지 네트워크 드라이버는 네트워크를 작성할 때 네트워크 드라이버를 지정하지 않으면 기본으로 사용하는 드라이버로, 같은 도커 엔진에서 작동하는 컨테이너가 서로 통신할 때 이용합니다.
> 도커 엔진을 실행하면 기본 브릿지 네트워크라는 브릿지 네트워크가 작성됨

직접 작성한 브릿지 네트워크를 `사용자 정의 브릿지 네트워크`가 부른다
(..) 사용자 정의 브릿지 네트워크를 이용하는 것이 좋습니다.

// docker network 하위의 모든 명령어 (몇개없네)

p249 요점 정리
- 볼륨을 이용하면 컨테이너를 삭제한 후에도 데이터가 남아 있습니다 
- 네트워크를 이용하면 컨테이너끼리 통신할 수 있습니다.


### 21장 MySQL 컨테이너 데이터가 사라지지 않게 만들기 
// 볼륨과 마운트 차이 

**21.1 볼륨 작성하기 volumn create**
- 볼륨 작성은 volumn create로 합니다

**21.2 컨테이너 가동할 때 볼륨 마운트 하기 container run --mount**
- container run에 --mount 옵션 추가
- key = value 형태로 하는데 3개가 있네 (type, source, destination)


### 22장 호스트머신에서 편집한 파일을 루비 컨테이너에서 실행하기
**22.1 바인드 마운트 이용하기 container run --mount**
- 볼륨과 마찬가지로 container run --mount 로 설정함
- 볼륨 자체는 ls 명령어로 참조하거나 vi 명령어로 편집할 수 없고 볼륨 관리는 도커 엔진이 담당합니다
- 반면에 바인드 마운트는 볼륨이 아니라 호스트 머신의 디렉터리를 컨테이너에 마운트합니다👍


p264
비슷하지만 다른 것#3 --mount 와 --volume
- 둘다 마운트용 옵션
- 표기 방법 부터 다르네

**22.2 볼륨과 바인드 마운트의 차이점**
바인드 마운트는 호스트머신의 디렉터리를 컨테이너에 마운트하고, 볼륨은 도커 엔진이 관리하는 스토리지를 컨테이너에 마운트합니다. 
컨테이너 내부에서 마운트 대상 디렉터리에 손상이 발생하면
- 바인드 마운트는 호스트머신에도 영향이 있음
- 볼륨 파손은 도커 엔진 내부에서만 영향을 준다
- 또한 볼륨은 도커 엔진이 관리하기 때문에 호스트머신의 파일과 다르게 직접 조작할 수 없습니다

볼륨은 컨테이너 데이터를 남기고 싶지만 직접 접근할 일도 없고 파일이 어디에 있던지 관계 없는 경우에 적합
반면에 바인드 마운트는 호스트머신과 컨테이너에서 디렉터리를 공유할 수 있다
호스트 머신의 편집기로 파일을 편집해서 컨테이너에서 실행하는 개발 환경이라면 필수적

p267 비슷하지만 다른것#4 - 바인드 마운트와 COPY
바인드 마운트는 컨테이너에 마운트하지만, COPY 명령은 이미지에 파일을 복사함
COPY 명령은 이미지에 파일을 복사하는 명령이므로, 미리 정한 설정 파일을 설치한 이미지로 정의해서 사용
반면 바인드 마운트는 컨테이너에 원하는 소스 코드를 마운트하는 식으로 가동할 때마다 유연하게 지정합니다



### 23장 PHP 컨테이너에서 MySQL 컨테이너와 통신하기

**23.1 네트워크 작성하기 network create**

**23.2 컨테이너 가동시 네트워크에 접속하기 container run --network**
// php 코드를 짜서 MySQL 컨테이너 통신하는걸 보여주네

**23.3 기본 브릿지 네트워크를 사용한 컨테이너 통신**
