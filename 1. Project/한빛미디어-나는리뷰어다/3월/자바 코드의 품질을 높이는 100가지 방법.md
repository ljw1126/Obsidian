
저자는 IntelliJ IDEA를 만드는 젯브레인에서 일한 경력을 가지고 있다.

초반에 책의 난이도가 있는 편이다. 구현 레벨에 있다면 `Chapter05. 일반적인 예외` 부터 읽기 편할 것이다. 그 전까지 `오버 플로우`, `언더 플로우`, `비트 연산`, `유니 코드` 등

책의 설명 흐름 
각각의 실수 유형을 논의한 다음에는 '`실수 방지 가이드`' 정리로 마무리한다
// 개인적으로 좋았던게 필자의 경험과 더불어 유명한 기업에서도 문제를 찾지 못해 몇년간 방치하다가 찾은 사례를 설명해주는게 좋았다


코드 리뷰, 페어 프로그래밍, 코드 스타일, 정적 분석 도구, 테스트 자동화 에 대한 권장
- 코드 리뷰, 테스트 자동화, 정적 분석 도구를 활용하면서 도움 받은 경험
- `정적 분석은 과도하게 의지하기 쉬운 기술일 뿐 전능한 존재는 아니다`. 실수를 예방하는 데 확실히 도움이 되는 반면 그 한계 또한 명확하다 라 말함
- 커버리지에 집착하다보니 테스트 하려는 목적이 흐려지고, 테스트가 짐이 되기도 했던 경험

- 코드 스타일을 통일하면 코드 가독성이 향상되고 에러 발생률도 낮아진다.
(하지만) <font color="#ff0000">이 책에서 다루는 대부분의 실수는 코드 스타일만으로 방지할 수 없다.</font>
- 마지막으로 단순히 정적 분석기가 틀렸을 가능성을 고려해야 한다. 
- 테스트 또한 코드이므로 버그가 생기고 재기능을 못 할 가능성이 있음을 간과하면 안된다. 

//결국 코드를 작성하는 건 사람인거고, 모든 케이스에 대한 커버는 현실적으로 불가능하다.



알고리즘 문제를 풀 때 숫자와 관련된 에러가 많아서 눈에 보이지 않아 고생한 사례가 많다


오류가 발생하지 않는 버그가 더 찾기 힘들다고, 차라리 오류가 발생하는게 문제 원인을 파악하는게 낫지, 발견되지 않은채 잠재되어 있다가 몇 년만에 찾은 사례도 많다.

테스트에서는 검증을 빼먹는다거나 
indexOf에서 -1인 경우를 처리하지 않는다거나
메서드 파라미터를 잘못 입력하여 사용한다거나 - replace, replaceAll


어려운 부분 
- ch02
	- 연산자의 우선순위 
- 

좋았던 부분
자바 버전 별로 정보를 나타내주는게, Java 8, 11을 실무에서 자주 사용하고 개인 프로젝트할 때나 17, 21을 사용한다 최근 24까지 나온걸로 아는데 세부적으로 무슨 변화가 있는지 알아 내는데는 한계가 있다 그런 점에서 

p66 문자열을 직접 결합하는 대신 다음과 같은 포메팅 메서드를 호출한다 (실수 방지)
```java
return String.format("Value: %s", value != null ? value : "(unknwon)");

// java 15부터
return "Value: %s".formatted(value != null ? value : "(unknwon)");
```
- 아쉽지만 현재 JVM에서 포맷팅 메서드는 문자열 연결보다 상당히 느리므로 빈번하게 실행되는 코드 경로에는 무턱대고 쓸수  없다

자바 9부터 `Objects.requireNonNullElse()` API 메서드로 null 판단 조건 표현식을 대체할 수 있다
```java
return "Value " + requireNonNullElse(value, "(unknwon)")
```
- 참고. [오라클 자바 17 Objects](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Objects.html)


p69
문자열 결합은 메서드 호출보다 우선순위가 낮다는 것을 명심한다.
자바 15부터 문자열 결합 대신 텍스트 블록을 사용할 수 있다. 
```java
String greetingPage = """
	<h1>Hello, $user$</h1>
""".replace("$user$", userName);
```

p85
자바 1.5부터 메서드 파라미터 중 마지막 요소를 `가변 인수(variable arity)`로 선언할 수 있다

p97 실수 방지 가이드 
> [!note] 새로운 API를 익힐 때는 Javadoc을 참고하고 객체의 가변성을 확인한다



**Ch01. 코드 품질 관리**
**Ch02. 표현식**
**Ch03. 프로그램 구조**
**Ch04. 숫자**
**Ch05. 일반적인 예외**
**Ch06. 문자열**
**Ch07. 객체 비교**
**Ch08. 컬렉션과 맵**
**Ch09. 라이브러리 메서드**
**Ch10. 유닛 테스트**


**Ch01. 코드 품질 관리**
개발자가 문제를 제대로 이해했지만 코드를 올바르게 작성하지 않아 기계가 문제를 풀지 못하는 경우다. 이 책은 이러한 범주의 버그에 중점을 둔다 (p30)

숙련된 개발자는 실무를 통해 이러한 버그를 지속적으로 경험해왔고, 위험한 코드와 주의가 필요한 지점을 한 눈에 파악할 수 있다. 또한 이들은 각종 유형별 버그를 이미 접해보았기에 문제의 소지가 있는 코드 패턴을 간단히 지목할 수 있다.

반면 경험이 부족한 개발자들은 이러한 버그를 간과하기 쉽다. 개발자의 손을 빠져나간 버그는 프로덕션에 심각한 장애를 일으킬 절호의 기회를 얻게 된다. 

각각의 실수 유형을 논의한 다음에는 '실수 방지 가이드'로 마무리 할 것이다.(p31)

`코드 리뷰`는 개발자가 커밋한 변경 사항을 체계적인 절차에 따라 동료들이 검토하는 제도이다
코드 리뷰는 단순한 버그 방지 외에도 코드 아키텍처를 개선하고 가독성과 성능을 높여준다. 또한 조직 내부에 지식을 공유하고 멘토링 문화를 정착 시키는 역할을 한다

`페어 프로그래밍`은 익스트림 프로그래밍 방법론에 등장한 기법이다. 코드 리뷰 절차를 극단화 시켜 아예 두 명의 프로그래머가 함께 개발하는 것이 핵심이다.

> [!info] 도서 추천
> - 아드리안 볼보아카의 Practial Remote Pair Programming (Packt, 2021)
> - 켄트 벡의 익스트림 프로그래밍 (인사이트, 2006)


코드 스타일의 경우 **구글 자바 스타일 가이드**를 한 번쯤 읽어볼 만하다 (p34)
오라클 웹 사이트에는 `Code cOnventions for the Java Programming Language`라는 좋은 자료가 있지만, 아쉽게도 지속적으로 관리되고 있지는 않다.

코드 스타일을 통일하면 코드 가독성이 향상되고 에러 발생률도 낮아진다.
(하지만) <font color="#ff0000">이 책에서 다루는 대부분의 실수는 코드 스타일만으로 방지할 수 없다.</font>
(p35)

`정적 분석`은 버그 탐지 분야에 활용하기 좋은 기술이다.

(...) 그러나 정적 분석이 코드 리뷰를 완전히 대체할 수는 없다. 정적 분석기는 특정 유형의 버그를 탐지하는 데 매우 뛰어나지만, 사람이 간단히 식별할 수 있는 버그를 절대 탐지하지 못하는 경우도 많다. 정적 분석기는 특정 패턴을 감지하는 식으로 코드를 분석하는데, 이러한 패턴에서 벗어난 코드를 발견하면 혼동을 일으키곤 한다


>[!info] 자바용 정적 분석 도구
>- IntelliJ IDEA
>- SonarQube for ide
>- Error Prone: 구글에서 개발, 오픈 소스 정적 분석기, 자바 컴파일러 플러그이니 형태로 작동
>- PVS-Studio
>- PMD

정적 분석기는 자바 표준 라이브러리 메서드가 어떻게 작동하는지 이해하며 이를 잘못 사용했을 경우 경고를 보낸다. 그러나 <u>통상적으로 정적 분석기는 개발자가 직접 만든, 또는 서드 파티 라이브러리 메서드에 대해서는 잘 알지 못한다.</u>

`정적 분석은 과도하게 의지하기 쉬운 기술일 뿐 전능한 존재는 아니다`. 실수를 예방하는 데 확실히 도움이 되는 반면 그 한계 또한 명확하다 (p42)

마지막으로 단순히 정적 분석기가 틀렸을 가능성을 고려해야 한다. 


`자동화된 테스트`(p46)

>[!info] 도서 추천
>- Test Driven (Manning, 2007)
>- JUnit IN ACTION (3판, 인사이트, 2024)


자바 s/w의 프로퍼티 테스트를 경험해보고 싶다면 jqwik 프레임워크를 참고하기 바란다.

아쉽지만 자동화된 테스트만으로 모든 버그를 발견하기란 거의 불가능하다. 따라서 일반적으로 
JaCoCo 등의 코드 커버리지 도구를 접목해 테스트 품질을 측정한다.

경험적으로, 커버리지 비율은 80%가 넘어가면 점점 더 올리기 어렵고 100%에 가까워질수록 기하급수적으로 난이도가 증가한다. 따라서 프로젝트의 테스트 커버리지 기준을 지나치게 높게 설정하면 실제 기능은 커녕 테스트를 작성하는데 모든 시간을 허비하고 말 것이다.  (p47)

테스트 또한 코드이므로 버그가 생기고 재기능을 못 할 가능성이 있음을 간과하면 안된다. 일례로 테스트를 잘못 만들면 제대로 작동하지 않는 코드까지 성공이라고 판단해버리는 경우도 있다.
(p48)

`뮤테이션 커버리지`
- 자동 테스트의 품질을 높이는 기술
- 현재 가장 널리 쓰이는 자바용 뮤테이션 테스트 시스템은 `Pitest` 이다
- 단점으로 완전한 뮤테이션 분석은 일반적인 테스트보다 실행 시간이 몇 배나 더 걸린다

`동적 분석`
- 코드 실행 도중 버그를 찾는 동적 분석 도구도 있다
- 대표적으로 `자바 패스파인더(Java Pathfinder)`는 데이터 경합, 처리되지 않은 예외, 잠재적으로 실패한 어설션 등을 감지할 수 있다

`코드 어설션`
- 유닛 테스트와 비슷한 방식으로 프로덕션 코드에 직접 어셜션을 추가하는 기법

> [!info]
> 자바 프로그램을 실행할 때 
> - JVM 명령줄 옵션에 `-ea`(enable assertions) 옵션을 추가하면 어설션 활성화 가능
> 	- 기본적으로 비활성화 상태, 프로덕션 환경에서도 비활성화이어야 한다
> - 따라서 어설션을 사용할 때는 테스트 환경에서만 활성화되어 있는지 꼭 확인하자
> - 추가로 `-ea`, `-da`(disable assertions) 옵션에 파라미터를 추가하면 특정 클래스나 패키지의 활성화 여부를 설정할 수 있다. (저자는 이 설정을 사용하지 않는 편이라 함)





**Ch02. 표현식**
- 연산자별 우선 순위에 대한 내용이 주를 이룬다 

p98
> [!note] 불변성과 성능
> 메서드 파라미터로 전달된 가변 객체를 수정하는 행위는 가끔 성능 관점에서 정당화되곤 한다. 하지만 그럴수록 API는 사용하기 어려워진다. 최신 자바 언어는 객체 할당과 가비지 컬렉션 능력이 과거 버전에 비해 크게 개선되었다. 따라서 정당한 이유가 없는 한 기존 객체를 고치기보다 새로운 객체를 생성하는 것을 추천한다. 
> (...) 하지만 대부분의 경우 이러한 추가 오버헤드는 무시할 수 있을 정도로 작고, 그에 비해 코드는 한층 단순해지고 잠재적인 에러의 위험성을 줄어든다. API 메서드를 새로 설계할 때는 이러한 원리를 항상 명심해야 한다.

p106 
**정리**




**Ch03. 프로그램 구조**
**Ch04. 숫자**
**Ch05. 일반적인 예외**
**Ch06. 문자열**
**Ch07. 객체 비교**
**Ch08. 컬렉션과 맵**
**Ch09. 라이브러리 메서드**
**Ch10. 유닛 테스트**