- 📚리뷰 도서 : [자바 최적화 2판](https://www.hanbit.co.kr/store/books/look.php?p_code=B9520608962)

소프트웨어 개발자가 더 잘하기 위해 하드웨어에도 관심을 가지기 시작하는 걸 **기계적 관심**이라고 했던거 같다.
- 책을 읽으면서 하드웨어적인 영역도 다루다보니 수준이 높다.. 
- 지금 당장 읽기 힘든 사람이라면, 훓어보고 키워드를 정리하는 것만으로 단편적으로 도움 받을 수 있찌 않을까 싶다 
- 단일 자바 가상 머신 환경에서 클라우드, 분산 환경, 배포, 모니터링(관측성)

성능 최적화 관련해서 개인적으로 "하지마라, 아직 하지마라(YAGNI)"가 생각난다.

자바 최적화이기때문에 JVM, 배포, 관리와 관련된 설명이 주를 이룸
- 이때 스프링, Docker(Dockerfile, compose),쿠버네티스, 클라우드, 배포 전략에 대해 간단히 살펴본다

성능 최적화가 필요하지 않은 시점에서 최적화를 고민하는 것은 오버엔지니어링 !
- 그리고 인터넷에 있는 잡글을 믿으면 안됨
- `1.1  잘못된 자바 성능 최적화 방법`에서 마법의 은탄환은 존재하지 않는다는 것을 언급(p31)

p34 성능 튜닝의 단계 
- 도식화하면 좋을 듯하다 

p39 성능 지표에 대해 설명할 때 상하관계가 인상깊다 (성능저하 부분)

p40 `1.5 성능 그래프 읽기`
> 그럴듯해보이지만, 이게 처음이자 마지막이 아닌가 싶다. 뒤로 갈수록 이론적인 내용이 훨씬 많이 차지하고 있다..

p45 1장 요약 
자바 성능의 개념에 대한 논의를 시작
효과적인 성능 분석에서 사용하는 기본 용어나 관측 가능한 지표들을 소개
성능 테스트 결과에서 자주 관찰되는 몇가지 일반적인 사례도 다루고, 클라우드 시스템에서 발생할 수 있는 추가적인 문제의 기초적인 개념을 소개함 

2장에서는 테스트에 대한 내용을 다룸 
- 유형별 정의 용의하네 

p54 테스트 환경 생성에서
프로덕션 환경과 동일한 부하를 처리할 수 없는 서드파티 네트워크 서비스 같은 요소는 현실적인 성능 테스트를 위해 목(Mock) 서비로 대체해야 합니다. 
- 뒤에 클라우드 환경을 사용하는 것도 고려하는데 .. **프로덕션 레벨에서의 테스트를 말하는걸로 보인다**

2.3 성능 안티 패턴의 원인에서 2.3.4 이해부족 설명할때 너무 공감함 .. 
`(..) 예를 들어 하이버네이트는 객체와 데이터베이스 간의 변환을 단순화하는 솔루션으로 보일 수 있습니다. 그러나 이를 충분히 이해하지 못한 상태에서는 오히려 시스템의 복잡성을 더하거나 장애를 유발할 위험이 있습니다. 😂`

p60
`기술적 문제에 대한 논의가 팀 내에서 자유롭게 이루어지도록 독려하고, 불확실한 점이 있다면 실제 데이터를 수집하거나 프로토타입을 만들어 검증하는 과정을 거쳐야 합니다. 새로운 기술이 매력적으로 보이더라도, 프로토타입 결과가 기대에 미치지 못한다면 팀은 보다 신중한 결정을 내릴 수 있습니다`

p65 트랜잭션 시간 분포의 보다 현실적인 모습


2.5 통계 해석 
거짓 상관관계

**2장 요약(p79)**
성능 테스트 7가지 유형을 다룬다 
- `지연 테스트`: 시작부터 끝까지의 트랜잭션 시간은 얼마나 걸립니까?
- `처리량 테스트`: 현재 시스템 용량으로 몇 개의 동시 거래를 처리할 수 있습니까?
- `스트레스 테스트`: 시스템의 한계쩜은 무엇인가요?
- `부하 테스트`: 시스템이 특정 부하를 처리할 수 있나요?
- `내구성 테스트`: 시스템을 장시간 실행했을 때 어떤 성능 이상이 발견될 수 있나요?
- `용량 계획 테스트`: 추가 리소스를 투입했을 때 시스템이 예상대로 확장되나요?
- `성능 저하 테스트`: 시스템이 부분적으로 장애가 발생했을 때 어떻게 처리되나요?

성능 안티패턴 , 통계, 해석, 인지 편향

성능 결과를 평가할 떄는 데이터를 적절히 처리하고 비과학적이거나 주관적인 사고에 빠지지 않을 것이 중요하다. 특히 적절하지 않은 상황에서 정규 분포 모델에 의존하는 통계적 오류를 피하는 것이 필요합니다. 

---
## 3장
자바 프로세스 실행시 과정 간략히 다룸 
- `부트스트랩 로더`와 `사용자 정의 애플리케이션 로더`
- 참고를 할 때 초기화

`HelloWorld.java` 예제를 해봄 

### 3.4 JIT 컴파일 소개 
자바 프로그램은 실행 시 바이트코드 인터프리터에서 시작하며, 명령어는 가상화된 스택 머신에서 처리됩니다. CPU로부터 추상화된 이 방식은 클래스 파일의 이식성이라는 장점을 제공하지만, 최적의 성능을 얻으려면 프로그램이 **네이티브 기능을 최대한 활용**해야 합니다.

핫스팟 가상 머신은 해석된 바이트코드를 네이티브 코드로 컴파일하여 성능을 향상시킵니다. 네이티브코드는 인터프리터를 거치지 않고 직접 실행됩니다. 핫스팟 가상 머신에서 컴파일 단위는 메서드와 루프이며, 이 과정을 JIT 컴파일이라고 합니다. 

### 3.5 자바 가상 머신 메모리 관리 

C, C++, 오브젝트 C와 같은 언어에서는 프로그래머가 직접 메모리를 할당하고 해제해야 함 
(..) 개발자가 언어 기능을 처리하는 데 많은 시간을 드이다 보니, 정작 비즈니스 가치를 창출하는 데 집중하지 못할 위험이 있었기 때문이다. 

자바에서는 **가비지 컬렉션**을 통해 자동으로 관리되는 힙 메모리를 도입함.
즉, 자바 가상 머신이 더 많은 메모리 할당이 필요할 때, 더 이상 필요하지 않은 메모리를 회수하고 재사용하는 비결정적 프로세스를 수행 

개발자가 직접 메모리를 관리하지 않아도 되면, 애플리케이션의 안정성과 정확성이 향상되는 장점이 있습니다. (..) 가비지 컬렉션은 실행 중인 애플리케이션에 긍정적인 영향이나 부정적인 영향을 미칠 수 있습니다. 

p96
> [!note] 자바 21 이전의 모든 스레드(또는 플랫폼 스레드)는 Thread 객체의 start() 메서드가 호출될 떄 생성되는 고유한 운영체제(OS) 스레드로 지원된다고 간주해도 안전합니다 


**3.8 자바 구현, 배포 또는 릴리스**



---
p30 (`도서 하단 목차 기준`)

개정판에서는 네 가지 주요 목표를 제공 
1. 단일 자바 가상 머신에서 실행되는 애플리케이션 코드의 성능에 대한 심층 분석
2. 자바 가상 머신 내부 구조에 대한 논의 
3. 현대 클라우드 스택이 자바/자바 가상 머신 애플리케이션과 상호 작용하는 방식에 대한 세부 사항
4. 클라우드 환경에서 클러스터로 실행되는 자바 애플리케이션의 동작에 대한 첫 번째 고착


**1.1 잘못된 자바 성능 최적화 방법**
'모든 코드를 하나의 메서드에 몰아 넣으라'는 조언을 따른 코드는 이제 현대의 JIT 컴파일러와 매우 부조화여서 오히려 성능 저하를 초래합니다.

p31

이 잘못된 조언을 따른 애플리케이션의 성능이 얼마나 손상되었는지는 알 수 없지만, 이 사례는 성능 문제에 정량적이고 검증할 수 있는 접근 방식을 사용하지 않을 때의 위험성을 잘 보여줍니다. 또한, 인터넷에서 잡한 모든 내용을 맹신해서는 안된다는 교훈을 제공하는 좋은 사례이기도 합니다. 

다음과 같은 것은 존재하지 않습니다. 
- 자바 가상 머신 성능을 획기적으로 높여주는 '마법 같은' 스위치
- 자바를 더 빠르게 만드는 '팁과 트릭'
- 숨겨진 비밀 알고리즘 


**1.2 자바 성능 개요**
대표적인 예가 메모리 관리입니다. 자바 가상 머신은 플러그형 **가비지 컬렉션** 서브 시스템을 통해 자동으로 메모리를 관리하므로, 프로그래머는 메모리를 수동으로 추적할 필요가 x

자바 성능 데이터의 특성상 통계적으로 정교한 접근이 필요하며, 단순한 기법을 자바/자바 가상 머신 애플리케이션에 적용하면 잘못된 결과를 자주 산출합니다.


**1.3 실증 과학으로서의 기능**

가장 먼저 이해해야 할 핵심 개념은 자바 가상 머신이 빠른 플랫폼이라는 점이다.

p34
다시 말해 성능은 실증 과학입니다. 성능 튜닝은 다음과 같은 단계를 거쳐 진행됩니다. 
1. 원하는 결과를 정의합니다 
2. 기존 시스템을 측정합니다 
3. 요구사항을 충족하기 위해 필요한 작업을 결정합니다 
4. 개선 작업을 수행합니다 
5. 다시 테스트합니다
6. 목표가 달성되었는지 확인합니다.

> 1장에서는 단일 자바 가성 머신에 적용되는 성능 튜닝 기법을 다룸

p35

**1.4 성능을 위한 분류 체계**
성능을 관측할 수 있는 지표는 다음과 같습니다 
- 처리량 (throughput)
- 효율성 (effciency)
- 지연 시간 (latency)
- 확장성 (scablity)
- 수용량 (capacity)
- 성능 저하 
- 활용도

**1.4.1 처리량**
- 시스템이나 서브 시스템이 수행할 수 있는 작업의 속도를 나타내는 지표
- 예를 들어, 초당 시스템이 처리할 수 있는 거래 수를 측정할 수 있습니다
	- 성능 지표는 때때로 배관과 같은 비유로 설명됩니다 
	- 물 파이프가 초당 100리터의 물을 생성할 수 있다면, 1초 동안 생성된 물의 양(100리터)이 처리량입니다. 이 값은 물의 속도와 파이프의 단면적에 따라 결정됩니다.

**1.4.2 지연 시간**
- S/W에서는 지연시간이 보통 시작에서 끝까지 걸리는 시간으로 정의되며, 단일 거래를 처리하고 결과를 확인하는데 걸리는 시간을 의미합니다.
- 작업 부하에 따라 다를 수 있으므로, 작업 부하가 증가함에 따라 지연시간을 나타내는 그래프를 생성하는 것이 일반적입니다.

**1.4.3 수용량**
- 시스템이 보유한 병렬 처리 작업량을 의미하며, 시스템에서 동시에 진행할 수 있는 작업 단위(ex. 거래)수를 나타냅니다.
- 예를 들어, 파이프의 시작 부분에 큰 저수조가 있다면 수용량이 증가할 수 있지만 전체 처리량에는 영향을 주지 않을 수 있습니다. 
- 반대로 매우 좁은 입구를 가진 파이프는 수용량이 적을 수 있습니다.


**1.4.4 활용도**
- 성능 분석의 가장 일반적인 작업은 시스템 리소스의 효율적인 사용을 달성하는 것입니다. (..)
- CPU뿐만 아니라 네트워크, 메모리, 때로는 저장소 I/O 서브시스템과 같은 다른 자원 유형도 클라우드 네이티브 애플리케이션에서 관리할 중요한 자원이 되어가고 있습니다. 
- 많은 애플리케이션에서 CPU보다 더 많은 메모리가 낭비되며, 많은 마이크로 서비스에서 네트워크 트래픽이 진정한 병목 현상이 되고 있습니다. 
- 예를 들어, 파이프의 입구가 좁을 경우 파이프 대부분이 높은 처리량을 가지더라도 입구 제한 때문에 전체 활용도가 낮을 수 있습니다. 즉, 파이프 내 물 수준이 낮게 유지됨)

**1.4.5 효율성**
- 동일한 처리량을 생산하는 데 더 많은 자원이 필요하다면, 이는 덜 효율적이라는 유용한 정의 중 하나가 되기 때문입니다. 

**1.4.6 확장성**
- 자원을 추가할 때 처리량이 어떻게 변하는지를 기준으로 정의하는 것이 유용함
- 이상적인 시스템 확장성은 자원이 증가하면 처리량이 정확히 비례하여 증가하는 것입니다.
- 시스템 확장성은 여러 요인에 의존하며, 일반적으로 단순한 선형 관계가 아닙니다 
- 일부 자원 범위에서는 시스템이 거의 선형적으로 확장되지만, 부하가 높아지면 완벽한 확장을 방해하는 한계를 마주하는 경우가 흔합니다. 

**1.4.7 성능 저하**
- 예를 들어, 일반적으로 시스템의 부하가 증가하면 활용도가 변하게 됩니다. 그러나 시스템이 낮은 활용 상태라면 부하를 증가시키더라도 활용도가 눈에 띄게 증가하지 않을 수 있습니다. 
- 반대로 시스템이 이미 과부하 상태라면 부하 증가의 영향이 다른 관측 지표에 나타날 수 있습니다. 
- 또 다른 예로, 확장성과 성능 저하는 둘다 부하가 증가함에 따라 시스템의 동작이 어떻게 변하는지를 나타냅니다. 확장성의 경우, 부하가 증가할 때 자원도 함께 추가되며, 시스템이 이러한 자원을 활용할 수 있는지가 핵심입니다. 
- 반면에, 부하는 증가하나 추가 자원이 제공되지 않으면 일부 성능 지표(ex. 지연시간)의 저하가 예상됩니다.


**1.5 성능 그래프 읽기**

> [!note] 성능 엘보(performance elbow)
> 증가하는 부하 아래에서 성능 (이 경우, 지연 시간)의 갑작스럽고 예기치 않게 저하되는 현상

> [!note] 암달의 법칙
> 이 법칙이 제시하는 확장성의 근본적인 제약을 그래프로 나타낸 것으로, 작업에 할당된 프로세서 수를 증가시킬 때 성능 향상 비율이 점점 감소하는 패턴을 보인다 



p42
sw 시스템 성능 그래프에서 자주 다루는 또 다른 주제는 메모리 활용도 (memory utilization) 입니다. 
- JVM의 GC 하위 시스템에 사용된 기술은 자연스럽게 스트레스 받지 않는 정상적인 애플리케이션에서 메모리 사용량이 '톱니형'패턴으로 나타나게 됩니다. 
- 이는 이클립스 어답티움에서 제공하는 JDK 미션 컨트롤(JMC) 도구의 스크린샷을 보여줍니다. (생략)

자바 가상 머신의 주요 성능 지표 중 하나는 **할당 속도(allocation rate)** 입니다 
- 할당 한계에 도달한 상태와 시스템에 자원 누수가 발생한 상태는 다른 문제라는 것입니다. 


p44
**1.6 클라우드 시스템의 성능**
분산 시스템 운영자는 다음과 같은 사항을 고려해야 합니다.
- 클러스터 내에서 작업이 어떻게 분배되는가?
- (..)

또한 클라우드 시스템에서는 단일 자바 가상 머신 환경과는 다른 두 가지 중요한 측면이 존재합니다. 
이러한 차이점은 .. 초보자들에게 처음에 명확하게 드러나지 않을 수 있습니다. 

1. 클라우드에서 배포 가능한 코드의 단위가 애플리케이션의 자바 가상 머신 프로세스가 아니라 **컨테이너**라는 점입니다.
	1. 분산 배포 환경을 기준으로 설명하는 듯 하다
2. 서비스에서 클라우드 제공업체르 사용하는 방식에 따라 효율성이나 활용도가 서비스 운영 비용에 직접적인 영향을 미친다는 점입니다. 

> 과거에는 팀이 데이터 센터의 특정 구역(일반적으로 **케이지**라 부름)에 실제 물리 서버를 소유하는 경우가 많았습니다. 이 서버 구매는 **자본 지출**을 의미하며, 자산으로 관리되었습니다. 
> 
> 반면 클라우드 서비스 회사가 소유한 머신의 시간을 임대하게 됩니다. 이는 **운영 비용**에 해당하며, 서비스의 비용(혹은 부채)으로 관리됩니다.

---
## 2장 성능 테스트 방법론 

**2.1 성능 테스트 종류**
성능 테스트는 종종 잘못된 이유로 수행되거나, 부실하게 진행됩니다. 
- 이유는 다양하지만, 대개는 성능 분석의 본질을 제대로 이해하지 못했거나, '아무것도 하지 않는 것보다는, 무언가를 하는 것이 낫다'는 믿음으로부터 시작됩니다.😂
- 이러한 믿음은 위험한 반쪽짜리 진실에 불과하다는 것을 이 책을 통해 알게 될 것입니다. 

흔히 저지르는 실수 중 하나는 구체적인 사항을 고려하지 않은 채 단순히 성능 테스트라는 용어를 일반적으로 사용하는 것입니다. 

p48
가장 일반적인 테스트 유형들과 각 유형의 예시 질문은 다음과 같습니다. 
- `지연 테스트`: 시작부터 끝까지의 트랜잭션 시간은 얼마나 걸립니까?
- `처리량 테스트`: 현재 시스템 용량으로 몇 개의 동시 거래를 처리할 수 있습니까?
- `스트레스 테스트`: 시스템의 한계쩜은 무엇인가요?
- `부하 테스트`: 시스템이 특정 부하를 처리할 수 있나요?
- `내구성 테스트`: 시스템을 장시간 실행했을 때 어떤 성능 이상이 발견될 수 있나요?
- `용량 계획 테스트`: 추가 리소스를 투입했을 때 시스템이 예상대로 확장되나요?
- `성능 저하 테스트`: 시스템이 부분적으로 장애가 발생했을 때 어떻게 처리되나요?

**2.1.1 지연 테스트**
- '우리 고객들이 트랜잭션이나 페이지 로드를 위해 얼마나 기다리고 있는가?'와 같은 지표
- 신중히 다뤄야할 몇가지 사항 
	- 가장 두드러지는 점은 단순한 평균값이 애플리케이션 요청에 얼마나 잘 반응하는지 측정하는데 크게 유용하지 않다는 것입니다. 

**2.1.2 처리량 테스트**
- 성능 테스트에서 두 번째로 일반적인 측정 지표일 것입니다. 
- 처리량 테스트는 지연 테스트와 어느정도 이중적인 관계가 있습니다. 
- 우리는 최대 처리량을 지연 분포가 갑자기 변화하는 순간을 관찰해서 결정합니다. 이는 사실상 시스템의 한계점(변곡점)입니다. 
- **스트레스 테스트의 목적**은 이러한 한계점과 그것이 발생하는 부하 수준을 찾는 것입니다. 
- **반면에 처리량 테스트**는 시스템이 성능 저하를 시작하기 전까지 관찰된 최대 처리량을 측정하는 것입니다. 

**2.1.3. 스트레스 테스트**
- 시스템의 여유 용량이 얼마나 있는지를 확인하기 위한 방법으로 생각할 수 있습니다. 
- 이 테스트는 시스템을 일정한 상태의 트랜잭션 상태에 두고, 동시 트랜잭션 수를 천천히 증가시켜 시스템의 성능이 저하되기 시작하는 지점을 찾는 방식으로 진행합니다.

**2.1.4 부하 테스트**
- 처리량 테스트(또는 스트레스 테스트)와는 다름 
- 보통 '시스템이 예상 부하를 처리할 수 있는가?'라는 이진적 테스트로 정의합니다

**2.1.5 내구성 테스트**
- 일부 문제들은 매우 오랜 시간 동안 또는 몇일 단위로 측정되곤 합니다. 
- 여기에는 느린 메모리 누수, 캐시 오염, 메모리 단편화 등이 포함됨
- 내구성 테스트는 실행하는데 많은 시간이 걸리고 비용이 많이 들기 때문에, 아마도 필요한 만큼 자주 수행되지 않는 경우가 많습니다. 하지만 이 과정에는 지름길은 없습니다. 
- .. 이러한 상황 때문에 많은 팀이 결국 '프로덕션 환경에서 테스트'를 하게 됩니다. 

**2.1.6 용량 계획 테스트** 
- 스트레스 테스트는 현재 시스템이 견딜 수 있는 한계를 찾는 것이 목적이라면, 용량 계획 테스트는 더 미래지향적입니다
- 이는 업그레이드 된 시스템이 어떤 부하를 처리할 수 있는지 찾는 것을 목표로 합니다

**2.1.7 성능 저하 테스트**
- 부분 실패 테스트라고도 불립니다
- 회복력 테스트의 한 유형
- 예를 들면, 애플리케이션 서버 클러스터가 갑자기 멤버를 잃거나 네트워크 대역폭이 갑자기 떨어지는 경우가 있습니다. 
- 성능 저하 테스트의 주요 관찰 항목으로 트랜잭션 지연 분포와 처리량이 포함됩니다.

> [!note] 카오스 몽키(Chaos Monkey)
> - 넷플릭스가 자사 인프라의 강건성을 검증하기 위해 수행한 프로젝트에서 유래
> - 기본 아이디어는 진정으로 회복력있는 아키텍처에서는 단일 구성 요소의 실패가 연쇄적인 실패를 유발하거나 시스템 전체에 유의미한 영향을 미쳐서는 안 된다는 것입니다


**2.2 모범 사례 개론**
성능 조정 작업에서 집중할 지점을 결정할 떄 다음 세가지 규칙을 고려 
- 중요한 요소가 무엇인지 파악하고 이것을 측정하는 방법을 찾으세요
- 최적화하기 쉬운 것보다 중요한 것을 최적화하세요
- 가장 큰 영향을 미치는 요소부터 최적화를 시작하세요


**2.2.1 탑다운 성능**

> [!note] 애플리케이션 전체의 성능 동작을 분석하는 접근 방식을 일반적으로 **탑다운 성능**이라고 부릅니다

p54
프로덕션 환경과 동일한 부하를 처리할 수 없는 서드파티 네트워크 서비스 같은 요소는 현실적인 성능 테스트를 위해 목(Mock) 서비로 대체해야 합니다. 

몇 가지 중요한 고려 사항 
- 테스트 환경에서 변경 사항을 먼저 적용한 후 프로덕션에 반영할 수 있는 프로세스를 갖출 것
- 테스트 환경에서 의도치 않은 프로덕션 의존성을 제거할 것
- 테스트 환경에서 실제 인증 또는 권한 시스템을 적용하고, 더미 구성 요소를 사용하지 않을 것

클라우드 기반 배포 환경의 장점 중 하나는 테스트 환경을 사용하지 않을 때 종료할 수 있다는 점입니다. 이를 통해 프로젝트 비용을 크게 절감 할 수 있다.


**2.2.3 성능 요구사항 식별**
성능을 평가할 때 사용하는 지표를 특정 요소에만 한정해서는 안된다
시스템을 전체적으로 바라보며 고객과 경영진에게 중요하고 관찰 가능한 지표들을 고려해야 한다
이러한 지표들은 보통 성능 **비기능 요구사항(NFRs)** 이라고 하며 최적화하려는 주요 대상입니다

다음 성능 목표는 누구나 쉽게 이해 가능
- 95% 기준 트랜잭션 시간을 100밀리초 줄이기 
- 현재 하드웨어로 처리량을 5배 높이기
- 평균 응답 시간을 30% 개선하기
하지만 일부 목표는 더 복잡할 수 있습니다 
- 고객 1명을 서비스하는데 드는 리소스 비용을 50% 줄이기
- 애플리케이션 클러스터가 절반으로 줄어들더라도 목표 성능 25% 이내로 유지하기
- 지연 시간을 10밀리초 단축해 고객 이탈 비율을 25% 낮추기 

**2.2.5 자바 특유의 문제들**

예를 들어, 현재 자바 가상 머신은 실행 중인 메서드를 분석해 최적화된 기계어 코드로 변환하기 위한 JIT 컴파일 후보를 자동으로 선정합니다. 만약 특정 메서드가 JIT 컴파일되지 않는 다면 그 이유는 다음 두 가지 중 하나일 가능성이 큽니다.
- 메서드가 컴파일될 만큼 자주 실행되지 않는다 
- 메서드가 너무 크거나 복잡하여 컴파일을 위한 분석이 불가능하다


p57
### 2.3 성능 안티 패턴의 원인 
안티 패턴은 여러 소프트웨어 프로젝트나 팀에서 공통적으로 나타나는 바람직하지 않은 행동이나 방식입니다. 

(..) 이러한 안티 패턴은 때로는 팀 내뷰의 제약, 잘못된 관리 방식, 혹은 개발자 특유의 인간적인 성향 때문에 발생하기도 합니다. 

(..) 성능 최적화는 항상 명확한 목표를 세우고 계획 단계에서부터 객관적으로 접근해야 합니다. 그러나 이는 생각보다 쉽지 않습니다. 팀이 압박을 받거나 적절한 환경에서 작업하지 못할 경우, 이러한 접근이 무실될 수 있습니다. 

(..) 많은 개발 문제에서 기술적인 요소보다는 소통 부족과 같은 인간적인 요소가 애플리케이션 무넺의 주요 원인이 되곤 합니다.

한편 캐리 플리첼이 작성한 블로그 글 ['개발자들이 잘못된 기술 선택을 계속하는 이유'](https://web.obsidianscheduler.com/why-developers-keep-making-bad-technology-choices/)


**2.3.1 지루함**

(..) 많은 사람이 일에서 의욕을 잃고 그저 버티는 개발자나, 더 쉬운 일을 찾아 떠나는 개발자를 본적이 있을 겁니다. 그러나 지루함을 느끼는 개발자는 프로젝트에 여러 가지 부정적인 영향을 미칠 수 있습니다. 

**2.3.2 이력 부풀리기**
때로는 개발자가 특정 기술을 과도하게 사용하는 이유가 지루함이 아닌 이력서나 CV에 해당 기술 경험을 추가하여 경력 시장에서 자신을 더 유리한 위치에 두기 위한 것일 수도 있습니다. 

(..) 개발자의 지루함이나 이력서 관리를 위해 불필요한 기술이 추가되면 그 결과는 광범위하고 오래 지속될 수 있습니다. 특히, 원래 개발자가 떠난 후에도 해당 기술의 도입으로 팀이 여러 해 동안 부담을 안게 될 가능성이 있습니다. 

**2.3.3 사회적 압박**
기술적 결정이 가장 나쁠 떄는 결정을 내리는 과정에서 우려 사항이 충분히 표현되거나 논의되지 않았을 떄입니다. 

**2.3.4 이해 부족**
개발자가 문제를 해결하기 위해 새로운 도구를 도입하려는 시도는 종종 기존 도구의 기능을 충분히 이해하지 못한 곳에서 비롯됩니다. 

(..) 예를 들어 하이버네이트는 객체와 데이터베이스 간의 변환을 단순화하는 솔루션으로 보일 수 있습니다. 그러나 이를 충분히 이해하지 못한 상태에서는 오히려 시스템의 복잡성을 더하거나 장애를 유발할 위험이 있습니다. 😂

**2.3.5 문제에 대한 오해 또는 문제 자체의 부재**
기술을 도입하려는 이유가 명확하게 검토되지 않으며, 문제 자체를 제대로 파악하지 않은 상태에서 해결책이 제시되는 경우가 있습니다. 

p60
`기술적 문제에 대한 논의가 팀 내에서 자유롭게 이루어지도록 독려하고, 불확실한 점이 있다면 실제 데이터를 수집하거나 프로토타입을 만들어 검증하는 과정을 거쳐야 합니다. 새로운 기술이 매력적으로 보이더라도, 프로토타입 결과가 기대에 미치지 못한다면 팀은 보다 신중한 결정을 내릴 수 있습니다`


### 2.4 자바 가상 머신 성능을 위한 통계 

`논문에 따르면, 동적인 sw 시스템(자바 가상머신)에서 통계적으로 유의미한 결과를 얻으려면 최소 30번의 실행이 필요합니다`

**2.4.1 오차 유형**
엔지니어가 성능 분석에서 마주할 수 잇는 주요 오차는 두 가지가 있음 
- `무작위 오차`: 측정 과정에서 발생하는 오차로, 서로 관련 없는 다양한 요인이 결과에 영향을 미치는 경우를 말함
- `체계적 오차`: 특정 요인이 지속적으로 결과 측정에 영향을 미치는 경우를 말함 


그림2-2 정규 분포(가우스 분포 또는 종 모양 곡선)
그림2-4 트랜잭션 시간 분포의 보다 현실적인 모습 

p66 자바 가상 머신이 생성하는 비정규의 롱테일 분포를 다룰 때 유용한 기법 중 하나는...

### 2.5 통계 해석 

**2.5.1 거짓 상관관계**
통계에서 가장 유명한 격언은 '상관관계는 인과관계를 의미하지 않는다'입니다. 즉, 두 변수가 유사한 패턴을 보인다고 해서 실제로 서로 연결되어 있다고 단정할 수는 없습니다. 

이 개념은 **성능 엔지니어가 반드시 이해해야 할 중요한 원칙으로 (..)**
상호 연관된 두 이벤트 A와 B 사이에는 다음과 같은 관계가 있을 수 있습니다. 
- A가 B를 유발한다(직접적 인과관계)
- B가 A를 유발한다(역방향 인과관계)
- A와 B는 C라는 공통 요인으로 동시에 유발된다 (공통 인과관계)
- A와 B 사이에는 아무런 연관이 없으며, 상관관계는 단순히 우연이다

### 2.6 인지적 편향과 성능 테스트

**인지 편향**은 인간의 뇌가 잘못된 결론을 내리게 유도하는 심리적 효과입니다. 특히, 인지 편향을 겪는 사람은 대게 이를 인식하지 못하며, 오히려 자신이 합리적인 판단을 한다고 믿기 때문에 문제가 됩니다.

예를 들어, **책임 전가** 안티 패턴에서는 특정 컴포넌트가 최근 여러 차례 장애를 일으킨 경우, 팀은 새로운 성능 문제의 원인도 해당 컴포넌트일 것이라고 쉽게 단정하는 경향이 있습니다. 그리고 분석된 데이터가 이 가설을 뒷받침하는 것처럼 보이면, 해당 데이터를 더욱 신뢰할 만한 정보로 받아들이게 됩니다. 

모든 성능 엔지니어가 주의해야 할 대표적인 편향을 소개하겠습니다 

> 함정을 아는 것, 그것이 회피의 첫 걸음입니다. 


**2.6.1 환원주의적 사고 편향**
시스템을 충분히 작은 부분으로 나누면 구성 요소를 이해함으로써 전체 시스템을 파악할 수 있다는 분석적 접근에 기반합니다. 각 부분을 이해하면 잘못된 가정을 줄일 수 있다고 생각하는 것입니다. 

**2.6.2 확증 편향**
확증 편향은 성능 테스트나 애플리케이션을 객관적으로 분석하는 과정에서 큰 문제를 일으킬 수 있습니다. 이 편향은 보통 의도하지 않게 발생하며, 부적절한 테스트 집합이 선택되거나 통계쩍으로 타당한 분석이 이루어지지 않을 때 나타납니다. 특히, 팀 내에서 특정 의견을 증명하려는 동기나 감정적인 요인이 종종 작용하면서 더욱 극복하기 어려운 편향 중 하나입니다.

**2.6.3 혼란 속의 행동 편향**
혼란 속의 행동 편향은 시스템이 예상대로 작동하지 않거나 장애가 발생했을 때, 팀이 압박을 받는 상황에서 자주 나타납니다. 

**2.6.4 위험 편향**
사람은 본래 위험을 회피하려는 성향이 강하며, 변화에 저항하는 경향이 있습니다. 

강력한 단위 테스트와 프로덕션 저하 테스트를 통해 이런 위험 편향을 상당 부분 줄일 수 있습니다. 

그러나 팀이 이 테스트들을 충분히 신뢰하지 못하면, 변화는 더욱 어려워지고 위험 요소를 효과적으로 통제할 수 없습니다. 이러한 편향은 애플리케이션 문제(서비스 중단 포함)에서 교훈을 얻지 못하고, 적절한 대응 방안을 마련하지 못하는 형태로 자주 드러납니다. 

---
### 3.1 인터프리팅과 클래스 로딩 
자바 가상 머신은 스택 기반 인터프리터 머신입니다.

이는 HW CPU 처럼 레지스터를 사용하는 대신, 연산의 중간 결과를 저장하는 실행 스택을 사용하며, 스택의 최상위 값(또는 값들)을 기반으로 계싼을 수행한다는 것을 의미합니다.

새로운 자바 프로세스가 초기화될 때, 클래스 로더 체인이 활용됩니다. 초기 로더는 **부트스트랩 클래스 로더**이며, 핵심 자바 런타임에 필요한 클래스를  로드합니다. 부트스트랩 클래스 로더는 java.lang.Object, Class.ClassLoder와 같은 필수적인 클래스를 불러와 자바 시스템의 나머지 부분이 정상적으로 동작할 수 있도록 합니다.

(..) p84
마지막으로 애플리케이션 클래스 로더가 생성됩니다. 이 로더는 클래스 경로에서 사용자 클래스를 로드하는 역할을 합니다. 

자바는 프로그램 실행 중 새로운 클래스가 처음 참조될 때 해당 의존성을 로드합니다. 만약 클래스 로더가 클래스를 찾지 못하면, 일반적으로 조회 작업을 부모 클래스 로더에 위임합니다. 조회 체인이 부트스트랩 클래스 로더까지 도달했음에도 클래스를 찾을 수 없으면, ClassNotFoundException이 발생합니다. 따라서 개발자는 반드시 프로덕션 환경과 동일한 클래스 경로로 컴파일 되는 빌드 프로세스를 사용해야 하며, 이를 통해 잠재적인 문제를 방지할 수 있습니다. 


### 3.4 JIT 컴파일 소개 
자바 프로그램은 실행시 바이트코드 인터프리터에서 시작하며, 명령어는 가상화된 스택 머신에서 처리됩니다. CPU로부터 추상화된 이 방식은 클래스 파일의 이식성이라는 장점을 제공하지만, 최적의 성능을 얻으려면 프로그램이 네이티브 기능을 최대한 활용해야 합니다. 

**핫스팟 가상 머신**은 해석된 바이트코드를 네이티브 코드로 컴파일하여 성능을 향상시킵니다. 네이티브 코드는 인터프리터를 거치지 않고 직접 실행됩니다. 핫스팟 가상 머신에서 컴파일 단위는 메서드와 루프이며, 이 과정을 **JIT 컴파일**이라고 합니다


### 3.5 자바 가상 머신 메모리 관리 

> 자바 가비지 컬렉션에 대한 소개

즉, 자바 가상 머신이 더 많은 메모리 할당이 필요할 때, 더이상 필요하지 않은 메모리를 회수하고 재사용하는 비결정적 프로세스를 수행합니다. (= 가비지 컬렉션)

p36
### 3.6 스레딩과 자바 메모리 모델

1990년대 후반에 설계되었으며, 다음과 같은 기본 설계 원칙을 따릅니다. 
- 자바 프로세스의 모든 스레드는 하나의 공통적인 GC 힙을 공유합니다
- 하나의 스레드에서 생선된 객체는 해당 객체에 대한 참조를 가진 다른 스레드에서 접근할 수 있습니다
- 객체는 기본적으로 변경 가능합니다. 즉, 객체 필드에 저장된 값은 프로그래머가 명시적으로 final 키워드를 사용해 불변임을 표시하지 않는 한 변경될 수 있습니다. 

> [!note] 자바 21 이전의 모든 스레드(또는 플랫폼 스레드)는 Thread 객체의 start() 메서드가 호출될 때 생성되는 고유한 운영 체제(OS) 스레드로 지원된다고 간주해도 안전합니다. 

`애플리케이션 스레드 == 플랫폼 스레드` ? 


### 3.7 자바 가상 머신 모니터링 또는 도구 

자바 가상 머신은 성숙한 실행 플랫폼으로, 실행 중인 애플리케이션의 계측, 모니터링, 관측성을 지원하기 위한 다양한 기술적 대안을 제공합니다. 
- 자바 관리 확장 프로그램(JMX)
- 자바 에이전트
- 자바 가상 머신 도구 인터페이스 (JVMTI)
- 서비스 지원 에이전트 (SA)

// 커맨드 옵션을 줄 수 있다는거 처음알았네 

자바 가상 머신 도구 인터페이스는 네이티브 에이전트가 자바 가상 머신에서 발생하는 이벤트를 모니터링하거나 통보받을 수 있도록 하는 통신 인터페이스로 간주할 수 있습니다. 


**VisualVM(p100)**
- 비주얼 가상 머신은 실행중인 프로세스를 실시간으로 모니터링하는 도구
- 자바 가상 머신의 attach 메커니즘을 활용

비주얼 가상 머신은 기본적으로 사용자에게 다섯 개의 탭을 제공합니다 (p103 생략)
- 개요
- 모니터
- 스레드
- 샘플러와 프로파일러 

### 3.8 자바 구현, 배포 또는 릴리스 




---
p300 
로그 이후로 ELK 스택 간단하게 설명하는게 인상 깊음


p42
JDK 미션 컨트롤(JMC) 

p57
캐리 플리첼이 작성한 블로그 글 ['개발자들이 잘못된 기술 선택을 계속하는 이유'](https://web.obsidianscheduler.com/why-developers-keep-making-bad-technology-choices/)




