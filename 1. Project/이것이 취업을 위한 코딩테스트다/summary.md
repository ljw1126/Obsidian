### Ch3. 그리디

### Ch4. 구현

### Ch5. DFS/BFS

### Ch6. 정렬

### Ch7. 이진 탐색

### Ch8. 다이나믹 프로그래밍

>[!note]  **다이나믹 프로그래밍과 동적 할당의 다이나믹은 같은 의미일까?**
> 프로그래밍에서 다이나믹은 '프로그램이 실행되는 도중에'라는 의미이다. 예를 들어 자료구조에서 동적할당(Dynamic Allocation)은 프로그램 실행 중에 프로그램 실행에 필요한 메모리를 할당하는 기법이다. 하지만 다이나믹 프로그래밍에서의 '다이나믹'은 이런 의미가 아니라는 것만 기억하자


 다이나믹 프로그래밍은 **메모이제이션(memorization) 기법**을 사용해서 이미 연산된 결과를 메모리에 저장해두고 캐싱하여 재사용하는 방식을 사용함으로써 중복되는 연산을 제거하고 시간을 줄일 수 있다.

 다이나믹 프로그래밍은 두 가지 방법으로 풀이 가능하다
① 탑다운(Top-Down), 하향식 : **재귀** 사용, 큰 문제를 풀기 위해 작은 문제를 호출하여 답을 구함 
② 보텀업(Bottom-up), 상향식 : **반복문** 사용, 순차적으로 작은 문제부터 답을 구함

> [!iinfo]
> - 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다 
> - 이미 계산된 결과를 일시적으로 기록해 넣는 개념으로 다이나믹 프로그래밍과는 별도의 개념이다


**실전 문제 링크**
- [[1로 만들기]]
- [[개미전사]]
- [[바닥공사 (🔺)]]
- [[효율적인 화폐 구성]]

---
### Ch9. 최단 경로
- **노드(vertex)** : 그래프에서 각 지점을 노드
- **간선(edge)** : 그래프에서 노드와 노드를 연결하는 선
	- 간선은 **단방향**과 **양방향** 두 가지로 나누어진다
	- 문제에 단방향이 주어지지 않는 경우 양방향을 고려하기도 해야 한다

그래프 간선 정보를 나타내는 방법으로 두 가지가 있다
① <font color="#ffff00">인접 행렬</font>(Adjacency Matrix)
- 2차원 배열 사용하여 간선 정보 표기, 노드에 연결된 간선 조회시 O(N) 걸림
- `int[][] edges`
② <font color="#ffff00">인접 리스트(Adjacency List)</font> 
- 리스트를 사용하여 노드에 연결된 간선 정보만 기록하여 사용
- **리스트 두 번 사용하는게 나은 걸로 기억** (넥스트 스텝하면서..)
- `List<List<Integer> adj` 나 `List<Integer>[] adj`

>[!Note] 참고. "이펙티브 자바 - 아이템 28. 배열보다는 리스트를 사용하라"
>https://www.notion.so/1-63df98c617084e7fa39dd95829d76a9c#6cee0f1de15649b5bacbdd3b99a751d3

> [!note]
> 다익스트라 알고리즘을 사용할 때 음수 간선이 존재하면 안된다 
> 음수 간선이 존재할 경우 무한 루프 발생 가능, 이 경우 벨만 포트 알고리즘을 사용해야 함


**최단 거리 알고리즘**
① 다익스트라 : O(ElogV)
② 플로이드 워셜 : O(V^3)
③ 벨만 포드 : O(VE), 음수 간선이 있을 때 사용

**실전 문제 링크**
- [[미래 도시]]
- [[전보]]

---
### Ch10. 그래프 이론
**서로소 집합(Disjoint Sets)**
- <u>공통 원소가 없는 두 집합</u>을 의미
	- 예로 집합 `[1, 2]` 와 집합 `[3, 4]`는 서로소 관계이다
	- 반면 집합 `[1, 2]` 와 집합 `[2, 3]`은 공통 원소 2가 있기 때문에 서로소 관계가 아니다
- 서로소 집합 자료구조란 <u>서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조이다</u>
- 서로소 집합 자료구조는 union, find 연산으로 조작할 수 있다
	- `union` : 연산은 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
	- `find` :  특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
- 시간 복잡도 
	- 노드의 V개 있고, 최대 V - 1개의 union연산과 M개의 find 연산이 가능할 때 경로 압축 방식을 적용한 시간 복잡도는 `O(V + M(1 + logV))` (로그의 밑수는 2 - M/V)

```java

private void union(int[] parent, int a, int b) {
  int parentA = find(a, parent);
  int parentB = find(b, parent);

 // 크기가 작은 부모 노드로 갱신
  if(parentA < parentB) {
    parent[parentB] = parentA;
  } else {
    parent[parentA] = parentB;
  }
}

// 경로 압축 기법 적용
private int find(int n, int[] parent) {
  if(parent[n] == n) return n;

  return parent[n] = find(parent[n], parent);
}

```

>[!caution] 서로소 집합을 활용한 사이클 판별
> 서로 다른 노드의 루트 노드가 같은 경우 바라본다면 연결할 경우 cycle이 발생한다


**신장 트리**
- Spanning Tree
- <u>모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프</u>를 의미
- 최소 신장 트리는 모든 노드를 연결하는 비용이 최소가 되는 부분 그래프를 뜻함
	- 대표적으로 크루스칼 알고리즘과 프림 알고리즘 풀이가 있음
	- 크루스칼 알고리즘은 모든 간선을 비용순으로 오름차순 정렬해서 확인하기 때문에 시간 복잡도 `O(ElogE)`로 알려져 있다 
		- union-find 알고리즘과 같이 사용 

//절차

**위상 정렬**
- Topology Sort
- 순서가 정해져 있는 일련의 작업을 차레대로 수행해야 할 때 사용하는 알고리즘
- <u>방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'</u>
- 시간 복잡도 : `O(V + E)`
	- 차례대로 노든 모드를 확인하면서 해당 노드에서 출발하는 간선을 제거하게 된다
	- 결과적으로 노드와 간선을 모두 확인해야 한다는 측면에서 `O(V + E)` 시간이 소요된다

>[!info] 진입차수(Indegree)
>특정한 노드로 들어오는 간선의 개수

//절차 p291

