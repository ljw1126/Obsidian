### 문제 링크 
https://school.programmers.co.kr/learn/courses/30/lessons/42891

### 시간 복잡도 
- `O(NlogN)`
	- 정렬 시간이 가장 크다
### 풀이 

**효율성2. 오버플로우 이슈**
- 높이 차 `diff` 의 경우 최대 1억이라 int 형으로 선언해도 문제가 없다
- 반면, 넓이 `area` 구할 때 (하이라이트 `21`)
	- `{java} long area = diff * w` 할 경우 `int * int` 로 int범위 초과하여 오버플로우가 발생 
	- `{java} long area = (long)(diff * w)` 의 경우에도 마찬가지로 오버플로우 발생 후 long 캐스팅은 의미가 없음
- 그리고 구간에서 인덱스를 구할 때 (하이라이트 `29`)
	- `{java} sub.get((int) k % sub.size()).no;` 에서 오버플로우가 발생
	- `k` 가 **long 타입**인데 int 캐스팅시  

### 제출 코드
```java hl:18,21,29
import java.util.*;
import java.io.*;

class Solution {
    public int solution(int[] food_times, long k) {
        List<Food> foods = new ArrayList<>();
        for(int i = 0; i < food_times.length; i++) {
            foods.add(new Food(i + 1, food_times[i]));
        }

        Collections.sort(foods);

        int answer = -1;
        int w = foods.size();
        int prevTime = 0;
        int i = 0;
        for(Food f : foods) {
            int diff = f.time - prevTime; // 높이

            if(diff > 0) {
                long area = (long) diff * w; // 넓이 = 높이 * 너비
                if(area <= k) {
                    k -= area;
                    prevTime = f.time;
                } else {
                    List<Food> sub = foods.subList(i, food_times.length);
                    sub.sort(Comparator.comparingInt(a -> a.no));
                    
                    answer = sub.get((int) (k % sub.size())).no;
                    break;
                }
            }

            i += 1;
            w -= 1;
        }

        return answer;
    }
    
    private static class Food implements Comparable<Food> {
        private final int no;
        private final int time;

        public Food(int no, int time) {
            this.no = no;
            this.time = time;
        }

        public int compareTo(Food o) {
            if(this.time != o.time) {
                return this.time - o.time;
            }
            
            return this.no - o.no;
        }
    }
}
```