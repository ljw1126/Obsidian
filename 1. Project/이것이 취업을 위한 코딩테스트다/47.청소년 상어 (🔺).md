### 문제 링크
https://www.acmicpc.net/problem/19236

### 시간 복잡도 

### 풀이 
- 구현, 백트래킹

**실수.** 상어가 바라보는 방향에서 최대값의 생선을 먹는다고 해서 최적의 해를 찾을 순 없다. 모든 조합을 고려해야 하기 때문에 백트래킹으로 풀이를 해야 했다


### 제출 코드
```java
import java.util.*;
import java.io.*;

public class Main {

	private static StringBuilder sb = new StringBuilder();  
	private static InputProcessor inputProcessor = new InputProcessor();  
	  
	public static void main(String[] args) {  
	    input();  
	    pro();  
	    output();  
	}  
	  
	/**  
	 * 청소년 상어는 (0,0)에 있는 물고기를 먹고 시작하는데, 방향은 (0,0)에 위치했던 물고기와 같다  
	 * - (1,1)로 시작  
	 *  
	 * 물고기가 이동  
	 * - 물고기는 번호가 작은 물고기부터 순서대로 이동  
	 * - 한칸을 이동할 수 있고, 빈칸과 다른 물고기가 있는 칸으로 이동가능  
	 *   - 반면, 상어가 있거나 공간 경계는 이동 못함  
	 * - 각각의 물고기는 방향이 이동할 수 있는 칸을 향할 때 까지 방향을 45도 반시계 방향으로 회전 시킴 (i + 1 % 8)  
	 *   - 이동할 수 있는 칸이 없으면 이동하지 않고, 그외에는 이동  
	 *   - 이때 다른 물고기가 있는 칸으로 이동할때는 swap  
	 * * 물고기의 이동이 끝나면 상어 이동  
	 * - 같은 방향으로 한번에 여러 개의 칸을 이동 가능  
	 *   - 이때 물고기가 없는 빈칸은 이동 불가, 이동하는 중에 물고기는 먹지 않음  
	 * - 그 칸의 물고기를 먹고 방향을 가진다  
	 * - 상어가 이동할 수 있는 칸이 없으면 종료, 그외는 다시 물고기 이동 후 반복  
	 */  
	  
	private static final int[][] DIR = {  
	        {-1, 0},  
	        {-1, -1},  
	        {0, -1},  
	        {1, -1},  
	        {1, 0},  
	        {1, 1},  
	        {0, 1},  
	        {-1, 1},  
	};  
	  
	private static int[][][] maps;  
	private static int result;  
	  
	private static void input() {  
	    maps = new int[5][5][2]; // 0 : 번호, 1 : 방향  
	    for(int i = 1; i <= 4; i++) {  
	        for(int j = 1; j <= 4; j++) {  
	            int no = inputProcessor.nextInt();  
	            int dir = inputProcessor.nextInt();  
	  
	            maps[i][j][0] = no;  
	            maps[i][j][1] = dir - 1;  
	        }  
	    }  
	}  
	  
	private static void pro() {  
	    rec(maps, 1, 1, 0);  
	  
	    sb.append(result);  
	}  
	  
	private static void rec(int[][][] arr, int sharkX, int sharkY, int value) {  
	    int[][][] _arr = copy(arr);  
	  
	    // 상어가 물고기를 먹는다  
	    int total = value + _arr[sharkX][sharkY][0];  
	    _arr[sharkX][sharkY][0] = -1;  
	  
	    moveAllFishes(_arr, sharkX, sharkY);  
	  
	    List<int[]> nexts = findNextPositions(_arr, sharkX, sharkY);  
	    if(nexts.size() == 0) { // 상어가 이동할 위치가 없다  
	        result = Math.max(result, total);  
	        return;    
	    }  
	  
	    // 현재 상어 위치에 빈칸 표시 후 다음으로 이동  
	    _arr[sharkX][sharkY][0] = -1;  
	    _arr[sharkX][sharkY][1] = -1;  
	    for(int[] next : nexts) {  
	        rec(_arr, next[0], next[1], total);  
	    }  
	}  
	  
	private static int[][][] copy(int[][][] base) {  
	    int[][][] temp = new int[5][5][2];  
	    for(int i = 1; i <= 4; i++) {  
	        for(int j = 1; j <= 4; j++) {  
	            temp[i][j][0] = base[i][j][0];  
	            temp[i][j][1] = base[i][j][1];  
	        }  
	    }  
	  
	    return temp;  
	}  
	  
	private static void moveAllFishes(int[][][] arr, int sharkX, int sharkY) {  
	    for(int i = 1; i <= 16; i++) {  
	        int[] position = findFish(arr, i);  
	  
	        if(position == null) continue;  
	  
	        int x = position[0];  
	        int y = position[1];  
	        int no = arr[x][y][0];  
	        int dir = arr[x][y][1];  
	  
	        // 회전히먄서 이동 가능한 경우 (제자리 회전)  
	        for(int j = 0; j < 8; j++) {  
	            int _dir = (dir + j) % 8; // 제자리 회전인데 누적시키고 있었다..  
	            int dx = x + DIR[_dir][0]; // 제자리 회전 미스**  
	            int dy = y + DIR[_dir][1];  
	  
	            if(dx < 1 || dy < 1 || dx > 4 || dy > 4) continue;  
	            if(dx == sharkX && dy == sharkY) continue;  
	  
	            // 빈칸이나 물고기 영역 이동 가능, 이동 못하는 경우 제자리  
	            // to  
	            int _no = arr[dx][dy][0];  
	            int __dir = arr[dx][dy][1];  
	  
	            arr[dx][dy][0] = no;  
	            arr[dx][dy][1] = _dir; // 현재 물고기의 회전 방향  
	  
	            // from  
	            arr[x][y][0] = _no;  
	            arr[x][y][1] = __dir;  
	  
	            break;        }  
	    }  
	}  
	  
	private static int[] findFish(int[][][] arr, int no) {  
	    for(int i = 1; i <= 4; i++) {  
	        for(int j = 1; j <= 4; j++) {  
	            if(arr[i][j][0] == no) {  
	                return new int[] {i, j};  
	            }  
	        }  
	    }  
	  
	    return null;  
	}  
	  
	private static List<int[]> findNextPositions(int[][][] arr, int sharkX, int sharkY) {  
	    List<int[]> result = new ArrayList<>();  
	    int dir = arr[sharkX][sharkY][1]; // 여기 실수, maps정적 필드 사용
	    int x = sharkX;  
	    int y = sharkY;  
	    for(int i = 0; i < 4; i++) {  
	        x += DIR[dir][0];  
	        y += DIR[dir][1];  
	  
	        if(1 <= x && x <= 4 && 1 <= y && y <= 4 
	        && arr[x][y][0] != -1) {  
	            result.add(new int[] {x, y});  
	        }  
	    }  
	  
	    return result;  
	}  
	  
	private static void output() {  
	    try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) {  
	        bw.write(sb.toString());  
	        bw.flush();  
	    } catch (IOException e) {  
	        throw new RuntimeException(e);  
	    }  
	}  
	  
	private static class InputProcessor {  
	    private BufferedReader br;  
	    private StringTokenizer st;  
	  
	    public InputProcessor() {  
	        this.br = new BufferedReader(new InputStreamReader(System.in));  
	    }  
	  
	    public String next() {  
	        while (st == null || !st.hasMoreElements()) {  
	            try {  
	                st = new StringTokenizer(br.readLine());  
	            } catch (IOException e) {  
	                throw new RuntimeException(e);  
	            }  
	        }  
	  
	        return st.nextToken();  
	    }  
	  
	    public String nextLine() {  
	        String result = "";  
	  
	        try {  
	            result = br.readLine();  
	        } catch (IOException e) {  
	            throw new RuntimeException(e);  
	        }  
	  
	        return result;  
	    }  
	  
	    public int nextInt() {  
	        return Integer.parseInt(next());  
	    }  
	  
	    public long nextLong() {  
	        return Long.parseLong(next());  
	    }  
	}

}

```