- `2025-10-11(토)`

> DDD 에 대해 
> ✅ 신입 : 필요, 시니어 : 복잡

객체지향 != DDD
📌 DDD 꽤 복잡
- 에릭 에반스 도서 : DDD
	- 이해하기 힘들다 (개념이 추상적)
	- **📚 국내 도서**
		- 도메인주도 설계 구현
		- 도메인주도 설계 첫걸음 등등
		- 단, 그 다음 나온 책은 원서를 전체 커버하지 않는다 
---

>[!note] 
>DDD 를 개발 관점, 조직관점에서 얘기하기도 한다. 
>큰 문제에 대한 사고 방식이라.. DDD가 커버하는 범위가 넓다

`파트1`
- 에릭에반스 책의 전체 흐름 , 목차를 훓는다
	- 읽기 힘들고, 예제도 힘들고 💩
- DDD는 `패턴 집합`이다
	- 약간 GoF, Head First 디자인 패턴 같은 느낌
	- 각각의 패턴이 독립적
- 패턴 랭귀지 : 일정 패턴, 흐름의 집합 

`파트2`
- 엔티티, VO에 대한 오해
- 에그리게이트 개념 중심으로 설명 
	- 책의 파트4개 중 
- 우선순위 낮다.
- 개발자 관점 

>[!info] 후속 강의 파트3, 4 계획 중인데 따라 하기 어렵다. 거의 다 만들어서 후속 강의 오픈 예정

> 설계가 한방에 되는 줄 오해 👉 계속 뒤집는다.

---

### 오전 
> 객체지향 != DDD
> - 공통점 ❌ 

> 프로젝트에 DDD 개념을 섞어서 쓰다보니 객체지향과 DDD에 대한 혼란이 발생 

> DDD 가이드를 따르다보면 필요이상으로 복잡해 지는 부분도 있다

> 모든 책에는 저자의 주관적인 견해가 들어간다 (나는 이렇게 생각해)
> - 전제로 까는 컨텍스트가 있다.
> - 이게 곧 정답은 아니다

도메인에 관련 문제를 해결하는게 == sw

해결해야될 문제보다 기술에 꽂히는 시기가 있다 => 밸런스가 나중에 찾아간다 (중요한 시기)

sw의 본질적인 문제, 복잡성을 해결하기 위해 나온게 DDD 도서
- 구현 관점/기법에만 빠져 오해하기 쉬움 (!= 본질 아님, 이건 결과물이다)
	- 문제는 심플한데, 코드 복잡도가 높아질 수 있다.
- 📌`문제를 해결하기 위해 (사용자 요구사항 > 기능 > 유지보수) 어떻게 복잡성을 낮출 거냐`
	- 사고방식, 우선순위 모음 👉 복잡한 문제를 단순하게 풀 수 있다

`객체지향`
- 블라블라

`함수형` 
- 블라블라

`DDD`
- 우선순위, 사고방식 모음 >> **철학적인 관점**으로 설명 

> DDD 볼때마다 새롭다는데 ✨


**파트1. 동작하는 도메인 모델 만들기 (핵심)**
- DDD 정의 
- DDD 궁극적인 목적

> 이런 문제가 발생할때 이런 패턴을 사용하면 복잡도가 낮아질거다.

>도메인. 사용자가 프로그램을 사용하는 주제 영역
>- 어떤 기능을 쓰는가

<u>sw는 전체/큰 문제중에 범위를 먼저 줄이는/정하는 것으로 시작 </u>
- 요구사항 범위를 줄인다. 
	- sw에 담을 범위 선정 : 메뉴, 주문, 결제
- `도메인` : 내가 개발하려할때 내가 해결하려는 문제에 대해 범위를 선정하는게 도메인이다. (개발자 입장)
	- <u>어디서부터 어디까지 해결하려는 범위</u>📌
- `모델` : 대상의 단순화 
	- 중요하지 않은 세부사항은 생략
	- CS, 배달라이더의 책임은 뺀다 
	- <u>실제로 개발해야 하는 걸 추린다. 그렇게 복잡한거를 단순화 시킨다.</u>
		- 추상화, 모델링이라 한다.
		- 본질만 냅두고 불필요한 세부사항을 버린다.📌
		- 추상화는 모호한게 아니라 명확해야 한다.
			- **sw 개발에서 추상화는 명확하다.**
			- `추상화는 최대한 늦게 도입해라`는 말이 명확해야 하기 때문
		- 같은 뷰를 바라볼 수 있도록 구조화 📌

> 음식 배달 에제가 "도메인 모델"이라고 보면 됨


> 도메인 모델을 클래스 다이어그램으로 표현하는 이유가 객체 지향 개발을 하기 때문에 설명하기 편하려고 그렇게 설명 > 목적은 코드를 짜는거이기 때문에 도메인 모델을 클래스 다이어그램으로 표현 

`슬라이드 18`

분석 / 설계 / 구현 모델 -- 90년대 
- DDD 관점에서는 다른게 아니라는 걸 인지 (전제로 깜)
	- 📌 DDD의 핵심은 도메인 모델을 처음부터 끝까지 끌고가는게 핵심
	- 📌  도메인 모델을 동작하게 만드는게 핵심 

> 도메인 모델, 설계, 코드가 다른게 아니다 (슬라이드21). 👉 코드를 고치는 순간 다 고쳐진다. 
- 시계방향, 반시계 방향으로 인식 
	- `모델 주도 설계 (Model -Drivent Design)`
		- 3가지가 함께 변경된다.
		- 📌 모델이랑 코드가 같이 싱크를 맞추면서 영향을 주고 받으며 바뀌는거다
		- DDD와 함계 MDD가 언제나 나온다.

> 개발자 관점에서 `도메인 모델은 코드와 같다(DDD)` 
> 📌 Tip. 도메인 모델을 코드로 치환해도 말이 되야 한다 


파트1.은 개발자 혼자서 하기 힘들고, 관계자가 포함된다.
- 지식 탐구 (`슬라이드28`)
	- 나혼자서 보험 도메인을 이해하는 건 어렵다.
	- 코드를 짜는데 필요한 무언가 주는 `도메인 전문가`가 필요 📌
		- 의사결정을 도와주는 `역할` 
			- ex. 개발자가 될 수도, 사장이 될 수도 
		- `도메인 전문가 == 역할`, `도메인 전문가 != 사람`
	- `저 사람들이 원하는게 뭔지 잘 캐치해/탐구해서 찾아내 (DDD)`📌
		- 능동적인 요소 
		- 도메인 전문가와 같이 얘기/대화를 많이 하면서 찾아라!

프로젝트에 맞게 적합한 용어가 있다. >> 무슨말하는지 모름 >> 시간이 지나면 같은 용어를 사용


`슬라이드29`. 유비쿼터스 언어
- `유비쿼터스` : 어디에나 있는이라는 의미
- 도메인 전문가와 사이의 **커뮤니케이션** 수단
	- DDD에서는 피드백을 주고 받는다. 
	- 용어집은 단편적인 해석
- <u>DDD는 같이 탐구해야 하기 때문에 상호간의 용어를 맞춰간다. 긴밀하게 대화하세요 </u>
	- <u>도메인 전문가와 개발자 사이의 협업이 깔려있다.</u>
		- 이게 아니라면 단편적일 것이다. 
- 교집합을 자연스럽게 만들어간다


`슬라이드31`. 도메인 주도 설계 요약
- <u>도메인 전문가와 개발자가 공통의 목표</u>를 가져야 함 
	- KPI 세우는건 목표가 안 맞는 ..
- 도메인에 적합한 코드를 만드는거니 도메인 전문가와 협업을 한다. 
- 그리고 코드와 유사한 형태가 나오기 시작한다. 
- 커뮤니케이션 용도 뿐만 아니라 다양한 프로젝트로 활용 가능해진다.
- `모든 DDD 활동에는 유비쿼터스 언어가 기반이 된다`
- 지식 탐구 > 코드 > 지식 정재하여 유비쿼터스 언어 확보해간다 (이미지 참고)


> [!summary] 
> 초반에 도메인 모델이 정확하지 않을꺼다 (전제, DDD)
> 그러니깐 계속 반복해서 리팩토링하면서 정재해야 한다고 설명 (반복)
> (요구사항도 바뀌고 하니깐.. 완벽한 설게는 없다.)


> 📌 이렇게 하면 전제하에 DDD에 나오는 패턴을 쓰는게 좋을거야. 그게 아니면 경우에 따라 더 복잡해 질거다.


`슬라이드33`. 도메인 모델의 용도 (기본, base) ✨
1. 비즈니스 지식 정리 
2. 커뮤니케이션
3. 코드 구조

> 도메인 모델을 만들어서 처음부터 끝까지 어디에서 사용하려고 한다. (DDD)

> 위의 세가지를 깔고 간다. 똑같은 규율가지고 처음부터 끝까지 적용하려고 하는데 DDD의 바탕이다.


DDD 기반에는 두가지가 깔린다.
1. `객체지향`이 성숙하던 시기에 DDD 나옴
	1. 객체지향은 작은 문제를 해결하려고, ... 포커스 맞춘게 객체지향 
	2. 코드 구조를 짜는게 객체 지향 패러다임 (유지보수 관점)

> 에릭에반스는 다 있던걸/기존에 있던걸 체계적으로 잘 모음 (90년대)
> 다른 목적으로 흩어져 있던걸 도메인을 축으로 체계화함 📌
- 객체지향 커뮤에서 해결해야 했던 문제를 도메인 관점에서 패턴화 시킨거다

---
> ⏰ 11시 30분 시작
> 백투더 퓨처 ㅋ

1. `애자일`
	1. 책을 읽으면 애자일이 기본적으로 깔려있다. 
	2. 저 시절의 애자일과 다르다.

`슬라이드38`.
- 객체지향이 커다란 문제를 해결하기에 한계가 있다. (90년대 부터)
	- 규모가 작은 복잡한 문제를 해결하기 적합 
	- 다만, 크고 복잡한 문제를 해결하려니 문제 발생 
- <u>DDD는 도메인 관점에서 객체 지향 이슈를 해결하기 위해 나옴</u>
	- 애그리게이트, 팩토리, 바운디드 컨텍스트에 대한 논의는 있었다 (명칭은 다를 뿐)

`슬라이드40`.
- 객체지향은 다이나믹 바인딩을 한다.
- GUI 등장하면서 객체 지향이 흥행
	- 그리고 매킨토시쪽 
- **객체지향은 GUI에 최적화된 패러다임이다**

> 디자인패턴 원서가 GUI 예제 기반으로 객체지향 패턴 설명 
- 특징, GUI에 필요한 컴포넌트가 메모리에 올라가 있음 (객체)


`슬라이드42`.
- 웹이 나오면서 복잡도가 급상승 (그전까지는 괜찮)
- 자바1.0, html 공부 🥹
- UI를 심플하게 복잡한 로직은 어려우니 서버사이드로 보냄 
	- 객체 지향이 백엔드로 감. >> **객체지향과 백엔드가 안 맞음, 힘듦** 📌
	- 객체 지향은 : 메모리상에 모든 객체가 있다고 가정
	- 백엔드로 가면서 디비가 붙음 
		- 메모리에 올리는데 한계가 있음 

> JPA는 반쪽자리 솔루션으로 어거지로 맞춰야 하니 현타가 오는 시기가 있다.


`슬라이드44`. 분산 객체 기술의 유행
- 코바, 디콘, EJB 컨테이너 
- 객체를 분산시키고 싶은거 (분산 객체) -> 네트워크 통신 필요 
	- 그래서 프록시/미들웨어가 필요해짐 (Stub, Skeleton)
		- (디자인 패턴 도서에서 프록시 패턴에서 본거 같다)📚
	- 하지만 네트워크 들어가는 순간 퍼포먼스가 줄어듦
		- 데이터를 모아서 보냄 >> 이때 **DTO** 개념이 나옴 
- 해결하기 위한 기술을 사용하는게 아니라 기술이 문제를 잡아먹었던 시기
	- 지금은 시스템/서비스 단위로 분산 시킴 
- 이상하다는 걸 깨닫기 시작 


`슬라이드45` 분산 객체 기술의 문제점 
- 💩 문제를 해결하는게 목적이 아니라 기술 스펙이 요구하는거에 맞춰서 코드 구현하지 않는 이상 실행조차 안됨 (옛날 제약)
- **침투적인 아키텍처**
	- 예로 단위 테스트 하나 실행하려면 서버를 실행해야 한다. 💩


객체지향의 큰 장점
- 내가 바라보는 문제와 코드의 일관성을 지킬 수 있다.
- 도메인을 바라보는 것과 코드를 바라보는것을 똑같이 로테이션은 같음 

> 도메인을 짜려는데 코드가 먹혀버리니 EJB가 아닌거 같다는 기술/책/말들이 나옴 
- 그래서 나온것 중 하나가  `Hibernate` (90년대 말 )

라이트한 컨테이너를 사용하고 싶어서 Spring 나옴 
디비에 접근하는 거는 Hibernate

> 90년대 ~ 2000년대 초반 
> 기술에 먹히던걸 회복하려고 


`슬라이드49`. 기술 관심사와 도메인 관심사의 혼재 
- 관심사의 분리
	- .. 
- EJB는 관심사로 묶어 버림 
	- 내가 사용하는 기술을 알고 사용해야 함
	- 기술 관심사 + 도메인 관심사를 섞어 버림 
	- 그래서 이게 안 좋은거 같다고 얘기 나옴
- Spring 로드 존슨이 EJB 까는 책을 씀 📚
	- 설계를 어떻게 해야 하는지 잘 나와 있다 함
	- 이 시기에 `POJO`라는 용어가 나옴


`슬라이드50`.  POJO
- Hibernate 는 POJO 기반의 영속성 프레임워크 
- spring
- 이 시기에 도메인 주도 설계 출간 📚

> 맥락을 설명해주는게 새롭네. 왜 이 기술이 나왔는지 배경 


`슬라이드52`. 분산 객체 기술의 문제점
- 도메인과 코드의 차이가 큼 
	- 번역이 필요해짐
	- 읽기 어려운 코드 > 알고리즘적으로 풀이한 코드 
		- 코드를 내가 알던 문제로 번역하기 쉽지 않다. 버그 만들기도 쉽고, 유지보수 어려움 
- <u>기술에 종속적으로 코드를 짠다는 건 바로 이 비용이 들어간다는 걸 인지</u>

> 기술에 집착한 코드는 내가 풀려는 도메인의 본질을 흐트려버림.. 도메인으로 번역하기 힘든 코드는 잘못 짠거라 할 수도..



`슬라이드53`. 해결방법. MDD
- 기술에 종속되서 코드를 바꾸지 말고, 도메인 모델을 만들고 코드를 짜면 비용이 줄어들거다.


`슬라이드54`. 침투적인 기술로 인한 커뮤니케이션의 복잡성 
- 기술 침투적이면 .. 


`슬라이드55`. 유비쿼터스 언어 


`슬라이드56`. 모델주도 설계와 유비쿼터스 언어
- 도메인 모델 그대로 코드를 짜라 
- 도메인 모델과 코드에 도메인 용어를 사용

> 기술 침투적(EJB)으로 인해 어려워지던 상황을 개선하기 위해 
> 도메인에 포커스를 맞추자. 해서 나온게 DDD
- 도메인 로직은 이렇고 우리가 해결하려는 문제는 이런거다 ✨


클린 아키텍처
- 도메인 로직에 의존성 걸지말고 떨어뜨리라.
- DDD의 연장선 


`슬라이드57`. 그래서 파트2에서는 
- 가이드를 제시
- 빌딩 블록
	- 이걸 구현하려면 이게 필요하다는걸 가이드함 
- `도메인 모델을 구현해야 하고 기술적인걸 배제해야 한다.`
	- 예. 엔티티는 언제 쓰냐면 .. 이런게 있다면.. 묶어버림 
	- 도메인 로직을 짤때는 구현시 이런 특성이 있기 때문에 구현을 이렇게 해야 한다고 가이드한다. 
- 조건. `기술적인것과 도메인 모델은 떨어져 있어야 한다. (에릭에반스)`


`슬라이드58`. 도메인 로직의 격리
- 컴퓨터 관련된 용어를 빼고 설명 가능해야 한다/로직을 짜야 한다 📌
	- 요구사항. 기술적인 용어는 배제 되어 있어야 한다. 
- 레이어 아키텍처에서 **도메인 영역**이 나눠진다. 
	- 클린아키텍처, 핵사고날 아키텍처도 이걸 만족한다. 
	- <u>도메인이 고립된다. </u>

> 헥사고날 아키텍처는 잘못쓰면 복잡하다.


`슬라이드60` 모델 주도 설계의 빌딩 블록

> 도메인 모델은 구현 가능해야 한다. 도메인 전문가와 소통이 가능하면서 코드로 표현이 되야 한다.

> 가이드이다. 이렇게 무조건 짜야 된다는게 아니라. 법칙처럼 받아들이는건 오해다 

> 파트1을 하는게 DDD이다. DDD 전제하에 파트2를 해라.

> 도메인을 이러한 특성을 가진 카테고리로 분류하면 단순해짐 > 특성이 구현의 일관성이 있을거다 > 이렇게 하면 구현 가능한 도메인을 만들수있을 거다 


**🏠 도메인을 표현하기 위한 빌딩 블록 (5가지)**
- `Association`
- `entity`
- `vo`
- `service`
- `module`


`슬라이드62` 

**🏠 생명 주기를 관리하기 위한 빌딩 블록** 
- `Aggregate`
- `Repository`
- `Factory`

> 빌딩 블록은 구현 가이드라서 쉽게 할 수 있다. 나머지는 정답이 없고 창의성을 발휘해야 함.
> 여기에 포커스를 맞추지만, 이게 곧 DDD는 아니다. 집착하면 EJB 처럼 묶이게 됨 
> 해결해야 할 문제는 따로 있는데 DDD 가이드에 묶임

---

### 오후 (파트2)
> `슬라이드63`부터 시작 예정 

> Aggregate 

`슬라이드63` 빌딩 블록의 목적 
- '도메인 모델과 코드는 별개가 아니다'
	- 뭉쳐서 생각함
- DDD는 노골적으로 끌고 올라간다. 
	- 도메인 분석은 코드를 유지보수 잘하기 위한 것이다. 
	- 도메인 모델 + 유비쿼터스 언어 = 커뮤니케이션

**🏠 도메인을 표현하기 위한 빌딩 블록**
- `Association`
- `entity`
- `vo`
- `service`
- `module`

**🏠 생명 주기를 관리하기 위한 빌딩 블록** 
- `Aggregate`
- `Repository`
- `Factory`


`슬라이드64`. 도메인 모델 예제
- 불변식
	- Order 클래스에`limitPrice : Money`


도메인 로직 

도메인 룰 
- 상태 변경 / 제거 조건

> 상태가 만들어지고 조건을 가지고 로직을 처리한다.

데이터 조회는 DDD 룰에서 벗어난다 (상관x) 📌

DDD는 불변식을 강조함/앞으로 내세운다 📌
- 객체지향은 불변식은 강조하진 않음.


`슬라이드65` 주문 현재 상태
- 불변식을 만족하는 상태


`슬라이드66` 첫번재 사용자 수정
- 상태변경이 일어나도 최종 결과물은 이 조건을 만족해야 해 (= 불변식)


`슬라이드67` 두번재 사용자 수정


`슬라이드68` 
- 점선 표시된 항목이 상태 수정된거 


> 불변식을 위반하는 케이스 슬라이드 설명
- 데이터 단위로 처리한다는게 불변식 위반할 가능성이 있다.  (데이터 관점)
- `불변식은 하나의 클래스로 말하지않고 여러 클래스를 뭉친다.` 
	- 여러개의 객체 / 엔티티를 묶어서 확인하는게 **도메인 룰**
- 그러면 관련성있는 객체를 그룹 단위로 가지고 다니면 된다. 
	- 이게 `Aggregate`이다 


`슬라이드75` Aggregate
- `불변식(기준)`을 만족시키는 객체 그룹의 단위로 처리 
- 애그리게이트는 작아야 한다 
	- 구조 관점에서 크게 잡으면 ❌
	- a가 b를 포함해도 불변식은 다를 수 있다. 
- **도메인 룰 관점에서 봐야 한다.**

> DDD는 도메인을 끌고 간다. 계속 
> 기술 관점에서도 보는데, 그걸할때 기준이 뭔지 확인할때 도메인 룰로 가버림


`슬라이드76` 애그리게이트 단위로 저장하면 불변식 유지
- 개념적으로 논리적으로 경게의 기준을 찾으면 일관성있는 상태를 유지 가능 (DDD의 주장📌)
	- 도메인 규칙 / 불변식 기준으로 


> 요구사항이 바뀌더라도 이 틀이 기반으로 되면 그나마 안정적 
- 도메인 룰 기반으로 코드 구조 가지고 오는게 사이드 이펙트가 적다
- 붋

