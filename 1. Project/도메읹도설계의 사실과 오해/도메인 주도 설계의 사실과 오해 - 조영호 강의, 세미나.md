- `2025-10-11(토)`

> DDD 에 대해 
> ✅ 신입 : 필요, 시니어 : 복잡

객체지향 != DDD
📌 DDD 꽤 복잡
- 에릭 에반스 도서 : DDD
	- 이해하기 힘들다 (개념이 추상적)
	- **📚 국내 도서**
		- 도메인주도 설계 구현
		- 도메인주도 설계 첫걸음 등등
		- 단, 그 다음 나온 책은 원서를 전체 커버하지 않는다 
---

>[!note] 
>DDD 를 개발 관점, 조직관점에서 얘기하기도 한다. 
>큰 문제에 대한 사고 방식이라.. DDD가 커버하는 범위가 넓다

`파트1`
- 에릭에반스 책의 전체 흐름 , 목차를 훓는다
	- 읽기 힘들고, 예제도 힘들고 💩
- DDD는 `패턴 집합`이다
	- 약간 GoF, Head First 디자인 패턴 같은 느낌
	- 각각의 패턴이 독립적
- 패턴 랭귀지 : 일정 패턴, 흐름의 집합 

`파트2`
- 엔티티, VO에 대한 오해
- 에그리게이트 개념 중심으로 설명 
	- 책의 파트4개 중 
- 우선순위 낮다.
- 개발자 관점 

>[!info] 후속 강의 파트3, 4 계획 중인데 따라 하기 어렵다. 거의 다 만들어서 후속 강의 오픈 예정

> 설계가 한방에 되는 줄 오해 👉 계속 뒤집는다.

---

### 오전 
> 객체지향 != DDD
> - 공통점 ❌ 

> 프로젝트에 DDD 개념을 섞어서 쓰다보니 객체지향과 DDD에 대한 혼란이 발생 

> DDD 가이드를 따르다보면 필요이상으로 복잡해 지는 부분도 있다

> 모든 책에는 저자의 주관적인 견해가 들어간다 (나는 이렇게 생각해)
> - 전제로 까는 컨텍스트가 있다.
> - 이게 곧 정답은 아니다

도메인에 관련 문제를 해결하는게 == sw

해결해야될 문제보다 기술에 꽂히는 시기가 있다 => 밸런스가 나중에 찾아간다 (중요한 시기)

sw의 본질적인 문제, 복잡성을 해결하기 위해 나온게 DDD 도서
- 구현 관점/기법에만 빠져 오해하기 쉬움 (!= 본질 아님, 이건 결과물이다)
	- 문제는 심플한데, 코드 복잡도가 높아질 수 있다.
- 📌`문제를 해결하기 위해 (사용자 요구사항 > 기능 > 유지보수) 어떻게 복잡성을 낮출 거냐`
	- 사고방식, 우선순위 모음 👉 복잡한 문제를 단순하게 풀 수 있다

`객체지향`
- 블라블라

`함수형` 
- 블라블라

`DDD`
- 우선순위, 사고방식 모음 >> **철학적인 관점**으로 설명 

> DDD 볼때마다 새롭다는데 ✨


**파트1. 동작하는 도메인 모델 만들기 (핵심)**
- DDD 정의 
- DDD 궁극적인 목적

> 이런 문제가 발생할때 이런 패턴을 사용하면 복잡도가 낮아질거다.

>도메인. 사용자가 프로그램을 사용하는 주제 영역
>- 어떤 기능을 쓰는가

<u>sw는 전체/큰 문제중에 범위를 먼저 줄이는/정하는 것으로 시작 </u>
- 요구사항 범위를 줄인다. 
	- sw에 담을 범위 선정 : 메뉴, 주문, 결제
- `도메인` : 내가 개발하려할때 내가 해결하려는 문제에 대해 범위를 선정하는게 도메인이다. (개발자 입장)
	- <u>어디서부터 어디까지 해결하려는 범위</u>📌
- `모델` : 대상의 단순화 
	- 중요하지 않은 세부사항은 생략
	- CS, 배달라이더의 책임은 뺀다 
	- <u>실제로 개발해야 하는 걸 추린다. 그렇게 복잡한거를 단순화 시킨다.</u>
		- 추상화, 모델링이라 한다.
		- 본질만 냅두고 불필요한 세부사항을 버린다.📌
		- 추상화는 모호한게 아니라 명확해야 한다.
			- **sw 개발에서 추상화는 명확하다.**
			- `추상화는 최대한 늦게 도입해라`는 말이 명확해야 하기 때문
		- 같은 뷰를 바라볼 수 있도록 구조화 📌

> 음식 배달 에제가 "도메인 모델"이라고 보면 됨


> 도메인 모델을 클래스 다이어그램으로 표현하는 이유가 객체 지향 개발을 하기 때문에 설명하기 편하려고 그렇게 설명 > 목적은 코드를 짜는거이기 때문에 도메인 모델을 클래스 다이어그램으로 표현 

`슬라이드 18`

분석 / 설계 / 구현 모델 -- 90년대 
- DDD 관점에서는 다른게 아니라는 걸 인지 (전제로 깜)
	- 📌 DDD의 핵심은 도메인 모델을 처음부터 끝까지 끌고가는게 핵심
	- 📌  도메인 모델을 동작하게 만드는게 핵심 

> 도메인 모델, 설계, 코드가 다른게 아니다 (슬라이드21). 👉 코드를 고치는 순간 다 고쳐진다. 
- 시계방향, 반시계 방향으로 인식 
	- `모델 주도 설계 (Model -Drivent Design)`
		- 3가지가 함께 변경된다.
		- 📌 모델이랑 코드가 같이 싱크를 맞추면서 영향을 주고 받으며 바뀌는거다
		- DDD와 함계 MDD가 언제나 나온다.

> 개발자 관점에서 `도메인 모델은 코드와 같다(DDD)` 
> 📌 Tip. 도메인 모델을 코드로 치환해도 말이 되야 한다 


파트1.은 개발자 혼자서 하기 힘들고, 관계자가 포함된다.
- 지식 탐구 (`슬라이드28`)
	- 나혼자서 보험 도메인을 이해하는 건 어렵다.
	- 코드를 짜는데 필요한 무언가 주는 `도메인 전문가`가 필요 📌
		- 의사결정을 도와주는 `역할` 
			- ex. 개발자가 될 수도, 사장이 될 수도 
		- `도메인 전문가 == 역할`, `도메인 전문가 != 사람`
	- `저 사람들이 원하는게 뭔지 잘 캐치해/탐구해서 찾아내 (DDD)`📌
		- 능동적인 요소 
		- 도메인 전문가와 같이 얘기/대화를 많이 하면서 찾아라!

프로젝트에 맞게 적합한 용어가 있다. >> 무슨말하는지 모름 >> 시간이 지나면 같은 용어를 사용


`슬라이드29`. 유비쿼터스 언어
- `유비쿼터스` : 어디에나 있는이라는 의미
- 도메인 전문가와 사이의 **커뮤니케이션** 수단
	- DDD에서는 피드백을 주고 받는다. 
	- 용어집은 단편적인 해석
- <u>DDD는 같이 탐구해야 하기 때문에 상호간의 용어를 맞춰간다. 긴밀하게 대화하세요 </u>
	- <u>도메인 전문가와 개발자 사이의 협업이 깔려있다.</u>
		- 이게 아니라면 단편적일 것이다. 
- 교집합을 자연스럽게 만들어간다


`슬라이드31`. 도메인 주도 설계 요약
- <u>도메인 전문가와 개발자가 공통의 목표</u>를 가져야 함 
	- KPI 세우는건 목표가 안 맞는 ..
- 도메인에 적합한 코드를 만드는거니 도메인 전문가와 협업을 한다. 
- 그리고 코드와 유사한 형태가 나오기 시작한다. 
- 커뮤니케이션 용도 뿐만 아니라 다양한 프로젝트로 활용 가능해진다.
- `모든 DDD 활동에는 유비쿼터스 언어가 기반이 된다`
- 지식 탐구 > 코드 > 지식 정재하여 유비쿼터스 언어 확보해간다 (이미지 참고)


> [!summary] 
> 초반에 도메인 모델이 정확하지 않을꺼다 (전제, DDD)
> 그러니깐 계속 반복해서 리팩토링하면서 정재해야 한다고 설명 (반복)
> (요구사항도 바뀌고 하니깐.. 완벽한 설게는 없다.)


> 📌 이렇게 하면 전제하에 DDD에 나오는 패턴을 쓰는게 좋을거야. 그게 아니면 경우에 따라 더 복잡해 질거다.


`슬라이드33`. 도메인 모델의 용도 (기본, base) ✨
1. 비즈니스 지식 정리 
2. 커뮤니케이션
3. 코드 구조

> 도메인 모델을 만들어서 처음부터 끝까지 어디에서 사용하려고 한다. (DDD)

> 위의 세가지를 깔고 간다. 똑같은 규율가지고 처음부터 끝까지 적용하려고 하는데 DDD의 바탕이다.


DDD 기반에는 두가지가 깔린다.
1. `객체지향`이 성숙하던 시기에 DDD 나옴
	1. 객체지향은 작은 문제를 해결하려고, ... 포커스 맞춘게 객체지향 
	2. 코드 구조를 짜는게 객체 지향 패러다임 (유지보수 관점)

> 에릭에반스는 다 있던걸/기존에 있던걸 체계적으로 잘 모음 (90년대)
> 다른 목적으로 흩어져 있던걸 도메인을 축으로 체계화함 📌
- 객체지향 커뮤에서 해결해야 했던 문제를 도메인 관점에서 패턴화 시킨거다

---
> ⏰ 11시 30분 시작
> 백투더 퓨처 ㅋ

1. `애자일`
	1. 책을 읽으면 애자일이 기본적으로 깔려있다. 
	2. 저 시절의 애자일과 다르다.

`슬라이드38`.
- 객체지향이 커다란 문제를 해결하기에 한계가 있다. (90년대 부터)
	- 규모가 작은 복잡한 문제를 해결하기 적합 
	- 다만, 크고 복잡한 문제를 해결하려니 문제 발생 
- <u>DDD는 도메인 관점에서 객체 지향 이슈를 해결하기 위해 나옴</u>
	- 애그리게이트, 팩토리, 바운디드 컨텍스트에 대한 논의는 있었다 (명칭은 다를 뿐)

`슬라이드40`.
- 객체지향은 다이나믹 바인딩을 한다.
- GUI 등장하면서 객체 지향이 흥행
	- 그리고 매킨토시쪽 
- **객체지향은 GUI에 최적화된 패러다임이다**

> 디자인패턴 원서가 GUI 예제 기반으로 객체지향 패턴 설명 
- 특징, GUI에 필요한 컴포넌트가 메모리에 올라가 있음 (객체)


`슬라이드42`.
- 웹이 나오면서 복잡도가 급상승 (그전까지는 괜찮)
- 자바1.0, html 공부 🥹
- UI를 심플하게 복잡한 로직은 어려우니 서버사이드로 보냄 
	- 객체 지향이 백엔드로 감. >> **객체지향과 백엔드가 안 맞음, 힘듦** 📌
	- 객체 지향은 : 메모리상에 모든 객체가 있다고 가정
	- 백엔드로 가면서 디비가 붙음 
		- 메모리에 올리는데 한계가 있음 

> JPA는 반쪽자리 솔루션으로 어거지로 맞춰야 하니 현타가 오는 시기가 있다.


`슬라이드44`. 분산 객체 기술의 유행
- 코바, 디콘, EJB 컨테이너 
- 객체를 분산시키고 싶은거 (분산 객체) -> 네트워크 통신 필요 
	- 그래서 프록시/미들웨어가 필요해짐 (Stub, Skeleton)
		- (디자인 패턴 도서에서 프록시 패턴에서 본거 같다)📚
	- 하지만 네트워크 들어가는 순간 퍼포먼스가 줄어듦
		- 데이터를 모아서 보냄 >> 이때 **DTO** 개념이 나옴 
- 해결하기 위한 기술을 사용하는게 아니라 기술이 문제를 잡아먹었던 시기
	- 지금은 시스템/서비스 단위로 분산 시킴 
- 이상하다는 걸 깨닫기 시작 


`슬라이드45` 분산 객체 기술의 문제점 
- 💩 문제를 해결하는게 목적이 아니라 기술 스펙이 요구하는거에 맞춰서 코드 구현하지 않는 이상 실행조차 안됨 (옛날 제약)
- **침투적인 아키텍처**
	- 예로 단위 테스트 하나 실행하려면 서버를 실행해야 한다. 💩


객체지향의 큰 장점
- 내가 바라보는 문제와 코드의 일관성을 지킬 수 있다.
- 도메인을 바라보는 것과 코드를 바라보는것을 똑같이 로테이션은 같음 

> 도메인을 짜려는데 코드가 먹혀버리니 EJB가 아닌거 같다는 기술/책/말들이 나옴 
- 그래서 나온것 중 하나가  `Hibernate` (90년대 말 )

라이트한 컨테이너를 사용하고 싶어서 Spring 나옴 
디비에 접근하는 거는 Hibernate

> 90년대 ~ 2000년대 초반 
> 기술에 먹히던걸 회복하려고 


`슬라이드49`. 기술 관심사와 도메인 관심사의 혼재 
- 관심사의 분리
	- .. 
- EJB는 관심사로 묶어 버림 
	- 내가 사용하는 기술을 알고 사용해야 함
	- 기술 관심사 + 도메인 관심사를 섞어 버림 
	- 그래서 이게 안 좋은거 같다고 얘기 나옴
- Spring 로드 존슨이 EJB 까는 책을 씀 📚
	- 설계를 어떻게 해야 하는지 잘 나와 있다 함
	- 이 시기에 `POJO`라는 용어가 나옴


`슬라이드50`.  POJO
- Hibernate 는 POJO 기반의 영속성 프레임워크 
- spring
- 이 시기에 도메인 주도 설계 출간 📚

> 맥락을 설명해주는게 새롭네. 왜 이 기술이 나왔는지 배경 


`슬라이드52`. 분산 객체 기술의 문제점
- 도메인과 코드의 차이가 큼 
	- 번역이 필요해짐
	- 읽기 어려운 코드 > 알고리즘적으로 풀이한 코드 
		- 코드를 내가 알던 문제로 번역하기 쉽지 않다. 버그 만들기도 쉽고, 유지보수 어려움 
- <u>기술에 종속적으로 코드를 짠다는 건 바로 이 비용이 들어간다는 걸 인지</u>

> 기술에 집착한 코드는 내가 풀려는 도메인의 본질을 흐트려버림.. 도메인으로 번역하기 힘든 코드는 잘못 짠거라 할 수도..



`슬라이드53`. 해결방법. MDD
- 기술에 종속되서 코드를 바꾸지 말고, 도메인 모델을 만들고 코드를 짜면 비용이 줄어들거다.


`슬라이드54`. 침투적인 기술로 인한 커뮤니케이션의 복잡성 
- 기술 침투적이면 .. 


`슬라이드55`. 유비쿼터스 언어 


`슬라이드56`. 모델주도 설계와 유비쿼터스 언어
- 도메인 모델 그대로 코드를 짜라 
- 도메인 모델과 코드에 도메인 용어를 사용

> 기술 침투적(EJB)으로 인해 어려워지던 상황을 개선하기 위해 
> 도메인에 포커스를 맞추자. 해서 나온게 DDD
- 도메인 로직은 이렇고 우리가 해결하려는 문제는 이런거다 ✨


클린 아키텍처
- 도메인 로직에 의존성 걸지말고 떨어뜨리라.
- DDD의 연장선 


`슬라이드57`. 그래서 파트2에서는 
- 가이드를 제시
- 빌딩 블록
	- 이걸 구현하려면 이게 필요하다는걸 가이드함 
- `도메인 모델을 구현해야 하고 기술적인걸 배제해야 한다.`
	- 예. 엔티티는 언제 쓰냐면 .. 이런게 있다면.. 묶어버림 
	- 도메인 로직을 짤때는 구현시 이런 특성이 있기 때문에 구현을 이렇게 해야 한다고 가이드한다. 
- 조건. `기술적인것과 도메인 모델은 떨어져 있어야 한다. (에릭에반스)`


`슬라이드58`. 도메인 로직의 격리
- 컴퓨터 관련된 용어를 빼고 설명 가능해야 한다/로직을 짜야 한다 📌
	- 요구사항. 기술적인 용어는 배제 되어 있어야 한다. 
- 레이어 아키텍처에서 **도메인 영역**이 나눠진다. 
	- 클린아키텍처, 핵사고날 아키텍처도 이걸 만족한다. 
	- <u>도메인이 고립된다. </u>

> 헥사고날 아키텍처는 잘못쓰면 복잡하다.


`슬라이드60` 모델 주도 설계의 빌딩 블록

> 도메인 모델은 구현 가능해야 한다. 도메인 전문가와 소통이 가능하면서 코드로 표현이 되야 한다.

> 가이드이다. 이렇게 무조건 짜야 된다는게 아니라. 법칙처럼 받아들이는건 오해다 

> 파트1을 하는게 DDD이다. DDD 전제하에 파트2를 해라.

> 도메인을 이러한 특성을 가진 카테고리로 분류하면 단순해짐 > 특성이 구현의 일관성이 있을거다 > 이렇게 하면 구현 가능한 도메인을 만들수있을 거다 


**🏠 도메인을 표현하기 위한 빌딩 블록 (5가지)**
- `Association`
- `entity`
- `vo`
- `service`
- `module`


`슬라이드62` 

**🏠 생명 주기를 관리하기 위한 빌딩 블록** 
- `Aggregate`
- `Repository`
- `Factory`

> 빌딩 블록은 구현 가이드라서 쉽게 할 수 있다. 나머지는 정답이 없고 창의성을 발휘해야 함.
> 여기에 포커스를 맞추지만, 이게 곧 DDD는 아니다. 집착하면 EJB 처럼 묶이게 됨 
> 해결해야 할 문제는 따로 있는데 DDD 가이드에 묶임

---

### 오후 (파트2)
> `슬라이드63`부터 시작 예정 

> Aggregate 

`슬라이드63` 빌딩 블록의 목적 
- '도메인 모델과 코드는 별개가 아니다'
	- 뭉쳐서 생각함
- DDD는 노골적으로 끌고 올라간다. 
	- 도메인 분석은 코드를 유지보수 잘하기 위한 것이다. 
	- 도메인 모델 + 유비쿼터스 언어 = 커뮤니케이션

**🏠 도메인을 표현하기 위한 빌딩 블록**
- `Association`
- `entity`
- `vo`
- `service`
- `module`

**🏠 생명 주기를 관리하기 위한 빌딩 블록** 
- `Aggregate`
	- entity, vo 집합
	- Aggregate root를 통해서만 내부 접근이 가능하다.
- `Repository`
- `Factory`


`슬라이드64`. 도메인 모델 예제
- 불변식
	- Order 클래스에`limitPrice : Money`


도메인 로직 

도메인 룰 
- 상태 변경 / 제거 조건

> 상태가 만들어지고 조건을 가지고 로직을 처리한다.

데이터 조회는 DDD 룰에서 벗어난다 (상관x) 📌

DDD는 불변식을 강조함/앞으로 내세운다 📌
- 객체지향은 불변식은 강조하진 않음.


`슬라이드65` 주문 현재 상태
- 불변식을 만족하는 상태


`슬라이드66` 첫번재 사용자 수정
- 상태변경이 일어나도 최종 결과물은 이 조건을 만족해야 해 (= 불변식)


`슬라이드67` 두번재 사용자 수정


`슬라이드68` 
- 점선 표시된 항목이 상태 수정된거 


> 불변식을 위반하는 케이스 슬라이드 설명
- 데이터 단위로 처리한다는게 불변식 위반할 가능성이 있다.  (데이터 관점)
- `불변식은 하나의 클래스로 말하지않고 여러 클래스를 뭉친다.` 
	- 여러개의 객체 / 엔티티를 묶어서 확인하는게 **도메인 룰**
- 그러면 관련성있는 객체를 그룹 단위로 가지고 다니면 된다. 
	- 이게 `Aggregate`이다 


`슬라이드75` Aggregate
- `불변식(기준, 제약조건, Constraint)`을 만족시키는 객체 그룹의 단위로 처리 
- 애그리게이트는 작아야 한다 
	- 구조 관점에서 크게 잡으면 ❌
	- a가 b를 포함해도 불변식은 다를 수 있다. 
- **도메인 룰 관점에서 봐야 한다.**

> DDD는 도메인을 끌고 간다. 계속 
> 기술 관점에서도 보는데, 그걸할때 기준이 뭔지 확인할때 도메인 룰로 가버림


`슬라이드76` 애그리게이트 단위로 저장하면 불변식 유지
- 개념적으로 논리적으로 경게의 기준을 찾으면 일관성있는 상태를 유지 가능 (DDD의 주장📌)
	- 도메인 규칙 / 불변식 기준으로 


> 요구사항이 바뀌더라도 이 틀이 기반으로 되면 그나마 안정적 
- 도메인 룰 기반으로 코드 구조 가지고 오는게 사이드 이펙트가 적다
- 불변식으로 경계를 잡으면 변경시 해당 그룹만 변경됨 📌
	- 비즈니스 룰을 기반으로 코드를 작성 


> DDD는 안정적으로 코드가 진화할 수 있는 기반으로 마련하고 싶은거 
- 도메인 기반으로 코드 구조를 잡고 싶은것 📌✅
- 이렇게 하면 <u>복잡성이 컨트롤 가능한 수준으로 낮아질 수 있다는게 주장</u>이다. (처음부터 끝까지 나오는 내용)


> DDD는 애그리게이터 단위로 트랜잭션을 잡아라고 가이드함
- 일관성이 맞춰진 상태에서 반영되야 하기 대문에 (비즈니스 룰이라) 트랜잭션으로 묶어라는거

`슬라이드 78`. 애그리게이트 단위로 리파지토리 추가
그래서 repository를 `애그리게이트 루트`에다가만 넣는다 
- Order + OrderLineItem이 한 세트 
- 에그리게이트 단위로 일관성있게 ..

`슬라이드 81`. 
> 객체 참조는 결합도가 높다. 끊어두고 애그리게이터 집합을 따로 관리하자
> 애그리게이트 경계관점에서 Order, Customer를 디비 처리를 같이하면 x
- 정말로 애그리게이트 내부에 있는지 없는지 고민을 해야 함 ✅
- 예로 주문(Order)시 사용자(Customer) 상태도 변경되는걸 원하는 경우도 가끔 나온다. 
	- 트랜잭션 경계..(??)
	- 를 끊어야한다.  만약 애그리게이트 경계를 합쳐버리면 커진다. 
- 결과적으로 필요하면 나중에 일관성을 맞춰주면 됨 
	- 나중에라도, 이벤츄얼 컨스턴시
	- 배치, 이벤트 처리 등등 


`슬라이드 82`.  결과적 일관성 
- 비즈니스 룰을 가지고 얘기하면 일관성이 맞춰짐 📌
	- 코드의 구조가/트랜잭션 경계가  비즈니스 룰을 기반으로 잡으면 
- 문제.👿
	- 그다지 복잡하지 않은 상황에서 쓰면 복잡해진다.
	- Order, Customer를 따로 경계를 지정해 트랜잭션 관리하게 되는데 .. 주문 카운터 증가시 추가 리소스가 들어가게 된다. 
		- 대신에 애그리게이트 경계를 끊고 트랜잭션 하나로 처리하는 것도 가능ㅎ다. 

> ddd는 복잡하다. 성능 이슈가 있을 수도있다. 
- 트래픽이 많고 트랜잭션이 많을때 애그리게이트 경계를 묶어두면 오래 걸림
	- 반면, 비즈니스 룰 관점에서 경계를 나누면 풀리는게 빠름 ✅
	- 시스템이 밀리니 끊는거다.

>코드 구조를 저렇게 잡으려면 리팩터링을 자주할 결심이 필요하다 ✅
>처음에 구조가 계속 변경될건데 그게 아니라면 복잡도만 높아짐 


> 얼마나 부딪히는지 경합이 발생하면 찢어버림 > 시스템 복잡도는 높아지지만 안정성 향상 
> >> 꼭 당연한건 아니다.


`슬라이드 83`. 지금까지 살펴본 내용
- 보통 구조만 따라가는데 .. 본질을 따라가지 않으면 경계만 찢어져서 복잡도만 높아진다.
- 주니어가 DDD를 하고 싶다는 건 모호한 부분이다. 
- DDD는 `사고 방식`이다. 
	- 개발할 때 어떻게 접근하면 좋을지 가이드 함
	- 맹목적으로 따르면 안 좋은 쪽으로 갈 수 있다.

> 코드 구조에 눈이 많이 가서 이상하게 짬 > 왜 이렇게 해라는 건지에 관심을 가져야 한다


`슬라이드84`. 
- 📌 추천은 하지 않음.
- 단, 이 책을 보면 Hibernate의 구조가 어떠한지 알 수 있다.
- 용어라도 보는게 좋다 


`슬라이드86`.  \[참고\]트랜잭션 스크립트 
- 도메인 로직을 절차지향적으로 짜는거 

`슬라이드88`. 도메인 모델 
- 아키텍처 레벨에서 도메인 로직을 객체지향적으로 짠다. ..(이 부분 다시 듣기, 뭔가 다르다는데)

// 도메인 모델 패턴과 DDD 맥락의 도메인 모델은 다르다 


로드 존슨이 깟던 코드가 spring 1.0에 나온다. 

// 휴식 시간 (오후 2시 22분)

불변식 경계는 exclusive (베타적), 겹치면 안된다 
경계식이 유효성 검사 같은거라 생각할 수 있다. 
어그리게이트 루트 ..

책📚
- 내가 당장 써먹야하는 기술책
- 내가 당장 안쓰는건데 좋다고 하는책, 봐야 하는 책 : DDD
	- 당장 써야 할때 봐도 DDD는 어렵다.
	- 일단 본다.
	- 상관없는 상황에 떠오를때가 있다. 
	- 잘 이해가 안되더라도 어떤 용어, 무언가 얘길하는걸 보고 세월이 지나 안보이는게 보인다 (성장한거)
	- 지금 당장 필요없더라도 성장에 필요하다면 본다 
	- 전제는 회사에 급한일이 있는데 그거부터 해야 마음의 여유가 생기니.. 우선순위를 잘 정한다. 💩
	- 20년째 .. 1년마다 보는데 새롭다. 내용자체가 어려운데 ..
	- 때로는 영어로 볼대가 더 이해가 잘될때가 있다. 원문의 늬앙스가 한글 번역하면 사라지기도 함
- 동떨어져 있는 개념이 없고 시간이 지나면 연결이 된다. 
- 결국. 이해는 안되더라도 한번씩 보는걸 추천한다 

> 애그리게이트 경계를 잘 정하는게 좋다.

---

> 오후 2시 30분 시작

> 파트3의 요약은 리팩터링을 계속 해라. 이다.

`슬라이드90` 애자일과 도메인 주도 설계 
- DDD는 애자일을 깐다 
- 90년대 애자일과 지금 애자일은 느낌이 다르다.
	- 변질되서 프로세스처럼 보일때가 많다. 
		

`슬라이드92`. 
`슬라이드93`. 

> 주니어 일때는 설계나 일정 추산이 어렵다. 지금도 어렵다 


`슬라이드95`.  문제. 흐릿한 요구사항 
- 요구사항을 명확히 정의하지 않고 감
	- 한번도 없었고, 더 없어질 것이다. 
	- 개발업의 종특
- 속도가 빠르다 => 경쟁 치열

> 내가 뭘 만들어지는지 모를때 일정 추산 못함, 불가능함


`슬라이드96`.  문제 - 변경되는 요구사항
- 업의 역사가 짧다.
- 건축이나 재조 업계에서 용어를 가져옴
	- ex. 아키텍처
	- 물리적으로 집을 짓다가 바꿀 수 없으니, 설계/디자인부터 한다
	- 뒤에 바뀌면 비용이 커짐
	- 물리적으로 성숙한 분야 > 반면 IT는 아닌데 얘네들 거를 가져옴 (단절된 단계, 문제 발생)
- 안 맞는거를 가져와서 억지로 끼워 맞춘거다.
	- 설계를 하는데 구현을 못하지
	- 초반에 일정 추산을 못하지
	- 와 같은 생각을 하게됨 (이상한 방식으로 우리는 일을 해야 해)


`슬라이드98`. 문제 - 예견적인 프로세스
- 일정 계획을 짜는게 비 현실적 


`슬라이드99`. 과도한 사전 설계 
- 90년대까지 이게 맞다고 생각을 함.
	- WBS 작성 후 SI 프로젝트 진행 

> 계획을 짜는건 중요하다. 계획을 무조건 지키는건 어려우니 상황에 맞춰 조정해야 한다. 
> 우리가 추청하는 일정은 틀린 일정일 거야 => 근데 이걸 지켜야 하는 약속으로 생각


`슬라이드100`. 그리고 애자일의 등장 
- https://agilemanifesto.org/iso/ko/manifesto.html


`슬라이드102`. eXtreme Programming explained by 켄트벡 
- 변경을 수용하라 (1998)
	- 꽉 막혀서 하는게 아니라, 변경이 발생하면 일정을 수정
- 애자일은 속도가 빠르다라고 잘못 판단 💩
	- `시간이 조금 갈리더라도 변경에 기민하게 일하는 방식이 반응하는게 애자일이다`📌


`슬라이드103`. XP 핵심
- 반복을 통한 피드백을 중요시함 
- 개발만큼 피드백이 빨리 주는게 없다. ✅
	- 개발이 재미있는 이유
	- 나에게 피드백 줄 수 있는 환경이 갖춰져 있다.
	- `TDD`, `CI` 도 마찬가지로 피드백을 빨리 준다

> 초반에는 요구사항을 잘 모르는데, 시간이 지나면 어떻게 되는지 안다. 
> 모르는 걸 학습하면서 배우게 된다. 


`슬라이드104`
✅ 피드백을 빨리 받을 수 있는 방식으로 프로세스를 압축시킨다.
- 초반에 잘 안보이지만, 명확한 몇가지가 있다. 
- 이걸 빨리 구현해서 배포까지 해버림
- 이걸 `이터레이션(반복적)`한다.
- 그리고 `회고`를 한다 >> 애자일에는 `회고`가 들어간다📌

> 애자일은 오래 걸리던 단계를 압축 시켜 피드백이 들어온다. 


`슬라이드111` 해결 - 반복을 통해 명확해지는 요구사항


`슬라이드112` 해결 - 짧은 주기의 반복 단위로 변경사항 반영

> 100짜리 전체 중에서 중요한거만 판단해서 현재 20만 오픈해도 되는지 의사결정, 안되면 30을 일정잡고 더 해본다. 

> 이터레이션 걸어서 반복하는게 스트레스이고 어렵다.👿


`슬라이드114` 해결 - 적응적인 프로세스
- 좋다 나쁘다를 떠나서 강제로 박아버리면 효과가 반감된다
	- 예로 테스트 커버리지 100%.
- 우리업은 제조업이 아니기 때문에 이렇게 해야한다..📌
- 우리 코드는 설계도라고 할 수 있다. 
	- 반복 생산은 빌드, 배포인데
- 애자일은 이걸 깨버린다. 


`슬라이드120` 진화적인 설계의 핵심은 리팩터링 
- 리팩터링 도서가 90년대 ~ 2000대 초
- 애자일하고 물린다. 


`슬라이드121` 애자일과 도메인 주도 설계
- DDD는 애자일을 지향
- 내가 원하는 구조가 나올때까지 리팩터링
- 도메인 모델은 코드이기때문에 만들면서 가야 한다. 
	- 사전에 만들고 시작하는건 비현실적이다. 💩

> 이벤트 스톰

> 나는 이걸 계속 리팩터링 할거라는 마인드가 있어야 한다. ⭕️

> DDD에서 리팩터링은 중요하다


`슬라이드125` 애자일 선언문
- https://agilemanifesto.org/iso/ko/manifesto.html
- 도메인 전문가와 개발자 팀이 협업해야 한다. 


`슬라이드127` XP 실천방법


`슬라이드130` 도약 
- 파트3에 대한 내용은 가볍게 말하고 넘어감 
- "리팩터링 하다보면 어느순간 도메인 구조에 맞춰서 코드를 잘 짜고 있다는 확신이 드는 순간이 온다"
	- 요구사항 변경이 발생해도 전체 구조가 거의 안 흔들린다. 
- 파트3에서는 이러한 마인드로 해야 한다.
	- 일단 요구사항 변경되더라도 리팩터링 해야지
	- 초반에 내가 잡는게 틀린 수 있다는 것을 인정하고 시작 


`슬라이드131` 지금까지 살펴본 내용 
- 다음 강의에서 예제를 넣으려고 함 
- 파트3가 중요함 


`슬라이드134` 마지막 파트 
- 파트4
- 레벨이 조직관점으로 바뀐다. 
- 개발자 관점보다는 조직관점으로 본다
	- DDD에 여기까지 본다는 느낌 


`슬라이드135` 핵심 - 여러 도메인 모델 
- 하나가 아닌 여러 도메인 모델이 있어야 한다 


`슬라이드136` 어디에 집중할 것인가?
- 조직관점 


`슬라이드140` 단일 도메인 모델 

> 응집도가 낮은 객체는 수정 메서드가 여러개다 
> 요구사항이 복잡해지면 .. 


`슬라이드141` 단일 도메인 모델 
- 팀을 나누면 커뮤니케이션이 끊긴다. 
- 문제는 코드를 같이 쓴다. 
- 그러다보니 수정 장애 발생시 싸우기 시작함 
- 협업 오버헤드 발생 

> 버그가 발생한다는 의미는 `의미적 충돌로 인한 언어의 모호함`


`슬라이드143`
- 서로 다른 컨텍스트에 필요한 코드들의 집합 
	- 하나의 객체에 사용자가 여러명


`슬라이드145` 사용되는 컨텍스트에 따라 모델을 분리하자 
- 쓰여지는 컨텍스트에 따라 도메인모델을 따로가자 
	- 동일한 상품이더라도 
	- 이걸 `바운디드(제한) 컨텍스트`라고 한다.📌


`슬라이드146` 바운디드 컨텍스트 


`슬라이드147` 바운디드 컨텍스트 구현 
- 소유권이 찢힌다라네 
- 바운디드 컨텍스트는 원래 MSA랑 관련 없다. 


`슬라이드148` 컨텍스트 맵 
- 컨텍스트 사이의 관계와 모델 변환 방식 정의 
- 어떻게 연동/협업할지 결정하는 것 
	- 데이터 주고 받기 위해 DTO 규격 정의 


`슬라이드149` 바운디드 컨텍스트 사이의 관계 
- 이미지 7개
- `팀은 이기적이다. 내꺼가 중요`

> 도메인 모델의 경계 == 바운디드 컨텍스트 


`슬라이드151` 전략적 디스틸레이션
- 읽어보기
- 어떤 영역이 중요하면 회사에서는 좋은 사람을 거기로 보낸다 (조직 관점, 조직 개편)
	- 가치에 투자하는 거네 ..


`슬라이드152` 코어 도메인 
- 중요한 부분이기 때문에 좋은 개발자를 때려 넣는다.


`슬라이드153` 제네릭 서브 도메인 
- 좋은 개발자를 넣을 필요 없음 
- 주니어 개발자나 소프트웨어로 대체


> 코어 도메인에는 DDD를 넣는걸 선택해서 전략적으로 대처가능. (리소스 분배)


`슬라이드162` 에릭 에반스 추천 챕터

---
> 쉬는 시간 없이 이어 간다고 함 3시 23분 

`슬라이드 163` 현재의 도메인 주도 설계

`슬라이드 164`
> 바운디드 컨텍스트 , 서브 도메인 생각
- 바운디드 : 도메인 속한 영역
- 서브 도메인은 : ...
- 뭐가 다르다는 건지 


`슬라이드 165`
- 바운디드는 솔루션 기준 
	- 예. 주문과 결제가 같이 돈다 (하나의 바운디드로 취급)
- 서브 도메인
	- 예. 주문과 결제는 두개의 서브 도메인이다. // ?? 다시 듣기 


`슬라이드 166` 도메인 주도 설계 구현 (2013📚)
- 파트4를 목차에서 위로 올려버림
- 서브 도메인 / 바운디드 컨텍스트를 잘 구분하는 걸 중요하게 생각함.
- 책 두껍다.

> 이책으로 접하면 DDD를 구현하는거라고 생각하기/오해하기 쉽다. 


`슬라이드 167` 문제 공간
- 서브 도메인은 문제 공간으로 간다 


`슬라이드 168` 솔루션 공간
- 바운디드 컨텍스트 관련 


`슬라이드 170`. 문제 공간에서 술루션 공간으로 


`슬라이드 171` 아키텍처한 구현 가이드 


`슬라이드 172`트랜잭션 당 하나의 애그리게이트 
- 결합도를 끊고 싶은데 어딘가 업데이트 치는 코드가 어디에 있다. (결합도가 높아진다)
- 애그리게이트한 디커플링을 살리기 위해 > `도메인 이벤트(Domain Event)`가 나옴


`슬라이드 173` 도메인 이벤트
- 애그리게이트의 상태 변경을 어딘가에 알리기 위해 
- 누가 받을지 모르겠지만 도메인 이벤트를 발행한다.
- 그럼 리스너가 받아서 처리한다. 


`슬라이드 177` 도메인 이벤트 📚2014
✨

`슬라이드 178` 이벤트 소싱
- 이벤트를 이벤트 스토어에 저장한다. 
- 이를 가지고 애그리게이트를 복구하는게 가능하다. 
- RDB를 안쓰고 이벤트 스토어 사용 (리플레이한다라고 함)
- 실제 사용 
- DDD에 들어옴
	- 상태 변경 트래킹하기 위해 


`슬라이드 181` 책임이 과도해진 도메인 모델 
- 조회와 수정 기능을 함께 구현하는 복잡한 도메인 모델 
	- UI, 비즈니스 룰이 꼬임.
	- ex. 엔티티를 DTO로 맵핑하면 비슷한 문제 많이 발생 


`슬라이드 183` CQRS도 공식적으로 DDD 참여 


`슬라이드 184` MSA의 유행 (2012)
- DDD는 가이드 정도였는데 
- MSA가 뜨면서 DDD를 꼭해야 하는것처럼 올라옴 
	- 또 다른 문제가 발생 

// 애그리게이트 단위, 바운디드 컨텍스트 단위, 


`슬라이드 185` 헥사고날 아키텍처의 재조명 (2005)
- 주문이 사용자일수도 다른 시스템 요청일수도 있다.
- 동일한 출력을 가지고 여러개
- 하나의 포트에 여러개의 어답터를 연결
- 사용자 중심의 시스템이 아니라, 인터렉션을 통해 여러 시스템과 ..
- 다양한 기술을 어댑터 형태로 포트에 연결한게 헥사고날 .. 

> 좋은 개념이네 정도였는데 갑자기 올라옴

> 헥사고날은 복잡한 상황을 가정함

> 꼭 DDD할떄 헥사고날 할 필요가 없다. 


`슬라이드 186` 도메인 주도 설계의 재조명


`슬라이드 189` 도메인 주도 설계와 도메인 중심 아키텍처 
- 3가지 이미지 


`슬라이드 190` 도제인 주도 설계 패턴, 원칙, 실천 방법 목차
- DDD 책 중 구현 관점에서 좋은 책 📚 (구현 관점에서 제일 좋다고 생각하신다함 )📌
- 다만, C# 닷넷 쪽이고 번역 안되어 있음 

// 오후 3:43분 휴식

Q. 데드라인이 정해진 SI에서도 애자일을 할 수 있는가
A. 우리에게 선택권이 없다. 하지만 제일 중요한거는 만드는 걸로..

Q. 바운디드 컨텍스트
A. 팀 구조를 따르면 된다. 문제가 되는건 사람이 늘어 대화가 꼬이게 되는 순간. 각각의 조직이 다른 조직과 대화가 최소화가 되도 잘 되는거. 바운디드 컨텍스트는 팀의 경계다. 그걸 안 정하면 비용이 증가한다. 이상적인건 도메인 단위로 나뉘는데 시간지나면 깨진다. 서브도메인은 논리적인 영역, 사업영역이라서 애매하다. 이건 회사마다 사업마다 다르다. 반면 바운디드 컨텍스트는 명확하다. 

// 모르는걸 모른다고 

---
> 4시에 시작 , 녹음 끊고 재시작 

### 모델 주도 설계의 빌딩 블록

`슬라이드194` 모델 주도 설계
- **파트2**에 대한 얘기

`슬라이드199` 빌딩 블록의 목적 
- 도메인 표현하기 위한 
- 생명주기 .. 위한 

> 가이드이고, 복잡성을 낮추는게 궁극적인 목표


`슬라이드204` 도메인 개념 
- 답을 정해두고 예제 설명 

> 객체지향과 DDD의 교집합 부분이 있다. 
- 객체 관점에서 도메인 모델링함 ..
	- 도메인 모델링을 객체지향에 맞춰 함. 해석하기 편하려고 📌
	- 도메인 모델링은 개념이다.


> 도메인 모델 만드는 이유는 > 코드 짤려고 > 시스템 기능을 구현하려고


`슬라이드210` DDD에서의 기능 구현  
- `기능 요구사항`과 `불변식`을 `애그리게이트`로 구현  (!= 객체 지향과 많이 다름, 충돌 나는 부분 발생)
	- 객체는 모두 참조로 연결되는데, 애그리게이트는 불변식으로 경계를 자른다. 📌


`슬라이드217`  불변식 
- 실무에서 
	- 기능 + 상품 룰을 따로 정리해서 주는 경우가 있다. 
	- 이걸 결국 이어야 한다. 개발자가 
- 불변식으로 소화하려면 정의해야 한다.
	- 떠먹이는 형태로 오지 않다. 
	- 하나의 불변식이 재활용되기도 한다. 

> 불변식을 기준으로 애그리게이트를 가져간다.✅

> 예제 코드는 못 살펴보고, 개념 설명을 주로 한 후 보면 된다.


`슬라이드218` 엔티티와 값 객체
- 차이점. 


`슬라이드219` 엔티티
- 정의 (책 내용)


`슬라이드220` 값 객체


`슬라이드221` 엔티티와 값 객체 
- 도메인 상에서 정의되어있지 않다. 
- 내가 선택하게 되어 있다. 
- 어떻게 사용할 건지에 따라 구분된다. 
- 예. 
	- 사람을 기준으로 엔티티 설명 , 사람을 구분할 수 있어야 해고  탐색(Tracking) 가능해야 한다.
	- 숫자 4가 여러개 있을때 어떤걸 쓰든 상관없는 경우 값 객체 설명
- 돈이 조페공사한테 엔티티일 수 있다. 
	- 내가 걔를 어떤식으로 쓸거냐에 따라 엔티티와 값 객체가 갈림


`슬라이드222` 연속성과 식별성 - 엔티티 
- 엔티티
	- 식별 가능해야 한다. (식별성)
	- 상태 변경에 대한 Tracking 가능해야 한다. (연속성)


`슬라이드226` 엔티티의 연속성 
- 형태는 다른데, 같은 애라고 tracking

`슬라이드227` 엔티티의 식별성 
- 다른 엔티티와 구별하기 위한 식별자 추가

`슬라이드228` 명칭이 변경된다면?
- 동일한 Shop으로 추적(연속성)


`슬라이드230` 엔티티의 단점 
- 상태가 다를 경우에도 동일한 객체로 식별하는데 따르는 복잡성 


`슬라이드231` 값 객체와 복잡성 낮추기
- 엔티티는 상태 변경을 추적하고 식별자로 구분되야 한다. 
- 값 객체는 불변적인 속성으로 고정 시킴 
	- 그래서 식별성이 없다. 
	- 값만 같다고 동일하다고 판단. 📌

> 돈이 어느 은행으로 오든 똑같은 만원이다. (값 객체)
> 만약 돈의 번호를 트래킹하면 엔티티 


`슬라이드233` 동일성과 동등성
- 엔티티는 식별자가 동일해야 한다.
- 값 객체는 속성이 동등해야 한다.

> DDD에서는 최대한 값 객체를 많이 만들려고 한다. 
- 엔티티를 최대한 줄이려고 한다.
- 내가 구현할 때 어떻게 쓰냐가 중요
- 룰1. 엔티티인데 VO로 써도 되는지 고민한다. 


`슬라이드234` 엔티티 기반 클래스 
- DomainEntity를 선언해서 상속하면 엔티티라고 할 수 있다.
- `관습처럼 굳어짐`
- 엔티티는 **Id(식별자)만 비교**


`슬라이드236` 값 객체 기반 클래스 
- **모든 값 자체를 비교**하게 된다. 
	- 식별자가 없기 때문에  ✅
- `ValueObject` 추상 클래스를 정의하네 


`슬라이드238`
- 엔티티 안에 값 객체가 포함됨


> 객체지향이 Value인것도 엔티티인것도 들어오다보니 .. 

`슬라이드240` 값객체와 복잡성 낮추기 
- 값 객체는 불변 ✅
	- 바뀌는 부분을 최소화한다. 📌

> 설계에서 중요한건 바뀌는걸 최소화한다. 


`슬라이드241` Money가 가변객체라면
상태가 바뀌면 가변객체 // 엔티티, 객체 지향 
상태가 고정이면 불변 객체 // vo


`슬라이드242` Money가 가변 객체라면
> 가변 객체는 상태가 누적되기 때문에 히스토리를 추적해야 한다. 📌
- 디버깅하기, 이해하기 힘들다. 

`슬라이드243` Money가 불변 객체라면
- vo는 데이터가 아니다 
- 행위가 중요하기 때문에 object이다.

> 상태 변경을 Vo로 보내고 불변으로 뜯어내면 이해하기 쉬워보인다.✨
- 리팩터링에서 vo를 쪼개는게 좋다.
- 의미적으로 그룹핑 할 수 있는 속성이 있다. 📌


`슬라이드246` 머니가 가변 객체라면 
- 사이드 이펙트가 버그가 된다.
- 의도된거면 상관없는데, 
- alias때문에 공유 참조되어 변경이 전파된다. 


`슬라이드247` 머니가 불변 객체라면


`슬라이드248`
> 전반적으로 값 객체를 많이 만드는게 좋다 📌 메모리 고민할 필요도 없다. 
> VO 용도가 한번 만들어 쓰고 빨리 버리는거다.

옛날에 new String() 선언 너무 많이해서 문제 발생했었지만, 요즘은 거의 못봄 
> String 문자열 풀을 통해 참조를 해버린다. 표준 라이브러리에서 보내는 형식은 값 객체이다. 
- 문제가 생길때까지 기다려바라.
	- 이상하게 짜지 않는 이상..
- VO 사용해서 코드를 읽는 리소스를 줄일 수 있는게 훨씬 좋다. ✅

> 새로운 값 객체를 만들어 불변 유지하고 사이드 이펙트를 낮춘다 ✅


`슬라이드250`
- 클래스 여러개 만드는게 표현력에 좋은데 . 예시에서는 요일별로 Map에 데이터 선언 
- vo는 항상 쌍으로 쓰이는게 있다 📌
- 영업시간이라는 객체로 뽑아 박아 버리는게 낫다. (vo)


`슬라이드253`
- 엔티티에 있던 복잡한 알고리즘, 로직을 VO에 넘길 수 있다.
- 그러면 엔티티가 읽기 편해진다. 

// 넥스트 스텝에서 VO를 뽑아라는게 이런 내용이었구나.. 잘 설명하지 못했던거 같네

> 값 객체는 리팩터링하면서 나온다. 처음부터 찾기가 힘들다. 개념중심이 아닌 행위 중심이다📌✅
- 엔티티가 길어질때 뜯어내면서 VO가 나온다.

> 도메인 모델에서 리팩터링은 필수이다 ✅


`슬라이드256` 모든 상태 변경을 엔티티로 
- Shop이 Aggregate root구나.


`슬라이드257` 엔티티인가, 값 객체인가 
- 돈이 있을때 도메인에 따라 엔티티/값 객체로 구분될 수 있다.

// 4시 50분 휴식 시간.

> VO로 뽑는게 심플해지는 케이스가 있다. 
- 도메인 오브젝트 (=엔티티) ✅

Q. 객체지향과 DDD는 다르다에 대해 
- A, B가 있을때 DDD는 둘 다 끊어져있다. (바운디드 컨텍스트)
	- 묘하게 객체지향이 섞여 있어 보이는게 DDD다
- 객체지향은 A,B가 이어져 있다. 참조가 있어 결합도가 있다. 
- <u>애그리게이터 경계안에서는 객체지향과 DDD가 동일한데 경계가 끊어지면 달라지게 된다.</u>

Q. 애그리게이터의 경계를 넘나 들기 위해 객체가 필요한가
- 로직 하나에만 쓰이면 그냥 둔다.
- 같은 바운디드 컨텍스트면 B를 A의 메서드 파라미터로 넣을지 , 아예 못하게 할지 갈린다. 
	- A가 B라는걸 몰랐으면 싶은 경우도 있다.
- <u>애그리게이트는 A와 B가 특정 조건에 대해 같이 바껴야 한다 (경계)</u>
	- 에그리 게이트가 생각보다 크면 안된다. 



---

> 오후 5시 , 이어서 녹음 

파트3, 파트4가 복잡하다.


`슬라이드258`
- 애그리게이트(=엔티티), 값 객체를 거의 같이 쓴다. 따로 쓰진 않는다. 


`슬라이드259` 도메인 주도 설계
- 책임 주도 설계 < `기능 요구사항`
- 계약에 의한 설계 < `불변식`

// 불변식때문에 객체지향과 차이가 있다. 


`슬라이드262` 불변식  
- 트랜잭션 일관성 

// 앞에 강의의 예제를 다시 설명. 객체가 아닌 데이터 관점으로 접근해서 수정하다보면 정합성 깨짐 
// 도메인 룰에 따라 애그리게이트(경계)를 잡아 불변식을 지키도록 하면 데이터 정합성을 유지할 수 있다. 

`슬라이드267` 애그리게이트 📌 
- (설명)
- `경계(boundary)`를 쳐서 안에 있는 애들은 막아버림 


`슬라이드268` Boundary 정의  
- 특정한 객체를 통해서만 내부의 객체 접근 
- Order 를 통해 OrderLineItem 접근가능 
	- 직접 말하지마
	- 이게 `애그리게이트`다


`슬라이드271` 애그리게이트📌
- `루트(root)`와 `경계(boundary)`
- 루트는 하나만 포함되고, 그게 `엔티티`다 
- **애그리게이트 루트**는 **엔티티**로 바꿀 수 있다. 
	- 나머지는 vo로 바꿀 수 있다. 
- 경계 바깥의 객체 접근은 루트를 통해서만 접근 가능하도록 한다. 
	- 불변식이 깨지지 않도록

> 객체지향에서는 미들맨이라는게 있다. DDD는 애그리게이트라는 큰 단위로 명시적으로 정의


// 내가 객체지향으로 하고 있는지 .. DDD를 섞어서 하고 있는지 모호하네 ..


`슬라이드273` 전역 식별성과 지역 식별성
- 애그리루트 : 전역 식별성 가짐 
- 하위 자식 : 지역 식별성 가짐
	- 직접 가져오는 방법은 없다. 
	- 애그리루트를 통해서 가져옴
	- 그래서 식별자가 안에서만 유니크하기만 하면된다📌
	- 그리고 vo로 바껴도 상관없음. 내가 구현하기 편하면 바꿔친다 ✅ 


`슬라이드275` 애그리게이트 


`슬라이드276` 애그리게이트 전체에 걸친 불변식 유지  
- 하위 OrderLineItem을 컨트롤러하는게 Order 붙어버리니.. 차라리 뜯어내는게 낫다


`슬라이드280` 리파지토리
- (정의)
- 애그리게이트 루트를 읽고 저장하는 리포지토리를 붙여버림 
	- DDD로 안짜면 엔티티 별로 레파지토리를 다 만들게 됨 💩
	- 이 경우 DDD가 아님 
	- 테이블 개수보다 리파지토리 개수가 적다. 
- 화면에 보여지는 조회는 다른거다.
- 조회해서 상태를 변경하거나, 따른거에 변경을 위해 조회하거나 하는 리파지토리를 설명하고 있다.✅

// 살짝 ddd처럼 과제 구현하고 있는건가 싶다. 애그리게이트 루트 .. ??

> DDD 레파지토리랑 스프링 CRUD 레파지토리랑 개념이 조금 다르다. 그 시절 얘기인데 지금은 똑같은거라 봐도 될듯.
- 원래 리포지토리는 도메인 로직꺼다.. 도메인레이어에 있어야 한다. 
- 현재는 리포지토리 이름은 유지하는데 레이어를 빼버린다. 
- 스프링이 DDD에서 용어를 많이 가져와 넣어버림 🤔

// 애그리게이트 루트 단위에 대해서만 리파지토리를 붙인다.

`슬라이드281` 리포지토리 


`슬라이드283` 리포지토리를 이해하기 위해서는 `연관관계` 이해가필요 

`슬라이드284` 연관관계 정의 

`슬라이드285` 연관관계 단순화 

> 객체는 양방향이 없다. 단방향이다. 고로 양방향은 단방향을 엮은거다 
- 양방향은 복잡한게 `sync`를 맞춰야 한다 

`슬라이드286`
> a,b가 같이 바뀌는게 의도가 아니면 양방향을 해서는 안된다. 📌
- 결합도에 대한 설명을 함.

> 애그리게이트 루트는 안에 있는거 변경되도 바깥으로 전파 안되도록 한다. 경계 설정을 함으로써
- <u>뭔가 변경시 영향이 어디까지만 가도록 하는게 설계다</u>

> 패키지에 사이클을 돌지 말라는 말이. 변경과 관련된거다.

> 불변식 변경시 애그리게이트 루트만 변경하면 된다

> 연관관계 방향은 의도적으로 결정한다. 최대한 사이드 이펙트가 적은 방향으로 짠다. 
- 주문 <-> 사람 
- `도메인 관점에서 양방향으로 보이지만 의존성 관점에서 단방향을 선택 ✅`
	- 결합도를 낮추는 방법을 공부하는게 좋다
- 보통 이런걸 데이터 조회할 때 발생함.
	- 비즈니스 로직에서 하면 안된다. 
- 결론은 양방향은 좋지 않다.


`슬라이드287` 다중성 줄이기
> 1:n(일대다)보다 n:1(다대일)이 낫다 📌
- 주문이 사용자를 거는게 낫다. 
- 유지보수 관점에서 

`슬라이드288`
- 일대다보다 일대일이 낫다

`슬라이드289`
- 불필요한 연관관계 제거하기 
- 단방향이 있다는건 외래키에 대한 작업이 필요하다는 의미... // 내가 이렇게 한거 같은데 ..
// 디비 관점과 객체 관점은 다르다
// 객체는 행위 관점


`슬라이드291` 객체 참조를 통한 탐색(강한 결합도)
- 의도/이유를 가지고 객체 선언 📌
	- **Shop이 바뀔때 주문이 바껴도 되라는 의도가 포함됨**🤔

`슬라이드292` 
- Order에서 shopId 만 가지고 다른 객체를 통해 shop을 조회가능 
	- 이 역할을 리파지토리가 해준다
- 결합도를 낮출 수 있다. 

// 내가 EF Core를 잘못 선언한건가????????
// 관점 신기한데 .. 나 이런거 상상도 못함.. 객체 참조를 가지고 있는거에 대한 의미가 
// 경계까지 같이 잡힌다는 의미구나 .. 객체 참조를 가진다는 의미가. (중요 ,, )

`슬라이드294` 리포지토리


`슬라이드295` 
객체 참조가 있으면 누군가는 호출한다 > 경계가 깨진다. 
cusomterId를 가지고 있다면 경계가 끊어지게 되는거다 

`슬라이드296`
애그리게이트 외부는 리포지토리를 통해 탐색

`슬라이드297`
애그리게이트 내부는 객체 참조를 통해 탐색한다.


> 비즈니스 룰이 바뀌면 애그리게이터 안에서는 결합도를 높여도 상관없다. 양방향 걸어도 상관없다. 객체 참조를 가진다.

> 특정Id값을 속성으로 가지는 경우가 경계를 끊는다는게 눈에 띈다. ✅


`슬라이드304` 애그리게이트 정리 ✨ (읽어보기)

// 이해되시죠 제가 무슨말 하려고 하는지 (반복)

---
### 애그리게이트 경계 정하기 (306)
> 오후 5시 40분

`슬라이드308` 붋변식
- 유효성 검사가 애그리게이터 루트에 들어간다. 


> DDD 방식의 구현에 대한 설명 

> 상태 기반으로 유효성 검사 로직을 설명 
> 상태가 바뀌는 시점에 유효성 검사 실행📌


슬라이드 324까지 불변식에 대한 설명 
- 상태에 대한 유효성 검사 
- 애그리게이트 루트에서 실행 
- 중복로직을 불변식으로 뽑아낸다. 

// 요때 딴 생각하다가 보니깐 흐름을 놓침🥹


애그리게이트 : 주문 , 고객 
바운디드 컨텍스트 : 주문 , 상품

> 마지막 6시 설명 시작

✅ (중요) 불변식 기준으로 애그리게이트 경계를 잡으면 된다


`슬라이드326` 애그리게이트 경계 정하기 
- Option 단위보다 Menu단위로 커뮤니케이션하는게 편하다 
- 루트는 애그리게이터 경계 사이에 첫번쨰가 자연스럽게 결정된다. 
- 루트는 불변 체크 로직을 다 가지고 있다. 


`슬라이드327` 엔티티와 값 객체 정하기 
- 애그리 루트는 엔티티고 
	- 하위는 엔티티나 vo 

`슬라이드330` 연관관계 방향 정하기 

`슬라이드333` 불변식에 따라 애그리게이트 경계가 달라질 수 있다. 
- 불변식 조건에 따라 쪼개실 수 있다. 
	- 다만 경계를 끊는게 복잡도가 높아질 수 있다. 
	- 성능적으로 트래픽도 많고 주기가 다르다면 경계를 끊는게 나을 수 있다.
- 개념적으로 .. 실용적으로 접근해서 애그리게이트를 묶는게 좋을 수 있다. ✅

> 불변식에 따라 애그리게이트 경계가 달라질 수 있다. 📌
> 경계때문에 싸우는 경우도 많다. >> 기본적으로 비즈니스 룰로 설명해야 한다. 
- <u>전반적으로 실용적으로 편하게 가져가는게 애그리 경계다</u>


`슬라이드336` Munu와 Shop Aggregate   


`슬라이드337` Menu 애그리게이트 루트 


`슬라이드339` 불변식 통제는 루트의 책임 


`슬라이드340` 기능은 애
- 포워딩 방식으로 기능 구현
- 책임 주도 설계 
- 객체지향 설계와 똑같음

> 불변식 기준으로 경계를 잡음 (DDD의 기본)

> 등록/삭제/업데이트든 불변식 (유효성 검사) 로직이 처리 됨


`슬라이드349`
- 논쟁
- 옵션 그룹을 찾을 수 있는 뭔가를 받는게 좋기는한데 
	- 지역식별자를 통해 안에서 찾으면 된다. 

`슬라이드350`
- 옵션 그룹은 지금 엔티티로 모델링이 되어있다. 
- 옵셔 그룹의 이름을 바꾸는 메서드는 메뉴에 존재한다. 
	- 그래서 메뉴에서 옵션 그룹 식별자로 찾아서 이름을 바꾸면 된다.  📌
- 만약 옵션 그룹이 VO이면 불변으로 갈아치운다 

> 속성만 변경하는게 편하면 엔티티로, 그냥 불변 객체로 갈아끼우는게 편하면 VO 📌

`슬라이드355` 옵션 그룹의 이름 변경 (컨트롤러)

> 중요한건 엔티티는 식별자로 찾아 상태만 바꾸는거고, VO는 불변 객체 교체 

> VO는 찾을때 값으로 식별자를 찾아야 한다. 

// 엔티티와 VO를 실용적인 관점에서 접근해서 정의하네.. (의도적으로)


`슬라이드357`
- 경우에 따라 옵션 그룹과 옵션을 둘다 VO로 바꿀 수 있다. 
- 사용자가 전체를 변경하는 경우가 있으니깐 .. 한꺼번에 밀어 넣을때는 VO로 처리하는게 다 날려버리고 새로 넣는게 편하다 // .. ?
- 트레이드 오프 
	- 매번 delete가 발생하는게 싫을 수 있다. 

> 애그리루트를 제외한 나머지는 VO로 하는걸 가이드한다 (DDD)
> 이럴려면 밖에서 안에꺼를 참조해서는 안된다. 


`슬라이드364` 값 객체 컬렉션 데이터베이스 매핑 
- FK랑 값 속성을 PK로 다 잡음 

> 애그게이트를 제외한 나머지는 entity, vo로 만들지는 내 선택이다. 보통 vo로 만드는게 경우에 따라 편할 수 있다. 

> 엔티티는 update (tracking), vo는 delete


`슬라이드365`
- `JPA 엔티티 != DDD 엔티티`
	- JPA 엔티티는 기술적 관점 : 메타 어노테이션으로 지정하는거 비즈니스 로직이랑 상관 x
	- DDD 엔티티는 비즈니스 로직 관점 
- JPA 엔티티를 넣고 DDD 로직을 넣으면 JPA 엔티티를 DDD 엔티티로 사용할 수 있다. ✅

> 객체는 행위관점이다 . 

> 데이터 관점은 맵핑하기 힘드니 JPA한테 해달라는거다 


`슬라이드366`
- JPA Entity -> DDD Entity 매핑해서 사용가능 
- 이 방식이 싫으시단다. 
- 그래서 테이블 소유권이 있다면 매핍하지 않는다. 

📌 확실하지 않으면 가장 단순한 방법으로 먼저 간다. (조영호님)
> 얼마나 달라요라고 할때 아직 달라요. 
> JPA, DDD 엔티티를 분리하려면 명확하게 다른거라는걸 인지하고 있어야지 의미가 있다. 
> 근데 이게 명확하지 않은데 초기에 수정이 많이 발생하게 된다. (JPA, DDD 엔티티 둘다 수정)
> 테이블에 대한 주도권이 개발자에게 있다면 매핑이 편한 구조로 간다. 

> 처음에 JPA + DDD 엔티티로 시작해서, 어느 영역에 복잡해지기 시작하면 그때 거기만 분리하는게 좋다. 
> 전체 매핑하도록 하면 일관성 지키기 지친다. 초기에 엔티티 변경이 많이 발생하니깐 .. 



### 리포지토리 구현하기 (367)
repository 상속을 받지 않고, 끝어서 생성자 주입해서 사용하는 방법도 있는데 굳이 .. 

> 하나의 목적 때문에 여러개를 고치게 되는데 별 차이는 없는데 수정 사항은 많다. 


### 팩토리와 서비스 (373)
장바구니에 담은 걸 주문으로 생성해야 한다. 

애그리게이터를 생성하려면 불변식을 만족하는 상태로 생성이 되야 한다. 
이럴떄는 외부의 데이터가 필요할 수도 있다. (또는 다른 객체 상태가 필요할 수도)

> DDD는 다 애그리게이터 중심이다.


`슬라이드 377` 팩토리 
- 애그리게이트를 생성하는 일이 복잡해지면 팩토리를 사용 

`슬라이드 378` 팩토리 
- 불변식 이행이 중요하다. 

> 애그리게이터를 만드는게 복잡하니 어디선가 책임을 가지게 한다. 

Cart가 Order의 팩토리인 경우 결합도가 높아짐 
-> 그래서 중간에 독립적인 OrderFactory를 생성한다. 
-> 팩토리는 단순히 객체가 아니라 불변식을 보장하는 애그리게이터를 만든다. 


`슬라이드 386` 서비스
- 객체나 어그리게이트나 넣기 힘든 연산이 있을대 서비스 사용 (DDD)
	- 스프링에서 DDD의 서비스를 가져왔다고 앞에서 말함 

`슬라이드 388` 서비스
- 잘만들어진 서비스는 다음의 세가지 특징이 있다. 
	- ..

이메일 중복 검사 -> 디비 조회해야 하는데 .. 

📌 도메인 서비스 언급 
> 애플리케이션 서비스에 있는 조건 로직이 모호할때가 있다. 
> 도메인 로직은 컴퓨터랑 상관없는 로직이다. 
> 애그리게이터에 넣기 모호할때는 `도메인 서비스`를 사용하기도 한다. 


**도메인 로직 누수 방지** -> 명칭이 새롭다.📌
- 불필요하게 도메인 서비스를 뽑아 쓰는거는 않좋아한다. 
- 1개 정도..
- 이것조차 도메인 서비스로 분리하게 되면 바이패스..

> 잘 도는게 중요하지, 무리하게 분리하고 맞추는게 중요한건 아니다. 



### 기타 (396)
- 애그리게이터 경계가 나눠져서 상태 변경이 필요한 경우
	- 예로. 주문시 고객의 주문 건수 증가시켜야 하는 경우
	- 이벤트 처리, 배치 처리, 비동기 카프카 등등 으로 이후 처리 하는게 나을 수도
	- 도메인 이벤트.. (스프링 예시)
		- 비즈니스 로직이 문제 생겨 롤백되면 이벤트는 발행된 이후가 된다. 
		- 근데 스프링 데이터 사용하면 이벤트를 쌓아뒀다가, 커밋이 되면 이벤트 발행한다. 
		- 이게 `스프링 모듈리스`로 들어갔다고 함✅
			- `아웃박스`까지 지원한다고 함
			- 도메인 이벤트를 사용하기 편하게 지원한다.


spring data jdbc도 있다. 
- spring jpa는 복잡하다.
- 심플하게 쓰면 좋은데.. 잘못된 관행으로 복잡하게 쓴다. 
- 심플하게 쓰고 싶다면 spring data jdbc 사용도 고려해볼 수 있다. 
	- 어노테이션이 두개뿐.
	- 단점이 상속, 다형성이 안됨 
	- 애그리게이터 내부 전체를 값 전체로 구성 
	- 네이티브 쿼리 사용 
	- 내부적으로 기본 sql은 지원 

> ddd 관점에서 spring data jdbc 괜찮다. 
> 애그리게이터 빼고 vo로 넣는다면 ..


> 짜는게 중요한게 아니라 왜 그렇게 하는게 중요하다. 

바운디드 컨텍스트를 왜 할려고 해? 를 생각해보면 .. 

ddd 도입시 이러한걸 고려해야 된다는 걸 ..

오전에 한게 ddd란 이런거다 (오해하지 말자)

프로세스 적인걸로 ddd를 접근해버리면 싸움이 많아진다. 

잘못쓰면 다른 길로 센다. 

> DDD라는게 이런거다 라는거만 이해하면 좋을거 같다. 


