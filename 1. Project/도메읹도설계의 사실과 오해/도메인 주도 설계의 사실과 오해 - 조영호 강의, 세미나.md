- `2025-10-11(토)`

> DDD 에 대해 
> ✅ 신입 : 필요, 시니어 : 복잡

객체지향 != DDD
📌 DDD 꽤 복잡
- 에릭 에반스 도서 : DDD
	- 이해하기 힘들다 (개념이 추상적)
	- **📚 국내 도서**
		- 도메인주도 설계 구현
		- 도메인주도 설계 첫걸음 등등
		- 단, 그 다음 나온 책은 원서를 전체 커버하지 않는다 
---

>[!note] 
>DDD 를 개발 관점, 조직관점에서 얘기하기도 한다. 
>큰 문제에 대한 사고 방식이라.. DDD가 커버하는 범위가 넓다

`파트1`
- 에릭에반스 책의 전체 흐름 , 목차를 훓는다
	- 읽기 힘들고, 예제도 힘들고 💩
- DDD는 `패턴 집합`이다
	- 약간 GoF, Head First 디자인 패턴 같은 느낌
	- 각각의 패턴이 독립적
- 패턴 랭귀지 : 일정 패턴, 흐름의 집합 

`파트2`
- 엔티티, VO에 대한 오해
- 에그리게이트 개념 중심으로 설명 
	- 책의 파트4개 중 
- 우선순위 낮다.
- 개발자 관점 

>[!info] 후속 강의 파트3, 4 계획 중인데 따라 하기 어렵다. 거의 다 만들어서 후속 강의 오픈 예정

> 설계가 한방에 되는 줄 오해 👉 계속 뒤집는다.

---

### 오전 
> 객체지향 != DDD
> - 공통점 ❌ 

> 프로젝트에 DDD 개념을 섞어서 쓰다보니 객체지향과 DDD에 대한 혼란이 발생 

> DDD 가이드를 따르다보면 필요이상으로 복잡해 지는 부분도 있다

> 모든 책에는 저자의 주관적인 견해가 들어간다 (나는 이렇게 생각해)
> - 전제로 까는 컨텍스트가 있다.
> - 이게 곧 정답은 아니다

도메인에 관련 문제를 해결하는게 == sw

해결해야될 문제보다 기술에 꽂히는 시기가 있다 => 밸런스가 나중에 찾아간다 (중요한 시기)

sw의 본질적인 문제, 복잡성을 해결하기 위해 나온게 DDD 도서
- 구현 관점/기법에만 빠져 오해하기 쉬움 (!= 본질 아님, 이건 결과물이다)
	- 문제는 심플한데, 코드 복잡도가 높아질 수 있다.
- 📌`문제를 해결하기 위해 (사용자 요구사항 > 기능 > 유지보수) 어떻게 복잡성을 낮출 거냐`
	- 사고방식, 우선순위 모음 👉 복잡한 문제를 단순하게 풀 수 있다

`객체지향`
- 블라블라

`함수형` 
- 블라블라

`DDD`
- 우선순위, 사고방식 모음 >> **철학적인 관점**으로 설명 

> DDD 볼때마다 새롭다는데 ✨


**파트1. 동작하는 도메인 모델 만들기 (핵심)**
- DDD 정의 
- DDD 궁극적인 목적

> 이런 문제가 발생할때 이런 패턴을 사용하면 복잡도가 낮아질거다.

>도메인. 사용자가 프로그램을 사용하는 주제 영역
>- 어떤 기능을 쓰는가

<u>sw는 전체/큰 문제중에 범위를 먼저 줄이는/정하는 것으로 시작 </u>
- 요구사항 범위를 줄인다. 
	- sw에 담을 범위 선정 : 메뉴, 주문, 결제
- `도메인` : 내가 개발하려할때 내가 해결하려는 문제에 대해 범위를 선정하는게 도메인이다. (개발자 입장)
	- <u>어디서부터 어디까지 해결하려는 범위</u>📌
- `모델` : 대상의 단순화 
	- 중요하지 않은 세부사항은 생략
	- CS, 배달라이더의 책임은 뺀다 
	- <u>실제로 개발해야 하는 걸 추린다. 그렇게 복잡한거를 단순화 시킨다.</u>
		- 추상화, 모델링이라 한다.
		- 본질만 냅두고 불필요한 세부사항을 버린다.📌
		- 추상화는 모호한게 아니라 명확해야 한다.
			- **sw 개발에서 추상화는 명확하다.**
			- `추상화는 최대한 늦게 도입해라`는 말이 명확해야 하기 때문
		- 같은 뷰를 바라볼 수 있도록 구조화 📌

> 음식 배달 에제가 "도메인 모델"이라고 보면 됨


> 도메인 모델을 클래스 다이어그램으로 표현하는 이유가 객체 지향 개발을 하기 때문에 설명하기 편하려고 그렇게 설명 > 목적은 코드를 짜는거이기 때문에 도메인 모델을 클래스 다이어그램으로 표현 

`슬라이드 18`

분석 / 설계 / 구현 모델 -- 90년대 
- DDD 관점에서는 다른게 아니라는 걸 인지 (전제로 깜)
	- 📌 DDD의 핵심은 도메인 모델을 처음부터 끝까지 끌고가는게 핵심
	- 📌  도메인 모델을 동작하게 만드는게 핵심 

> 도메인 모델, 설계, 코드가 다른게 아니다 (슬라이드21). 👉 코드를 고치는 순간 다 고쳐진다. 
- 시계방향, 반시계 방향으로 인식 
	- `모델 주도 설계 (Model -Drivent Design)`
		- 3가지가 함께 변경된다.
		- 📌 모델이랑 코드가 같이 싱크를 맞추면서 영향을 주고 받으며 바뀌는거다
		- DDD와 함계 MDD가 언제나 나온다.

> 개발자 관점에서 `도메인 모델은 코드와 같다(DDD)` 
> 📌 Tip. 도메인 모델을 코드로 치환해도 말이 되야 한다 


파트1.은 개발자 혼자서 하기 힘들고, 관계자가 포함된다.
- 지식 탐구 (`슬라이드28`)
	- 나혼자서 보험 도메인을 이해하는 건 어렵다.
	- 코드를 짜는데 필요한 무언가 주는 `도메인 전문가`가 필요 📌
		- 의사결정을 도와주는 `역할` 
			- ex. 개발자가 될 수도, 사장이 될 수도 
		- `도메인 전문가 == 역할`, `도메인 전문가 != 사람`
	- `저 사람들이 원하는게 뭔지 잘 캐치해/탐구해서 찾아내 (DDD)`📌
		- 능동적인 요소 
		- 도메인 전문가와 같이 얘기/대화를 많이 하면서 찾아라!

프로젝트에 맞게 적합한 용어가 있다. >> 무슨말하는지 모름 >> 시간이 지나면 같은 용어를 사용


`슬라이드29`. 유비쿼터스 언어
- `유비쿼터스` : 어디에나 있는이라는 의미
- 도메인 전문가와 사이의 **커뮤니케이션** 수단
	- DDD에서는 피드백을 주고 받는다. 
	- 용어집은 단편적인 해석
- <u>DDD는 같이 탐구해야 하기 때문에 상호간의 용어를 맞춰간다. 긴밀하게 대화하세요 </u>
	- <u>도메인 전문가와 개발자 사이의 협업이 깔려있다.</u>
		- 이게 아니라면 단편적일 것이다. 
- 교집합을 자연스럽게 만들어간다


`슬라이드31`. 도메인 주도 설계 요약
- <u>도메인 전문가와 개발자가 공통의 목표</u>를 가져야 함 
	- KPI 세우는건 목표가 안 맞는 ..
- 도메인에 적합한 코드를 만드는거니 도메인 전문가와 협업을 한다. 
- 그리고 코드와 유사한 형태가 나오기 시작한다. 
- 커뮤니케이션 용도 뿐만 아니라 다양한 프로젝트로 활용 가능해진다.
- `모든 DDD 활동에는 유비쿼터스 언어가 기반이 된다`
- 지식 탐구 > 코드 > 지식 정재하여 유비쿼터스 언어 확보해간다 (이미지 참고)


> [!summary] 
> 초반에 도메인 모델이 정확하지 않을꺼다 (전제, DDD)
> 그러니깐 계속 반복해서 리팩토링하면서 정재해야 한다고 설명 (반복)
> (요구사항도 바뀌고 하니깐.. 완벽한 설게는 없다.)


> 📌 이렇게 하면 전제하에 DDD에 나오는 패턴을 쓰는게 좋을거야. 그게 아니면 경우에 따라 더 복잡해 질거다.


`슬라이드33`. 도메인 모델의 용도 (기본, base) ✨
1. 비즈니스 지식 정리 
2. 커뮤니케이션
3. 코드 구조

> 도메인 모델을 만들어서 처음부터 끝까지 어디에서 사용하려고 한다. (DDD)

> 위의 세가지를 깔고 간다. 똑같은 규율가지고 처음부터 끝까지 적용하려고 하는데 DDD의 바탕이다.


DDD 기반에는 두가지가 깔린다.
1. `객체지향`이 성숙하던 시기에 DDD 나옴
	1. 객체지향은 작은 문제를 해결하려고, ... 포커스 맞춘게 객체지향 
	2. 코드 구조를 짜는게 객체 지향 패러다임 (유지보수 관점)

> 에릭에반스는 다 있던걸/기존에 있던걸 체계적으로 잘 모음 (90년대)
> 다른 목적으로 흩어져 있던걸 도메인을 축으로 체계화함 📌
- 객체지향 커뮤에서 해결해야 했던 문제를 도메인 관점에서 패턴화 시킨거다

---
> ⏰ 11시 30분 시작
> 백투더 퓨처 ㅋ

1. `애자일`
	1. 책을 읽으면 애자일이 기본적으로 깔려있다. 
	2. 저 시절의 애자일과 다르다.

`슬라이드38`.
- 객체지향이 커다란 문제를 해결하기에 한계가 있다. (90년대 부터)
	- 규모가 작은 복잡한 문제를 해결하기 적합 
	- 다만, 크고 복잡한 문제를 해결하려니 문제 발생 
- <u>DDD는 도메인 관점에서 객체 지향 이슈를 해결하기 위해 나옴</u>
	- 애그리게이트, 팩토리, 바운디드 컨텍스트에 대한 논의는 있었다 (명칭은 다를 뿐)

`슬라이드40`.
- 객체지향은 다이나믹 바인딩을 한다.
- GUI 등장하면서 객체 지향이 흥행
	- 그리고 매킨토시쪽 
- **객체지향은 GUI에 최적화된 패러다임이다**

> 디자인패턴 원서가 GUI 예제 기반으로 객체지향 패턴 설명 
- 특징, GUI에 필요한 컴포넌트가 메모리에 올라가 있음 (객체)


`슬라이드42`.
- 웹이 나오면서 복잡도가 급상승 (그전까지는 괜찮)
- 자바1.0, html 공부 🥹
- UI를 심플하게 복잡한 로직은 어려우니 서버사이드로 보냄 
	- 객체 지향이 백엔드로 감. >> **객체지향과 백엔드가 안 맞음, 힘듦** 📌
	- 객체 지향은 : 메모리상에 모든 객체가 있다고 가정
	- 백엔드로 가면서 디비가 붙음 
		- 메모리에 올리는데 한계가 있음 

> JPA는 반쪽자리 솔루션으로 어거지로 맞춰야 하니 현타가 오는 시기가 있다.


`슬라이드44`. 분산 객체 기술의 유행
- 코바, 디콘, EJB 컨테이너 
- 객체를 분산시키고 싶은거 (분산 객체) -> 네트워크 통신 필요 
	- 그래서 프록시/미들웨어가 필요해짐 (Stub, Skeleton)
		- (디자인 패턴 도서에서 프록시 패턴에서 본거 같다)📚
	- 하지만 네트워크 들어가는 순간 퍼포먼스가 줄어듦
		- 데이터를 모아서 보냄 >> 이때 **DTO** 개념이 나옴 
- 해결하기 위한 기술을 사용하는게 아니라 기술이 문제를 잡아먹었던 시기
	- 지금은 시스템/서비스 단위로 분산 시킴 
- 이상하다는 걸 깨닫기 시작 


`슬라이드45` 분산 객체 기술의 문제점 
- 💩 문제를 해결하는게 목적이 아니라 기술 스펙이 요구하는거에 맞춰서 코드 구현하지 않는 이상 실행조차 안됨 (옛날 제약)
- **침투적인 아키텍처**
	- 예로 단위 테스트 하나 실행하려면 서버를 실행해야 한다. 💩


객체지향의 큰 장점
- 내가 바라보는 문제와 코드의 일관성을 지킬 수 있다.
- 도메인을 바라보는 것과 코드를 바라보는것을 똑같이 로테이션은 같음 

> 도메인을 짜려는데 코드가 먹혀버리니 EJB가 아닌거 같다는 기술/책/말들이 나옴 
- 그래서 나온것 중 하나가  `Hibernate` (90년대 말 )

라이트한 컨테이너를 사용하고 싶어서 Spring 나옴 
디비에 접근하는 거는 Hibernate

> 90년대 ~ 2000년대 초반 
> 기술에 먹히던걸 회복하려고 


`슬라이드49`. 기술 관심사와 도메인 관심사의 혼재 
- 관심사의 분리
	- .. 
- EJB는 관심사로 묶어 버림 
	- 내가 사용하는 기술을 알고 사용해야 함
	- 기술 관심사 + 도메인 관심사를 섞어 버림 
	- 그래서 이게 안 좋은거 같다고 얘기 나옴
- Spring 로드 존슨이 EJB 까는 책을 씀 📚
	- 설계를 어떻게 해야 하는지 잘 나와 있다 함
	- 이 시기에 `POJO`라는 용어가 나옴


`슬라이드50`.  POJO
- Hibernate 는 POJO 기반의 영속성 프레임워크 
- spring
- 이 시기에 도메인 주도 설계 출간 📚

> 맥락을 설명해주는게 새롭네. 왜 이 기술이 나왔는지 배경 


`슬라이드52`. 분산 객체 기술의 문제점
- 도메인과 코드의 차이가 큼 
	- 번역이 필요해짐
	- 읽기 어려운 코드 > 알고리즘적으로 풀이한 코드 
		- 코드를 내가 알던 문제로 번역하기 쉽지 않다. 버그 만들기도 쉽고, 유지보수 어려움 
- <u>기술에 종속적으로 코드를 짠다는 건 바로 이 비용이 들어간다는 걸 인지</u>

> 기술에 집착한 코드는 내가 풀려는 도메인의 본질을 흐트려버림.. 도메인으로 번역하기 힘든 코드는 잘못 짠거라 할 수도..



`슬라이드53`. 해결방법. MDD
- 기술에 종속되서 코드를 바꾸지 말고, 도메인 모델을 만들고 코드를 짜면 비용이 줄어들거다.


`슬라이드54`. 침투적인 기술로 인한 커뮤니케이션의 복잡성 
- 기술 침투적이면 .. 


`슬라이드55`. 유비쿼터스 언어 


`슬라이드56`. 모델주도 설계와 유비쿼터스 언어
- 도메인 모델 그대로 코드를 짜라 
- 도메인 모델과 코드에 도메인 용어를 사용

> 기술 침투적(EJB)으로 인해 어려워지던 상황을 개선하기 위해 
> 도메인에 포커스를 맞추자. 해서 나온게 DDD
- 도메인 로직은 이렇고 우리가 해결하려는 문제는 이런거다 ✨


클린 아키텍처
- 도메인 로직에 의존성 걸지말고 떨어뜨리라.
- DDD의 연장선 


`슬라이드57`. 그래서 파트2에서는 
- 가이드를 제시
- 빌딩 블록
	- 이걸 구현하려면 이게 필요하다는걸 가이드함 
- `도메인 모델을 구현해야 하고 기술적인걸 배제해야 한다.`
	- 예. 엔티티는 언제 쓰냐면 .. 이런게 있다면.. 묶어버림 
	- 도메인 로직을 짤때는 구현시 이런 특성이 있기 때문에 구현을 이렇게 해야 한다고 가이드한다. 
- 조건. `기술적인것과 도메인 모델은 떨어져 있어야 한다. (에릭에반스)`


`슬라이드58`. 도메인 로직의 격리
- 컴퓨터 관련된 용어를 빼고 설명 가능해야 한다/로직을 짜야 한다 📌
	- 요구사항. 기술적인 용어는 배제 되어 있어야 한다. 
- 레이어 아키텍처에서 **도메인 영역**이 나눠진다. 
	- 클린아키텍처, 핵사고날 아키텍처도 이걸 만족한다. 
	- <u>도메인이 고립된다. </u>

> 헥사고날 아키텍처는 잘못쓰면 복잡하다.


`슬라이드60` 모델 주도 설계의 빌딩 블록

> 도메인 모델은 구현 가능해야 한다. 도메인 전문가와 소통이 가능하면서 코드로 표현이 되야 한다.

> 가이드이다. 이렇게 무조건 짜야 된다는게 아니라. 법칙처럼 받아들이는건 오해다 

> 파트1을 하는게 DDD이다. DDD 전제하에 파트2를 해라.

> 도메인을 이러한 특성을 가진 카테고리로 분류하면 단순해짐 > 특성이 구현의 일관성이 있을거다 > 이렇게 하면 구현 가능한 도메인을 만들수있을 거다 


**🏠 도메인을 표현하기 위한 빌딩 블록 (5가지)**
- `Association`
- `entity`
- `vo`
- `service`
- `module`


`슬라이드62` 

**🏠 생명 주기를 관리하기 위한 빌딩 블록** 
- `Aggregate`
- `Repository`
- `Factory`

> 빌딩 블록은 구현 가이드라서 쉽게 할 수 있다. 나머지는 정답이 없고 창의성을 발휘해야 함.
> 여기에 포커스를 맞추지만, 이게 곧 DDD는 아니다. 집착하면 EJB 처럼 묶이게 됨 
> 해결해야 할 문제는 따로 있는데 DDD 가이드에 묶임

---

### 오후 (파트2)
> `슬라이드63`부터 시작 예정 

> Aggregate 

`슬라이드63` 빌딩 블록의 목적 
- '도메인 모델과 코드는 별개가 아니다'
	- 뭉쳐서 생각함
- DDD는 노골적으로 끌고 올라간다. 
	- 도메인 분석은 코드를 유지보수 잘하기 위한 것이다. 
	- 도메인 모델 + 유비쿼터스 언어 = 커뮤니케이션

**🏠 도메인을 표현하기 위한 빌딩 블록**
- `Association`
- `entity`
- `vo`
- `service`
- `module`

**🏠 생명 주기를 관리하기 위한 빌딩 블록** 
- `Aggregate`
- `Repository`
- `Factory`


`슬라이드64`. 도메인 모델 예제
- 불변식
	- Order 클래스에`limitPrice : Money`


도메인 로직 

도메인 룰 
- 상태 변경 / 제거 조건

> 상태가 만들어지고 조건을 가지고 로직을 처리한다.

데이터 조회는 DDD 룰에서 벗어난다 (상관x) 📌

DDD는 불변식을 강조함/앞으로 내세운다 📌
- 객체지향은 불변식은 강조하진 않음.


`슬라이드65` 주문 현재 상태
- 불변식을 만족하는 상태


`슬라이드66` 첫번재 사용자 수정
- 상태변경이 일어나도 최종 결과물은 이 조건을 만족해야 해 (= 불변식)


`슬라이드67` 두번재 사용자 수정


`슬라이드68` 
- 점선 표시된 항목이 상태 수정된거 


> 불변식을 위반하는 케이스 슬라이드 설명
- 데이터 단위로 처리한다는게 불변식 위반할 가능성이 있다.  (데이터 관점)
- `불변식은 하나의 클래스로 말하지않고 여러 클래스를 뭉친다.` 
	- 여러개의 객체 / 엔티티를 묶어서 확인하는게 **도메인 룰**
- 그러면 관련성있는 객체를 그룹 단위로 가지고 다니면 된다. 
	- 이게 `Aggregate`이다 


`슬라이드75` Aggregate
- `불변식(기준, 제약조건, Constraint)`을 만족시키는 객체 그룹의 단위로 처리 
- 애그리게이트는 작아야 한다 
	- 구조 관점에서 크게 잡으면 ❌
	- a가 b를 포함해도 불변식은 다를 수 있다. 
- **도메인 룰 관점에서 봐야 한다.**

> DDD는 도메인을 끌고 간다. 계속 
> 기술 관점에서도 보는데, 그걸할때 기준이 뭔지 확인할때 도메인 룰로 가버림


`슬라이드76` 애그리게이트 단위로 저장하면 불변식 유지
- 개념적으로 논리적으로 경게의 기준을 찾으면 일관성있는 상태를 유지 가능 (DDD의 주장📌)
	- 도메인 규칙 / 불변식 기준으로 


> 요구사항이 바뀌더라도 이 틀이 기반으로 되면 그나마 안정적 
- 도메인 룰 기반으로 코드 구조 가지고 오는게 사이드 이펙트가 적다
- 불변식으로 경계를 잡으면 변경시 해당 그룹만 변경됨 📌
	- 비즈니스 룰을 기반으로 코드를 작성 


> DDD는 안정적으로 코드가 진화할 수 있는 기반으로 마련하고 싶은거 
- 도메인 기반으로 코드 구조를 잡고 싶은것 📌✅
- 이렇게 하면 <u>복잡성이 컨트롤 가능한 수준으로 낮아질 수 있다는게 주장</u>이다. (처음부터 끝까지 나오는 내용)


> DDD는 애그리게이터 단위로 트랜잭션을 잡아라고 가이드함
- 일관성이 맞춰진 상태에서 반영되야 하기 대문에 (비즈니스 룰이라) 트랜잭션으로 묶어라는거

`슬라이드 78`. 애그리게이트 단위로 리파지토리 추가
그래서 repository를 `애그리게이트 루트`에다가만 넣는다 
- Order + OrderLineItem이 한 세트 
- 에그리게이트 단위로 일관성있게 ..

`슬라이드 81`. 
> 객체 참조는 결합도가 높다. 끊어두고 애그리게이터 집합을 따로 관리하자
> 애그리게이트 경계관점에서 Order, Customer를 디비 처리를 같이하면 x
- 정말로 애그리게이트 내부에 있는지 없는지 고민을 해야 함 ✅
- 예로 주문(Order)시 사용자(Customer) 상태도 변경되는걸 원하는 경우도 가끔 나온다. 
	- 트랜잭션 경계..(??)
	- 를 끊어야한다.  만약 애그리게이트 경계를 합쳐버리면 커진다. 
- 결과적으로 필요하면 나중에 일관성을 맞춰주면 됨 
	- 나중에라도, 이벤츄얼 컨스턴시
	- 배치, 이벤트 처리 등등 


`슬라이드 82`.  결과적 일관성 
- 비즈니스 룰을 가지고 얘기하면 일관성이 맞춰짐 📌
	- 코드의 구조가/트랜잭션 경계가  비즈니스 룰을 기반으로 잡으면 
- 문제.👿
	- 그다지 복잡하지 않은 상황에서 쓰면 복잡해진다.
	- Order, Customer를 따로 경계를 지정해 트랜잭션 관리하게 되는데 .. 주문 카운터 증가시 추가 리소스가 들어가게 된다. 
		- 대신에 애그리게이트 경계를 끊고 트랜잭션 하나로 처리하는 것도 가능ㅎ다. 

> ddd는 복잡하다. 성능 이슈가 있을 수도있다. 
- 트래픽이 많고 트랜잭션이 많을때 애그리게이트 경계를 묶어두면 오래 걸림
	- 반면, 비즈니스 룰 관점에서 경계를 나누면 풀리는게 빠름 ✅
	- 시스템이 밀리니 끊는거다.

>코드 구조를 저렇게 잡으려면 리팩터링을 자주할 결심이 필요하다 ✅
>처음에 구조가 계속 변경될건데 그게 아니라면 복잡도만 높아짐 


> 얼마나 부딪히는지 경합이 발생하면 찢어버림 > 시스템 복잡도는 높아지지만 안정성 향상 
> >> 꼭 당연한건 아니다.


`슬라이드 83`. 지금까지 살펴본 내용
- 보통 구조만 따라가는데 .. 본질을 따라가지 않으면 경계만 찢어져서 복잡도만 높아진다.
- 주니어가 DDD를 하고 싶다는 건 모호한 부분이다. 
- DDD는 `사고 방식`이다. 
	- 개발할 때 어떻게 접근하면 좋을지 가이드 함
	- 맹목적으로 따르면 안 좋은 쪽으로 갈 수 있다.

> 코드 구조에 눈이 많이 가서 이상하게 짬 > 왜 이렇게 해라는 건지에 관심을 가져야 한다


`슬라이드84`. 
- 📌 추천은 하지 않음.
- 단, 이 책을 보면 Hibernate의 구조가 어떠한지 알 수 있다.
- 용어라도 보는게 좋다 


`슬라이드86`.  \[참고\]트랜잭션 스크립트 
- 도메인 로직을 절차지향적으로 짜는거 

`슬라이드88`. 도메인 모델 
- 아키텍처 레벨에서 도메인 로직을 객체지향적으로 짠다. ..(이 부분 다시 듣기, 뭔가 다르다는데)

// 도메인 모델 패턴과 DDD 맥락의 도메인 모델은 다르다 


로드 존슨이 깟던 코드가 spring 1.0에 나온다. 

// 휴식 시간 (오후 2시 22분)

불변식 경계는 exclusive (베타적), 겹치면 안된다 
경계식이 유효성 검사 같은거라 생각할 수 있다. 
어그리게이트 루트 ..

책📚
- 내가 당장 써먹야하는 기술책
- 내가 당장 안쓰는건데 좋다고 하는책, 봐야 하는 책 : DDD
	- 당장 써야 할때 봐도 DDD는 어렵다.
	- 일단 본다.
	- 상관없는 상황에 떠오를때가 있다. 
	- 잘 이해가 안되더라도 어떤 용어, 무언가 얘길하는걸 보고 세월이 지나 안보이는게 보인다 (성장한거)
	- 지금 당장 필요없더라도 성장에 필요하다면 본다 
	- 전제는 회사에 급한일이 있는데 그거부터 해야 마음의 여유가 생기니.. 우선순위를 잘 정한다. 💩
	- 20년째 .. 1년마다 보는데 새롭다. 내용자체가 어려운데 ..
	- 때로는 영어로 볼대가 더 이해가 잘될때가 있다. 원문의 늬앙스가 한글 번역하면 사라지기도 함
- 동떨어져 있는 개념이 없고 시간이 지나면 연결이 된다. 
- 결국. 이해는 안되더라도 한번씩 보는걸 추천한다 

> 애그리게이트 경계를 잘 정하는게 좋다.

---

> 오후 2시 30분 시작

> 파트3의 요약은 리팩터링을 계속 해라. 이다.

`슬라이드90` 애자일과 도메인 주도 설계 
- DDD는 애자일을 깐다 
- 90년대 애자일과 지금 애자일은 느낌이 다르다.
	- 변질되서 프로세스처럼 보일때가 많다. 
		

`슬라이드92`. 
`슬라이드93`. 

> 주니어 일때는 설계나 일정 추산이 어렵다. 지금도 어렵다 


`슬라이드95`.  문제. 흐릿한 요구사항 
- 요구사항을 명확히 정의하지 않고 감
	- 한번도 없었고, 더 없어질 것이다. 
	- 개발업의 종특
- 속도가 빠르다 => 경쟁 치열

> 내가 뭘 만들어지는지 모를때 일정 추산 못함, 불가능함


`슬라이드96`.  문제 - 변경되는 요구사항
- 업의 역사가 짧다.
- 건축이나 재조 업계에서 용어를 가져옴
	- ex. 아키텍처
	- 물리적으로 집을 짓다가 바꿀 수 없으니, 설계/디자인부터 한다
	- 뒤에 바뀌면 비용이 커짐
	- 물리적으로 성숙한 분야 > 반면 IT는 아닌데 얘네들 거를 가져옴 (단절된 단계, 문제 발생)
- 안 맞는거를 가져와서 억지로 끼워 맞춘거다.
	- 설계를 하는데 구현을 못하지
	- 초반에 일정 추산을 못하지
	- 와 같은 생각을 하게됨 (이상한 방식으로 우리는 일을 해야 해)


`슬라이드98`. 문제 - 예견적인 프로세스
- 일정 계획을 짜는게 비 현실적 


`슬라이드99`. 과도한 사전 설계 
- 90년대까지 이게 맞다고 생각을 함.
	- WBS 작성 후 SI 프로젝트 진행 

> 계획을 짜는건 중요하다. 계획을 무조건 지키는건 어려우니 상황에 맞춰 조정해야 한다. 
> 우리가 추청하는 일정은 틀린 일정일 거야 => 근데 이걸 지켜야 하는 약속으로 생각


`슬라이드100`. 그리고 애자일의 등장 
- https://agilemanifesto.org/iso/ko/manifesto.html


`슬라이드102`. eXtreme Programming explained by 켄트벡 
- 변경을 수용하라 (1998)
	- 꽉 막혀서 하는게 아니라, 변경이 발생하면 일정을 수정
- 애자일은 속도가 빠르다라고 잘못 판단 💩
	- `시간이 조금 갈리더라도 변경에 기민하게 일하는 방식이 반응하는게 애자일이다`📌


`슬라이드103`. XP 핵심
- 반복을 통한 피드백을 중요시함 
- 개발만큼 피드백이 빨리 주는게 없다. ✅
	- 개발이 재미있는 이유
	- 나에게 피드백 줄 수 있는 환경이 갖춰져 있다.
	- `TDD`, `CI` 도 마찬가지로 피드백을 빨리 준다

> 초반에는 요구사항을 잘 모르는데, 시간이 지나면 어떻게 되는지 안다. 
> 모르는 걸 학습하면서 배우게 된다. 


`슬라이드104`
✅ 피드백을 빨리 받을 수 있는 방식으로 프로세스를 압축시킨다.
- 초반에 잘 안보이지만, 명확한 몇가지가 있다. 
- 이걸 빨리 구현해서 배포까지 해버림
- 이걸 `이터레이션(반복적)`한다.
- 그리고 `회고`를 한다 >> 애자일에는 `회고`가 들어간다📌

> 애자일은 오래 걸리던 단계를 압축 시켜 피드백이 들어온다. 


`슬라이드111` 해결 - 반복을 통해 명확해지는 요구사항


`슬라이드112` 해결 - 짧은 주기의 반복 단위로 변경사항 반영

> 100짜리 전체 중에서 중요한거만 판단해서 현재 20만 오픈해도 되는지 의사결정, 안되면 30을 일정잡고 더 해본다. 

> 이터레이션 걸어서 반복하는게 스트레스이고 어렵다.👿


`슬라이드114` 해결 - 적응적인 프로세스
- 좋다 나쁘다를 떠나서 강제로 박아버리면 효과가 반감된다
	- 예로 테스트 커버리지 100%.
- 우리업은 제조업이 아니기 때문에 이렇게 해야한다..📌
- 우리 코드는 설계도라고 할 수 있다. 
	- 반복 생산은 빌드, 배포인데
- 애자일은 이걸 깨버린다. 


`슬라이드120` 진화적인 설계의 핵심은 리팩터링 
- 리팩터링 도서가 90년대 ~ 2000대 초
- 애자일하고 물린다. 


`슬라이드121` 애자일과 도메인 주도 설계
- DDD는 애자일을 지향
- 내가 원하는 구조가 나올때까지 리팩터링
- 도메인 모델은 코드이기때문에 만들면서 가야 한다. 
	- 사전에 만들고 시작하는건 비현실적이다. 💩

> 이벤트 스톰

> 나는 이걸 계속 리팩터링 할거라는 마인드가 있어야 한다. ⭕️

> DDD에서 리팩터링은 중요하다


`슬라이드125` 애자일 선언문
- https://agilemanifesto.org/iso/ko/manifesto.html
- 도메인 전문가와 개발자 팀이 협업해야 한다. 


`슬라이드127` XP 실천방법


`슬라이드130` 도약 
- 파트3에 대한 내용은 가볍게 말하고 넘어감 
- "리팩터링 하다보면 어느순간 도메인 구조에 맞춰서 코드를 잘 짜고 있다는 확신이 드는 순간이 온다"
	- 요구사항 변경이 발생해도 전체 구조가 거의 안 흔들린다. 
- 파트3에서는 이러한 마인드로 해야 한다.
	- 일단 요구사항 변경되더라도 리팩터링 해야지
	- 초반에 내가 잡는게 틀린 수 있다는 것을 인정하고 시작 


`슬라이드131` 지금까지 살펴본 내용 
- 다음 강의에서 예제를 넣으려고 함 
- 파트3가 중요함 


`슬라이드134` 마지막 파트 
- 파트4
- 레벨이 조직관점으로 바뀐다. 
- 개발자 관점보다는 조직관점으로 본다
	- DDD에 여기까지 본다는 느낌 


`슬라이드135` 핵심 - 여러 도메인 모델 
- 하나가 아닌 여러 도메인 모델이 있어야 한다 


`슬라이드136` 어디에 집중할 것인가?
- 조직관점 


`슬라이드140` 단일 도메인 모델 

> 응집도가 낮은 객체는 수정 메서드가 여러개다 
> 요구사항이 복잡해지면 .. 


`슬라이드141` 단일 도메인 모델 
- 팀을 나누면 커뮤니케이션이 끊긴다. 
- 문제는 코드를 같이 쓴다. 
- 그러다보니 수정 장애 발생시 싸우기 시작함 
- 협업 오버헤드 발생 

> 버그가 발생한다는 의미는 `의미적 충돌로 인한 언어의 모호함`


`슬라이드143`
- 서로 다른 컨텍스트에 필요한 코드들의 집합 
	- 하나의 객체에 사용자가 여러명


`슬라이드145` 사용되는 컨텍스트에 따라 모델을 분리하자 
- 쓰여지는 컨텍스트에 따라 도메인모델을 따로가자 
	- 동일한 상품이더라도 
	- 이걸 `바운디드(제한) 컨텍스트`라고 한다.📌


`슬라이드146` 바운디드 컨텍스트 


`슬라이드147` 바운디드 컨텍스트 구현 
- 소유권이 찢힌다라네 
- 바운디드 컨텍스트는 원래 MSA랑 관련 없다. 


`슬라이드148` 컨텍스트 맵 
- 컨텍스트 사이의 관계와 모델 변환 방식 정의 
- 어떻게 연동/협업할지 결정하는 것 
	- 데이터 주고 받기 위해 DTO 규격 정의 


`슬라이드149` 바운디드 컨텍스트 사이의 관계 
- 이미지 7개
- `팀은 이기적이다. 내꺼가 중요`

> 도메인 모델의 경계 == 바운디드 컨텍스트 


`슬라이드151` 전략적 디스틸레이션
- 읽어보기
- 어떤 영역이 중요하면 회사에서는 좋은 사람을 거기로 보낸다 (조직 관점, 조직 개편)
	- 가치에 투자하는 거네 ..


`슬라이드152` 코어 도메인 
- 중요한 부분이기 때문에 좋은 개발자를 때려 넣는다.


`슬라이드153` 제네릭 서브 도메인 
- 좋은 개발자를 넣을 필요 없음 
- 주니어 개발자나 소프트웨어로 대체


> 코어 도메인에는 DDD를 넣는걸 선택해서 전략적으로 대처가능. (리소스 분배)


`슬라이드162` 에릭 에반스 추천 챕터

---
> 쉬는 시간 없이 이어 간다고 함 3시 23분 

`슬라이드 163` 현재의 도메인 주도 설계

`슬라이드 164`
> 바운디드 컨텍스트 , 서브 도메인 생각
- 바운디드 : 도메인 속한 영역
- 서브 도메인은 : ...
- 뭐가 다르다는 건지 


`슬라이드 165`
- 바운디드는 솔루션 기준 
	- 예. 주문과 결제가 같이 돈다 (하나의 바운디드로 취급)
- 서브 도메인
	- 예. 주문과 결제는 두개의 서브 도메인이다. // ?? 다시 듣기 


`슬라이드 166` 도메인 주도 설계 구현 (2013📚)
- 파트4를 목차에서 위로 올려버림
- 서브 도메인 / 바운디드 컨텍스트를 잘 구분하는 걸 중요하게 생각함.
- 책 두껍다.

> 이책으로 접하면 DDD를 구현하는거라고 생각하기/오해하기 쉽다. 


`슬라이드 167` 문제 공간
- 서브 도메인은 문제 공간으로 간다 


`슬라이드 168` 솔루션 공간
- 바운디드 컨텍스트 관련 


`슬라이드 170`. 문제 공간에서 술루션 공간으로 


`슬라이드 171` 아키텍처한 구현 가이드 


`슬라이드 172`트랜잭션 당 하나의 애그리게이트 
- 결합도를 끊고 싶은데 어딘가 업데이트 치는 코드가 어디에 있다. (결합도가 높아진다)
- 애그리게이트한 디커플링을 살리기 위해 > `도메인 이벤트(Domain Event)`가 나옴


`슬라이드 173` 도메인 이벤트
- 애그리게이트의 상태 변경을 어딘가에 알리기 위해 
- 누가 받을지 모르겠지만 도메인 이벤트를 발행한다.
- 그럼 리스너가 받아서 처리한다. 


`슬라이드 177` 도메인 이벤트 📚2014
✨

`슬라이드 178` 이벤트 소싱
- 이벤트를 이벤트 스토어에 저장한다. 
- 이를 가지고 애그리게이트를 복구하는게 가능하다. 
- RDB를 안쓰고 이벤트 스토어 사용 (리플레이한다라고 함)
- 실제 사용 
- DDD에 들어옴
	- 상태 변경 트래킹하기 위해 


`슬라이드 181` 책임이 과도해진 도메인 모델 
- 조회와 수정 기능을 함께 구현하는 복잡한 도메인 모델 
	- UI, 비즈니스 룰이 꼬임.
	- ex. 엔티티를 DTO로 맵핑하면 비슷한 문제 많이 발생 


`슬라이드 183` CQRS도 공식적으로 DDD 참여 


`슬라이드 184` MSA의 유행 (2012)
- DDD는 가이드 정도였는데 
- MSA가 뜨면서 DDD를 꼭해야 하는것처럼 올라옴 
	- 또 다른 문제가 발생 

// 애그리게이트 단위, 바운디드 컨텍스트 단위, 


`슬라이드 185` 헥사고날 아키텍처의 재조명 (2005)
- 주문이 사용자일수도 다른 시스템 요청일수도 있다.
- 동일한 출력을 가지고 여러개
- 하나의 포트에 여러개의 어답터를 연결
- 사용자 중심의 시스템이 아니라, 인터렉션을 통해 여러 시스템과 ..
- 다양한 기술을 어댑터 형태로 포트에 연결한게 헥사고날 .. 

> 좋은 개념이네 정도였는데 갑자기 올라옴

> 헥사고날은 복잡한 상황을 가정함

> 꼭 DDD할떄 헥사고날 할 필요가 없다. 


`슬라이드 186` 도메인 주도 설계의 재조명


`슬라이드 189` 도메인 주도 설계와 도메인 중심 아키텍처 
- 3가지 이미지 


`슬라이드 190` 도제인 주도 설계 패턴, 원칙, 실천 방법 목차
- DDD 책 중 구현 관점에서 좋은 책 📚 (구현 관점에서 제일 좋다고 생각하신다함 )📌
- 다만, C# 닷넷 쪽이고 번역 안되어 있음 

// 오후 3:43분 휴식

Q. 데드라인이 정해진 SI에서도 애자일을 할 수 있는가
A. 우리에게 선택권이 없다. 하지만 제일 중요한거는 만드는 걸로..

Q. 바운디드 컨텍스트
A. 팀 구조를 따르면 된다. 문제가 되는건 사람이 늘어 대화가 꼬이게 되는 순간. 각각의 조직이 다른 조직과 대화가 최소화가 되도 잘 되는거. 바운디드 컨텍스트는 팀의 경계다. 그걸 안 정하면 비용이 증가한다. 이상적인건 도메인 단위로 나뉘는데 시간지나면 깨진다. 서브도메인은 논리적인 영역, 사업영역이라서 애매하다. 이건 회사마다 사업마다 다르다. 반면 바운디드 컨텍스트는 명확하다. 

---
> 4시에 시작 

### 모델 주도 설계의 빌딩 블록

`슬라이드194` 모델 주도 설계
- **파트2**에 대한 얘기

`슬라이드199` 빌딩 블록의 목적 
- 도메인 표현하기 위한 
- 생명주기 .. 위한 

> 가이드이고, 복잡성을 낮추는게 궁극적인 목표


`슬라이드204` 도메인 개념 
- 답을 정해두고 예제 설명 


