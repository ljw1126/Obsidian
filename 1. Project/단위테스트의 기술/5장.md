4장에서 목과 스텁을 수동으로 직접 작성하는 방법을 살펴보았다

이번 장에서는 **격리 프레임워크**(=모의 프레임워크, mocking framework)를 공부한다 

>[!info] 격리 프레임워크
>런타임에 가짜 객체를 생성하고 설정할 수 있는 재사용 가능한 라이브러리를 의미한다
>이러한 객체는 동적 스텁, 동적 목 이라고 한다


모듈형, 함수형, 객체 지향형을 어떻게 사용할 수 있는지 살펴본다
이들을 사용하면서 테스트의 가독성, 유지 보수성, 지속 가능한 테스트 등이 프레임워크들이 지향하는 가치를 배울 수 있다

### 5.1 격리 프레임워크 정의
객체나 함수 형태의 목이나 스텁을 동적으로 생성, 구성, 검증할 수 있게 해주는 프로그래밍 가능한 API다. 격리 프레임워크를 사용하면 이러한 작업을 수 작업으로 했을 때보다 더 간단하고 빠르며 코드도 더 짧게 작성할 수 있다.

#### 5.1.1 선택하기: 느슨한 타입 대 정적 타입
- 느슨한 타입의 자바스크립트 격리 프레임워크
	- 제스트와 사이넌 등
- 정적 타입의 자바스크립트 격리 프레임워크
	- substitute.js 등

의존성 타입에 따라 
- 모듈 의존성(import, require) 
	- 제스트 같은 느슨한 타입의 프레임워크가 좋다
- 함수형 의존성(단일 함수, 고차 함수, 간단한 매개변수와 값)
	- 모듈 의존성과 마찬가지로, 제스트와 같은 느슨한 타입의 프레임워크가 잘 어울린다
- 객체 전체, 객체 계층 구조, 인터페이스 
	- substitute.js 같은 객체 지향적인 프레임워크가 어울린다

### 5.2 동적으로 가짜 모듈 만들기
앞서 했던 PasswordVerifier 예제와 제스트를 계속 사용할 예정


>[!note] 명령과 쿼리 분리
>명령과 쿼리 분리라는 설계 방식이 있다. 이 용어에 대해 더 알고 싶다면 마틴 파울러가 2005년에 쓴글을 읽어보기 바란다. 이 패턴은 다양한 설계 아이디어를 이해하는데 매우 유용하다
https://medium.com/@joohotheman/%EB%B2%88%EC%97%AD-%EB%A7%88%ED%8B%B4-%ED%8C%8C%EC%9A%B8%EB%9F%AC-cqrs-%ED%8F%AC%EC%8A%A4%ED%8C%85-245c63bb1e58


ex) configuration-servier.js 에서 로그 레벨 조회하려고 **쿼리** 보내고,
PasswordVerifier에서 로그를 남기라고 **명령**을 보낸다


#### 5.2.1 제스트 API에 대해 알아 둘 점
제스트로 스텁을 만들때나 목을 만들때나 모든 곳에서 'mock' 단어를 사용하여 헷갈릴 수 있다
<u>'stub'이라는 단어를 'mock'과 동일한 의미로 사용하면 더 와닿을 것이다 </u>

<u>제스트와 같은 프레임워크가 없었다면 모듈을 직접 가짜로 만드는 것이 엄청나게 번거로웠을 것이다.</u> 
//결국 4장에서 했던게 수작업으로 mock을 만들었던 거였구나 

p431
그러나 jest.mock의 단점은 제어권이 있는 코드까지 모두 가짜로 만들어 버린다는 것이다.
이렇게 하면 실제 의존성을 더 간단한 내부 API로 추상화하여 숨기는 방식의 이점을 놓칠 수 있다
이러한 접근 방식 포트와 어댑터 아키텍처(헥사고날 아키텍처)라고도 한다
(코드의 유지보수성이 뛰어나다는 단점이 있다)


### 5.3 함수형 스타일의 동적 목과 스텁
초기화 단계에서 선언만 하고, 검증단계에서 메소드 체인을 통해서 확인하는게 심플해짐


### 5.4 객체 지향 스타일의 동적 목과 스텁

인터페이스 변경이 발생할 경우 모의 객체가 여러 군데 있게 되면 수정이 여러 군데 발생한다 
이러한 모의 객체를 팩토리 함수와 같은 함수 내부로 옮겨서 객체의 생성 처리를 한 곳에서만 하는 것이 좋은 선택일 수 있다.

p447
>[!info] 격리 프레임워크와 AAA 패턴 
>격리 프레임워크를 사용하는 방식은 우리가 1장에서 살펴본 AAA 패턴과 잘 맞아 떨어진다 .
>.. 그외 읽어보기

참고. **AAA패턴**: 테스트 코드를 `준비(Arrange) - 실행(Act) - 검증(Assert)` 순으로 작성

