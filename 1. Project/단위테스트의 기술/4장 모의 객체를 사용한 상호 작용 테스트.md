### 4.1 상호 작용 테스트, 목, 스텁
**상호 작용 테스트**
- 작업 단위가 제어할 수 없는 영역에 있는 의존성과 어떻게 상호 작용하고 메시지를 보내는지(함수를 호출하는지) 확인하는 방법이다.
- 모의 함수(mock function)나 모의 객체(mock object)를  사용하여 외부 의존성을 제대로 호출했는지 검증할 수 있다

**목(mock)**
- 외부로 나가는 의존성과 연결 고리를 끊는데 사용한다
- 목은 가짜로 만든 모듈이나 객체 및 함수
- 단위 테스트에서 **종료점**을 나타낸다

목은 어떤 대상을 흉내내어 만들었기 때문에 호출되었는지 검증하는 것이 중요하다
호출 여부를 검증하지 않으면 목을 사용하지 않는 것이나 마찬가지이다
유지보수와 가독성 때문에 보통 하나의 테스트에 목은 한 개만 사용하는 것이 일반적이다

**스텁(stub)**
- 내부로 들어오는 의존성과 연결 고리를 끊는데 사용한다
- 테스트 코드에 가짜 동작이나 데이터를 제공하는 가짜 모듈, 객체, 함수를 의미한다
- 목과 달리 스텁은 호출 검증할 필요가 없고, 하나의 테스트에 여러 개 사용할 수 있다

스텁은 데이터나 동작이 **작업 단위로 들어오는** 경유지를 나타내며 종료점은 나타내지 않는다
스텁은 상호 작용이 발생하는 지점으로 볼 수 있지만, 작업 단위의 최종 결과를 나타내지 않는다


### 4.2 로거 함수에 의존
- PasswordVerifier 함수에 로거(외부 의존성) 함수 호출하는 로직을 추가 

p350
표4-1. 가짜 객체를 주입하는 방법(참고)

### 4.3 기본 스타일: 매개변수를 주입하는 방식으로 리팩터링
p356
매개변수를 추가하는 간단한 리팩터링으로 얻을 수 있는 이점 
- 더이상 테스트 코드에서 import, require 구문을 사용하여 로거 함수를 불러올 필요 없다
	- 이는 나중에 실제 로거 함수의 의존성을 변경하더라도 테스트할 코드를 변경할 이유가 줄어든다는 의미이기도 하다
- 우리가 원하는 **로거 함수를 어떤 방식으로든** 만들어 주입할 수 있다
	- 이 함수가 동일한 인터페이스를 구현하기만 하면 된다
	- 우리가 임의로 만든 로거 함수(mockLog)는 테스트할 때 함수가 제대로 호출되었는지 확인하는 용도로 사용할 수 있다

// 앞에 3장에서 했던 에제와 별 차이 없는 내용이다

### 4.4 목과 스텁을 구분하는 것의 중요성
// 목과 스텁이 조금 .. 구분이 덜된다 

목은 작업 단위의 요구사항을 나타낸다 
- 예. 로거를 호출한다, 이메일을 보낸다
- // 실행 내용을 오버라이딩 해서 정의, 인터페이스를 그대로 구현
스텁은 들어오는 정보나 동작을 나타낸다
- 데이터베이스 쿼리가 false를 반환한다, 특정 설정이 오류를 일으킨다
- // 결과값을 그대로 리턴하거나, 실행하거나

**목은 테스트당 하나만 사용**하는 것이 좋다
- 목이 여러 개라는 것은 하나의 테스트에서 여러 요구 사항을 테스트한다는 의미가 될수 있기 때문

일관된 이름 규칙을 고수하면 다음 장점이 있다 
- 가독성
- 유지보수성
- 신뢰성

p359 **검증 룰렛(assertion roulette)** 용어
- 하나의 테스트에 여러 개의 목(= 요구사항)이 있을 때, 위에 하나가 틀리면 나머지 다른 목은 검증될 수 없어 결과를 알 수 없게 된다.. // 테스트 유지보수성 어려워짐
- 30%만 보고 처방을 내리는 돌팔이 의사가 있을때
	- 나머지는 검증이 안되었기 때문에 오진이 발생할 수 있다
	- 테스트 코드도 마찬가지이다 
	- 모든 버그를 철저히 살피지 않고 대충 처리하거나 문제가 하나가 아니라 두 개 있을 경우 어디에 문제가 발생했는지 제대로 파악하지 못하고 잘못된 부분을 수정할 가능성이 높아진다


#### chat-gpt 질의 응답 1
**나**: 단위 테스트의 기술에서 목과 스텁에 대한 차이를 설명하는데 조금 이해가 되지 않습니다. 목과 스텁이나 외부 의존성을 다루기 위한 방법으로 차이는 스텁은 외부 의존성을 호출시 지정한 임의 상태를 반환받아 검증하고 목은 외부 의존성을 호출시 종료점, 반환값 등이 정상 호출되었는지 검증하는 걸로 이해하고 있습니다. 상태와 행위의 차이로 이해하면 될까요

**chat-gpt**
네, 정확한 방향으로 이해하고 계십니다!

단순하게 정리하면:

- **스텁(Stub)** → _상태 검증_: 특정 입력에 대해 미리 정해진 값을 반환하도록 설정하여 테스트를 진행함. (ex. "A를 주면 B를 반환")
- **목(Mock)** → _행위 검증_: 특정 메서드가 예상한 횟수만큼 호출되었는지, 예상한 인자로 호출되었는지 등을 검증함.

즉,  
✔️ **스텁**은 외부 의존성이 _어떤 값을 반환해야 하는지_를 고정하여 테스트를 수행하고,  
✔️ **목**은 외부 의존성이 _어떻게 호출되었는지_를 검증하는 데 집중합니다.

예제를 보면 차이가 더 명확해질 거예요.

### 1️⃣ 스텁(Stub) 예제

```java
when(orderRepository.findById(1L))
    .thenReturn(Optional.of(new Order(1L, "상품1")));
```

👉 `orderRepository.findById(1L)`이 호출되면 항상 `Optional.of(new Order(1L, "상품1"))`를 반환하도록 지정함.  
👉 반환값을 확인하면서 *기능(상태)*이 올바르게 동작하는지 검증할 때 사용.

### 2️⃣ 목(Mock) 예제

```java
verify(orderRepository, times(1)).save(any(Order.class));
```

👉 `orderRepository.save()`가 정확히 **한 번** 호출되었는지 검증.  
👉 호출 여부 및 횟수 같은 _행위_를 검증하는 데 사용.

---

이 차이를 **상태 기반 테스트 vs. 행위 기반 테스트**로 이해하면 좋아요!  
✔ **스텁** → "이런 상태를 가정하고 코드가 잘 동작하는가?" (상태 기반)  
✔ **목** → "이런 방식으로 의존성을 호출했는가?" (행위 기반)

이제 좀 더 명확해졌나요? 😊

#### chat-gpt 질의 응답 2
**나**: bdd 스타일로 예시 해줬는데, 데이터베이스 조회 결과를 지정하는 것은 stub이라 구분하는거였나요?? 저는 전부다 mock이라고 생각해왔습니다. verify를 하지 않은 것은 전부 stub이었겠군요

**chat-gpt 답변**
네! 정확하게 이해하셨습니다.

`when(...).thenReturn(...)` 같은 방식으로 **특정 값을 반환하도록 설정하는 것**은 **스텁(Stub)**입니다.  
반면, `verify(...)`를 사용해서 **메서드가 호출되었는지 검증하는 것**은 **목(Mock)**입니다.

즉,

- **스텁**: 반환값을 미리 지정하여 상태 기반 테스트를 수행 (행위 검증 X)
- **목**: 메서드 호출 여부와 횟수 등을 검증하는 행위 기반 테스트

---

### ✅ BDD 스타일로 다시 정리

```java
// Given - 스텁 설정 (Stub)
given(orderRepository.findById(1L))
    .willReturn(Optional.of(new Order(1L, "상품1")));

// When - 서비스 실행
Order order = orderService.getOrderById(1L);

// Then - 상태 검증
assertThat(order.getName()).isEqualTo("상품1");

// verify를 하지 않았으므로 Stub 역할만 수행
```

👉 `given(...).willReturn(...)`을 사용하여 특정 값을 반환하도록 설정한 것은 **스텁** 역할.  
👉 `verify(...)`를 사용하지 않았으므로 **행위 검증을 하지 않음**.

---

### ✅ 행위 검증(Mock) 예제

```java
// Given - 스텁 설정
given(orderRepository.save(any(Order.class))).willReturn(new Order(2L, "상품2"));

// When - 서비스 실행
orderService.createOrder("상품2");

// Then - 행위 검증
then(orderRepository).should(times(1)).save(any(Order.class));
```

👉 `then(orderRepository).should(times(1)).save(...)`를 사용하여 호출 여부 검증 → **Mock 역할**

---

### 🔹 정리

✔ `when(...).thenReturn(...)`만 사용하면 **Stub**  
✔ `verify(...), should(...)`를 사용하면 **Mock**

> "verify를 하지 않은 것은 전부 Stub" → 네, 정확합니다!  
> Mockito의 `mock()`으로 만든 객체라도 검증을 하지 않으면 Stub 역할만 수행하게 됩니다. 😊


### 4.5 모듈 스타일의 목
#### 4.5.2 모듈 주입 방식으로 코드 리팩터링
예제 4-7 ~ 10까지 이해가 안됨.. 
커링과 부분 적용이라는게.. 결국 테스트에서 외부 의존성을 쉽게 테스트하기 위해서 그런다는건 동일한데...

#### chat-gpt lodash curry에 대해 
`lodash`의 `curry` 함수는 **함수를 부분적으로 적용할 수 있도록 변환하는 함수**입니다. 즉, 여러 개의 인자를 받는 함수를 하나씩 인자를 적용해 나갈 수 있도록 변환하는 역할을 합니다.
// 부분 함수 형태로 함수 인자를 나눠서 순차적으로 적용할 수 있도록 지원
## 사용 방법

`_.curry(func)`는 원래 함수 `func`을 커리 함수로 변환하여 반환합니다. 변환된 함수는 필요한 모든 인자가 전달될 때까지 계속 새로운 함수를 반환하며, 모든 인자가 전달되면 원래 함수가 실행됩니다.

## 예제

```javascript
const _ = require('lodash');

const sum = (a, b, c) => a + b + c;

const curriedSum = _.curry(sum);

console.log(curriedSum(1, 2, 3)); // 6 (모든 인자를 한 번에 전달)
console.log(curriedSum(1)(2, 3)); // 6 (부분 적용)
console.log(curriedSum(1)(2)(3)); // 6 (한 개씩 적용)
```

## 동작 방식

1. `_.curry`를 적용하면, 인자가 부족하면 계속 새로운 함수를 반환함.
2. 모든 인자가 다 전달되면 원래 함수가 실행됨.
3. 여러 개의 인자를 한꺼번에 전달할 수도 있고, 한 개씩 전달할 수도 있음.

## 언제 사용하나요?

- 함수형 프로그래밍에서 **부분 적용(partial application)**을 활용할 때
- 같은 로직을 여러 곳에서 다르게 사용해야 할 때
- 재사용성을 높이고 코드 가독성을 개선할 때

예를 들어, 특정 값을 기준으로 필터링하는 함수를 커리화하면 활용도가 높아집니다.

```javascript
const isGreaterThan = _.curry((min, value) => value > min);

const isGreaterThan10 = isGreaterThan(10);

console.log(isGreaterThan10(15)); // true
console.log(isGreaterThan10(5));  // false
```

이처럼 `curry`를 사용하면 특정 인자를 미리 적용하여 새로운 함수를 쉽게 만들 수 있습니다.

순차적으로 부분 함수 조합이 만들어 질 수 있다
```javascript
const _ = require('lodash');

const sum = _.curry((a, b, c) => a + b + c);

console.log(sum(1)(2)(3)); // ✅ 6 (순차적 적용)
console.log(sum(1, 2)(3)); // ✅ 6 (순차적 적용)
console.log(sum(1)(2, 3)); // ✅ 6 (순차적 적용)
```


### 4.7 객체 지향 스타일의 목
#### 4.7.1 의존성 주입을 위한 코드 리팩토링
클래스는 생성자를 갖고 있으며 생성자를 통해 클래스의 호출자가 매개변수를 전달하도록 강제할 수 있다. 이것은 객체 지향적인 설계에서 매우 일반적이다 

// 고차 함수나 모듈 주입이나 결국 따로 함수를 정의해서 외부에서 의존성을 주입하는데, 클래스 방식은 생성자 초기화시 강제할 수 있기 때문에 오히려 심플해보인다

p384
생성자를 사용하면 의존성이 필수적이라는 것을 명확히 나타낼 수 있어 코드의 가독성과 유지 보수성을 높일 수 있다.

p385
이름에 'Fake'를 포함함으로써 **실제 코드가 아님을 강조**한 것이다

#### 4.7.2 인터페이스 주입을 이용한 코드 리팩터링
인터페이스는 객체 지향 프로그램에서 중요한 역할을 한다. 이는 다형성의 한 형태로, 동일한 인터페이스를 구현하는 객체들을 서로 대체할 수 있게 한다.

자바스크립트나 루비 같은 언어에서는 인터페이스가 필요하지 않다. 이 언어들은 객체를 특정 인터페이스로 반환하지 않고도 <u>덕 타이핑을 허용</u>하기 때문이다.

자바스크립트에서는 타입스크립트를 사용하여 인터페이스를 활용할 수 있다. 우리가 사용할 컴파일러나 **트랜스파일러**는 타입을 올바르게 사용하는지 확인해 줄 수 있다


p392 인터페이스 이름을 짓는 방법 ( 저자 방식 참고 )

#### 4.8.3 복잡한 인터페이스를 직접 사용할 때 단점
// 읽어보기 

#### 4.8.4 인터페이스 분리 원칙(ISP)
ISP는 인터페이스에 필요한 것보다 더 많은 기능이 포함되어 있으면 필요한 기능만 포함된 더 작은 어댑터 인터페이스를 만들어야 한다는 것이다. 따라서 가능한 한 함수를 더 적게 만들고 이름을 더 명확하게 짓고 매개변수를 덜 사용하도록 하면 좋다.

이렇게 하면 테스트가 훨씬 간단하다. 실제 의존성을 추상화함으로써 복잡한 인터페이스가 변경되더라도 테스트를 변경할 필요가 없다. 어댑터 클래스 파일 하나만 변경하면 된다.


### 4.9 부분 모의 객체 (spy)

여기에서 중요한 점은 testableLog는 **부분 모의 객체** 라는 것이다. 이는 testableLog의 메서드 중 일부가 실제 의존성과 로직을 포함한 함수라는 의미이다. 

부분 모의 객체를 사용하는 것이 효율적일 때도 있다. 예를 들어 레거시 코드를 다룰 때 기존 코드와 의존성을 분리해야 할 경우에 유용하다.

#### 4.9.2 부분 모의 객체를 객체 지향 방식으로 풀어보기 
TestableLogger 클래스는 실제 메서드와 오버라이드한 메서드가 공존하는 형태이다
- 이 방식은 추출 및 오버라이드(extract and override)라고 함 
- 이 내용은 마이클 패더스가 쓴 <레거시 코드 활용 전략>에서 더 자세히 다룬다


### 4.10 요약

목을 작업 단위에 주입하는 방식은 여러 가지이다
- 표준 방식: 매개변수를 추가하여 주입
- 함수형 방식: 부분 적용 또는 팩토리 함수를 사용하여 주입
- 모듈 방식: 모듈 의존성을 추상화하여 주입
- 객체 지향 방식: 생성자 초기화로 강제

또한 자바스크립트에서는 복잡한 인터페이스를 부분적으로 구현할 수 있어 반복 코드를 줄일 수 있다.
또 실제 클래스를 상속받아 일부 메서드만 가짜로 대체하는 **부분 모의 객체(마지막 예제)** 를 사용하는 방식도 있다