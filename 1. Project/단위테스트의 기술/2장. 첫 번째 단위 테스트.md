
### 2.1 제스트 소개 

**제스트(jest)**
- 페이스북에서 만든 오픈 소스 테스트 프레임워크
- 백엔드와 프런트엔드 프로젝트 테스트 모두에 널리 사용되고 있다
- 두 가지 주요 테스트 구문을 지원한다
	- test라는 단어를 사용
	- 자스민(jasmin)문법을 기반
- 두 방식을 모두 시도해 보고 어떤 것이 더 나은지 살펴본다

제스트는 jest.config.js 또는 package.json 파일이 필요하다

**초기화**
```shell
cd ch2-first-test
npm init --yes

// 또는 
yarn init --yes
```


프로젝트에 의존되게 설치하는 경우 /프로젝트 루트/node_modeuls/.bin 폴더에 jest.js 파일이 생성된다. 아래는 글로벌로 설치하는 방법이다 

```shell
npm install -g jest    // 글로벌 설치
npx jest       // 제스트 실행 
```

이렇게 하면 테스트가 있는 폴더 어디에서나 npm을 거치지 않고도 터미널에서 직접 제스트 명령어를 실행할 수 있다. 

<u>실제 프로젝트에서는 전역으로 설치한 제스트를 사용하는 대신 npm 명령어로 테스트를 실행하는 것이 일반적이다</u>


#### 2.1.4 테스트 파일 생성 
제스트는 테스트 파일을 찾을 때 기본적으로 다음 규칙을 따른다 
- `__tests__` 폴더가 있으면 그 안의 모든 파일을 이름과 상관없이 테스트 파일로 간주하고 불러온다
- 프로젝트 최상위 폴더 아래에 있는 모든 폴더를 대상으로 `*.spec.js` 또는 `*.test.js`로 끝나느 파일을 재귀적으로 찾는다

우선 첫번째 규칙을 따르고, 나중에 파일을 옮기거나 폴더를 사용하지 않는 경우 개발 일관성 유지하기 위해 파일이름을 `*.spec.js` 또는 `*.test.js`로 끝나도록 만들 예정이다

제스트를 사용할 때 파일 위에 `require()`를 쓸 필요는 없다.  제스트는 자동으로 글로벌 함수를 불러온다(import). 주로 많이 사용하는 함수로는 test, describe, it, expect 등이 있다 

>[!note] 테스트 파일 위치 
>- 폴더 아래에 모아두거나, 테스트 대상 모듈 옆에 두거나 하는 방법이 있다
>- 프로젝트 전체에서 일관성을 유지하며 테스트 파일을 쉽게 찾을 수 있도록 하는 것이 중요하다
>- 필자는 테스트 폴더에 배치하는 쪽을 선호
>- 테스트에 필요한 헬퍼(helper) 파일을 테스트 폴더 근처에 둘 수 있어 편리하기 때문이다. 빠른 탐색 측면에서도 이점이 있다.


**파일 생성**
```js
// 실패하는 테스트
test('hello jest', () => {
  expect('hello').toEqual('goodbye');
});
```

#### 2.1.5 제스트 실행
아래 명령어를 실행하면 루트 폴더(ex. ch2-first-test)에서 실행하면 node_modules 디렉터리에서 제스트를 불러와 실행한다
```shell
npx jest
```


p154 실패하는 테스트와 성공하는 테스트 출력의 구성 설명* (not bad)

```js
// 성공하는 테스트
test('hello jest', () => {
  expect('hello').toEqual('hello');'
});
```


>[!tip] `jest --watch` 명령어
>제스트가 파일 변화를 감지하고 변경된 파일에 대한 테스트를 자동으로 실행한다. 매번 제스트를 재실행할 필요도 없어지고, 매 실행마다 걸리는 내부적인 초기화 작업을 건너뛰게 되며, 테스트가 많아지면 상당한 시간을 절약할 수 있다. 즉, 지속적인 테스트 프로세스에 큰 도움이 된다.

<u>제스트는 비동기 테스트와 콜백도 지원한다 (책의 후반부, 제스트 문저 참고)</u>


### 2.2 라이브러리, 검증, 러너, 리포터
제스트는 다음 역할을 한다
- 테스트를 작성할 때 사용하는 **테스트 라이브러리** 역할
- 테스트 내에서 expect 함수를 사용하는 **검증(assertion)** 라이브러리 역할
- **테스트 러너(runner)** 역할
- 테스트 실행 결과를 보여주는 **테스트 리포터(reporter)** 역할

또 제스트는 목(mock), 스텁(stub), 스파이(spy) 등을 생성할 수 있는 격리(isolation) 기능도 지원한다. (..) 하지만 자.스에서는 이러한 기능 중 일부만 제공하는 테스트 프레임워크가 많다. 이는 '한 가지 기능에 충실한 것'이라는 철학 때문일 수도 있고, 다른 이유가 있을 수도 있다. <u>어쨋든 제스트는 이 모든 기능을 하나로 통합한 몇 안 되는 테스트 프레임워크 중 하나이다.</u>


### 2.3 단위 테스트 프레임워크가 제공하는 기능 
제스트 프레임워크를 사용하면서 달라진 점 
- 테스트 코드의 일관된 형식
- 반복성
- 신뢰성과 시간 절약
- 공동의 이해

요약하자면 단위 테스트 프레임워크는 테스트 작성부터 실행, 검증까지 과정을 매우 효율적으로 만들므로 시간을 투자해서 학습할 가치가 충분하다.

p162 ~ 163 참고하기 . 테스트 프레임워크로 할 수 있는 것에 대한 설명

>[!note] 단위 테스트 프레임워크를 사용한다고 해서 테스트가 가독성, 유지보수성, 신뢰성을 보장하지 안는다. 게다가 모든 로직을 테스트할 수 있는 것도 아니다 (..)

p167
제스트는 엄밀히 말해 xUnit이나 TAP 프레임워크가 아니다. 기본적으로 xUnit이나 TAP 규격을 따르지 않기 때문이다. 하지만 xUnit 스타일의 테스트 리포팅이 빌드 환경에서 여전히 많이 사용되고 있기에 빌드 서버에서 리포팅을 그 프로토콜에 맞추는 것이 좋다
- `jest-xunit` 모듈을 설치하면 제스트 테스트 결과를 대부분의 빌드 도구에서 쉽게 처리할 수 있다
- 반면에 TAP 형식의 출력을 원한다면 `jest-tap-reporter`를 사용한다. 그런 다음 프로젝트의 jest.config.js 파일을 사용하여 제스트의 보고 형식을 설정할 수 있다.

### 2.4 앞으로  이 책에서 주로 다루는 예제: 비밀번호 검증 프로젝트
- p169 ~ 250까지 내용을 다룬다

```js
// password-verifier0.js
const verifyPassword = (input, rules => {
        const errors = [];
        rules.forEach(rule => {
          const result = rule(input);
          if(!result.passed) {
             errors.push(`error ${result.reason}`);
          }
        });

        return errors;
};
```

### 2.5 verifyPassword() 함수의 첫 번째 테스트 코드
AAA패턴: 테스트 코드를 `준비(Arrange) - 실행(Act) - 검증(Assert)` 순으로 작성


---
- npm trends 참고
- 단위 테스트 프레임워크가 약 900개 정도 넘는다 (위키백과 참고)

---
도서 오타 
2.1.3 제스트 설치 - npm init 중복이다 (p147)