
p257
- 이번 장에서는 <u>반환 값을 가진 종료점</u>과 <u>상태 값을 변경하는 종료점</u>을 사용하여 예제를 만든다 
- 또 종료점의 마지막 유형인 서드 파티 호출(외부 의존성)을 다룰 예정
- 새로운 요구 사항인 시간 값에 의존하는 코드도 살펴볼 예정이다

이를 처리하는 두 가지 방식을 살펴보는데
- 코드를 리팩터링하는 방식
- 리팩터링 없이 **몽키 패칭**을 적용하는 방식

### 3.1 의존성 유형
의존성 유형 
- 외부로 나가는 의존성 : 작업 단위의 **종료점을 나타내는 의존성**
	- 예로 로거 함수 호출, 데이터베이스 저장, 이메일 발송, API나 웹훅 알림 보내는 작업 등
- 내부로 들어오는 의존성: **종료점을 나타내지 않는 의존성**
	- 예로 데이터베이스 쿼리 결과, 파일 시스템의 파일 내용, 네트워크 응답 결과 등이 있다
	- 모두 이전 작업의 결과로, 작업 단위로 **들어오는** 수동적인 데이터 조각이라 할 수 있다

// 그림참고하면, 외부로 나가는 의존성은 종료점이 외부 의존성을 나타내지만, 내부로 들어오는 의존성은 
중간과정이기 때문에 종료점은 따로 존재한다

<u>p261 스텁과 목 관련 용어 표 정리 </u>
- 스텁에 더미 객체는 sut 이고 테스트 스텁은 sut에 주입하는 객체네
- 목에 테스트 스파이는 sut이고, 모의 객체는 sut에 의존성 주입 대상

- 스텁은 내부로 들어오는 의존성(간접 입력)을 끊어 준다
	- 스텁은 가짜 모듈이나 객체 및 가짜 동작이나 데이터를 코드 **내부로 보내는** 가짜 함수를 의미
	- 테스트 대상 코드가 외부 시스템이나 데이터 의존하지 않고도 동작할 수 있게 된다
- 목은 외부로 나가는 의존성(간접 출력 또는 종료점)을 끊어준다
	- 가짜 모듈이나 객체 및 호출 여부를 검증하는 함수를 의미한다
	- 목은 단위 테스트에서 **종료점**을 나타낸다

현업에서는 mock 이라는 단어를 스텁과 목을 모두 아우르는 용어로 사용할 때가 많다
- 혼란 야기
- <u>스텁과 목은 큰 차이가 있으며 올바른 용어를 사용하여 상대방이 무엇을 의미하는지 명확히 하는 것이 중요하다</u> // 용어때문에 헷갈리는 경우가 정말 많았다

p265-266 
- xUnit 테스트 패턴과 이름 규칙 설명

>[!note] 스텁, 목, 페이크의 이해
>
>- 스텁
>	- 결과값을 반환하도록 하여 데이터베이스 상태에 무관하게 검색 기능 테스트 가능
>	- 테스트의 독립성을 높여주지만, 호출 여부는 검증 x
>- 목
> 	- 외부 시스템과 상호 작용을 시뮬레이션하고, 호출여부나 호출된 인수를 검증하는데 사용된다
> 	- 예로 실제로 이메일 보내지 않으면서 이메일 발송 함수가 호출되었는지 등을 확인
> 	- 목은 하나의 테스트에서 하나만 사용하는 것이 좋다
> - 페이크
> 	- 실제 구현을 대체하는 가벼운 버전의 구성 요소다
> 	- 예로 실제 운영 데이터 베이스 대신 인메모리 데이터베이스를 사용하여 테스트를 수행할 수 있다

요악하자면
- 스텁: 미리 정의된 가짜 데이터를 제공하여 테스트 대상 코드의 입력을 시뮬레이션한다
- 목: 테스트 대상 코드가 외부 시스템과 상호 작용할 때 호출 여부와 인수를 검증한다
- 페이크: 실제 구현을 대체하는 가벼운 버전의 구성 요소를 제공하여 테스트를 수행한다
 

### 3.2 스텁을 사용하는 이유 
p269 날짜를 사용하는 경우 테스트가 어려운 이유에 대해 예제로 설명한다
- 주말 시간에만 통과하는 테스트 // 시간에 대한 의존성 가짐

좋은 테스트 기준 중 하나인 일관성을 다시 살펴보면 
- 테스트는 언제 실행하든 이전 실행과 **같은 결과를 보장해야 한다**
- 테스트 내에서 사용된 같은 변하지 않아야 하고 검증도 매번 동일해야 한다

### 3.3 스텁을 사용하는 일반적인 설계 방식
#### 3.3.1 스텁으로 만든 시간을 매개변수로 주입
- 시간을 매개변수화해서 외부에서 의존성을 주입하도록 함수와 테스트 리팩토링
- 예제 3-3 **의존성 역전** 사용 (p278)
	- currentDay 매개변수를 추가함으로써 시간 값의 통제권을 함수 호출자(테스트 코드)에 넘겨주었다. 
	- 우리가 주입하는 것은 일반적으로 '더미'라는 단순한 데이터 조각으로, 별다른 동작은 없는 코드 조각이다
	- 하지만 이 책에서는 더미를 **'스텁'** 이라고 부르겠다


p279
순수 함수는 모든 의존성을 내부적으로 주입 받기에 함수형 프로그래밍 디자인은 일반적으로 테스트하기 훨씬 쉽다는 특징이 있다.

currentDay는 '더미' 값이다. 필자는 이것이 '스텁' 범주에 포함되어 있다고 본다
함수에 전달되는 특정 입력 값이나 동작을 모방하는데 이 값을 사용하므로 역시나 스텁이라 합 수 있다고 설명

### 3.3.2 의존성, 주입, 제어 
**읽어보기.** 표로 용어 설명하고 있으니 잘 읽기 

테스트하려는 코드에 동작이나 임의의 데이터를 변경하고 주입하기가 쉬울수록 코드가 변경되더라도 테스트를 작성하고 읽고 유지보수하는 것이 더 쉬워진다.


### 3.4 함수를 이용한 주입 방법
예제 3-3에서 currentDay를 매개변수로 주입하여 외부 의존성을 끊고 **함수 레벨**에서 의존성 문제를 해결했다

자.스는 **함수형 프로그래밍**과 **객체 지향 프로그래밍** 두 가지 스타일을 사용할 수 있다.
- <u>이 장에서는 두 스타일을 사용한 서로 다른 방식을 소개할 예정이다</u>
- 디자인에 정답은 없다
- 그러나 함수형 스타일은 배우기 어렵다는 단점이 있다.
- 그렇기 때문에 이 두 방식을 모두 배우고 상황에 가장 적합한 방식을 적용하는 것이 현명하다 

#### 3.4.1 함수 주입
예제 3-4. 함수를 의존성으로 전달하기
// 자바에서 함수형 인터페이스 선언해서 람다 함수로 전달하는게 생각나네

이전 테스트와 큰 차이는 없지만, 함수를 매개변수로 전달하는 것이 가능하다.
함수를 인수로 전달하는 방법은 특정 상황에서 예외를 만들어 내거나 테스트 내에서 특정한 동작을 하도록 만들 수 있어 유용하게 사용될 수 있다.

#### 3.4.2 부분 적용을 이용한 의존성 주입
팩토리 함수는 미리 정의된 컨텍스트를 가진 함수를 반환하는 함수로, 고차함수의 일종이다
다음 예제에서는 
- 팩토리 함수를 테스트의 준비 단계에서 사용 
- 반환된 함수를 실행 단계에서 호출 
- 준비 단계에서 rules, getDayen을 인수로 전달하면서 팩토리 함수가 반환하는 새로운 함수가 이들을 참조할 수 있도록 설정한다

예제 3-6. 고차 함수 사용하기
// 함수형 프로그래밍을 사용하여 테스트를 준비하고, 실행 단계에서 실행 할대까지 지연이 되는 구나
// **좋은 예제**이다


### 3.5 모듈을 이용한 주입 방법
- 자.스에서는 모듈을 가져오거나(require) 불어오는(import) 기능을 제공한다
- 외부 의존성은 제어할 수 없기 때문에 테스트를 어렵게 한다
- 즉, 의존성을 대체할 수 있는 **심**을 만들어야 한다

p291 예제 3-7. 필수 의존성 추상화하기 
