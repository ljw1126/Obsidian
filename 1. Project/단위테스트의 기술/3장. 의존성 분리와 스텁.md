
p257
- 이번 장에서는 <u>반환 값을 가진 종료점</u>과 <u>상태 값을 변경하는 종료점</u>을 사용하여 예제를 만든다 
- 또 종료점의 마지막 유형인 서드 파티 호출(외부 의존성)을 다룰 예정
- 새로운 요구 사항인 시간 값에 의존하는 코드도 살펴볼 예정이다

이를 처리하는 두 가지 방식을 살펴보는데
- 코드를 리팩터링하는 방식
- 리팩터링 없이 **몽키 패칭**을 적용하는 방식

### 3.1 의존성 유형
의존성 유형 
- 외부로 나가는 의존성 : 작업 단위의 **종료점을 나타내는 의존성**
	- 예로 로거 함수 호출, 데이터베이스 저장, 이메일 발송, API나 웹훅 알림 보내는 작업 등
- 내부로 들어오는 의존성: **종료점을 나타내지 않는 의존성**
	- 예로 데이터베이스 쿼리 결과, 파일 시스템의 파일 내용, 네트워크 응답 결과 등이 있다
	- 모두 이전 작업의 결과로, 작업 단위로 **들어오는** 수동적인 데이터 조각이라 할 수 있다

// 그림참고하면, 외부로 나가는 의존성은 종료점이 외부 의존성을 나타내지만, 내부로 들어오는 의존성은 
중간과정이기 때문에 종료점은 따로 존재한다

<u>p261 스텁과 목 관련 용어 표 정리 </u>
- 스텁에 더미 객체는 sut 이고 테스트 스텁은 sut에 주입하는 객체네
- 목에 테스트 스파이는 sut이고, 모의 객체는 sut에 의존성 주입 대상

- 스텁은 내부로 들어오는 의존성(간접 입력)을 끊어 준다
	- 스텁은 가짜 모듈이나 객체 및 가짜 동작이나 데이터를 코드 **내부로 보내는** 가짜 함수를 의미
	- 테스트 대상 코드가 외부 시스템이나 데이터 의존하지 않고도 동작할 수 있게 된다
- 목은 외부로 나가는 의존성(간접 출력 또는 종료점)을 끊어준다
	- 가짜 모듈이나 객체 및 호출 여부를 검증하는 함수를 의미한다
	- 목은 단위 테스트에서 **종료점**을 나타낸다

현업에서는 mock 이라는 단어를 스텁과 목을 모두 아우르는 용어로 사용할 때가 많다
- 혼란 야기
- <u>스텁과 목은 큰 차이가 있으며 올바른 용어를 사용하여 상대방이 무엇을 의미하는지 명확히 하는 것이 중요하다</u> // 용어때문에 헷갈리는 경우가 정말 많았다

p265-266 
- xUnit 테스트 패턴과 이름 규칙 설명

>[!note] 스텁, 목, 페이크의 이해
>
>- 스텁
>	- 결과값을 반환하도록 하여 데이터베이스 상태에 무관하게 검색 기능 테스트 가능
>	- 테스트의 독립성을 높여주지만, 호출 여부는 검증 x
>- 목
> 	- 외부 시스템과 상호 작용을 시뮬레이션하고, 호출여부나 호출된 인수를 검증하는데 사용된다
> 	- 예로 실제로 이메일 보내지 않으면서 이메일 발송 함수가 호출되었는지 등을 확인
> 	- 목은 하나의 테스트에서 하나만 사용하는 것이 좋다
> - 페이크
> 	- 실제 구현을 대체하는 가벼운 버전의 구성 요소다
> 	- 예로 실제 운영 데이터 베이스 대신 인메모리 데이터베이스를 사용하여 테스트를 수행할 수 있다

요악하자면
- 스텁: 미리 정의된 가짜 데이터를 제공하여 테스트 대상 코드의 입력을 시뮬레이션한다
- 목: 테스트 대상 코드가 외부 시스템과 상호 작용할 때 호출 여부와 인수를 검증한다
- 페이크: 실제 구현을 대체하는 가벼운 버전의 구성 요소를 제공하여 테스트를 수행한다
 

### 3.2 스텁을 사용하는 이유 
p269 날짜를 사용하는 경우 테스트가 어려운 이유에 대해 예제로 설명한다
- 주말 시간에만 통과하는 테스트 // 시간에 대한 의존성 가짐

좋은 테스트 기준 중 하나인 일관성을 다시 살펴보면 
- 테스트는 언제 실행하든 이전 실행과 **같은 결과를 보장해야 한다**
- 테스트 내에서 사용된 같은 변하지 않아야 하고 검증도 매번 동일해야 한다

### 3.3 스텁을 사용하는 일반적인 설계 방식
#### 3.3.1 스텁으로 만든 시간을 매개변수로 주입
- 시간을 매개변수화해서 외부에서 의존성을 주입하도록 함수와 테스트 리팩토링
- 예제 3-3 **의존성 역전** 사용 (p278)
	- currentDay 매개변수를 추가함으로써 시간 값의 통제권을 함수 호출자(테스트 코드)에 넘겨주었다. 
	- 우리가 주입하는 것은 일반적으로 '더미'라는 단순한 데이터 조각으로, 별다른 동작은 없는 코드 조각이다
	- 하지만 이 책에서는 더미를 **'스텁'** 이라고 부르겠다


p279
순수 함수는 모든 의존성을 내부적으로 주입 받기에 함수형 프로그래밍 디자인은 일반적으로 테스트하기 훨씬 쉽다는 특징이 있다.

currentDay는 '더미' 값이다. 필자는 이것이 '스텁' 범주에 포함되어 있다고 본다
함수에 전달되는 특정 입력 값이나 동작을 모방하는데 이 값을 사용하므로 역시나 스텁이라 합 수 있다고 설명

### 3.3.2 의존성, 주입, 제어 
**읽어보기.** 표로 용어 설명하고 있으니 잘 읽기 

테스트하려는 코드에 동작이나 임의의 데이터를 변경하고 주입하기가 쉬울수록 코드가 변경되더라도 테스트를 작성하고 읽고 유지보수하는 것이 더 쉬워진다.


### 3.4 함수를 이용한 주입 방법
예제 3-3에서 currentDay를 매개변수로 주입하여 외부 의존성을 끊고 **함수 레벨**에서 의존성 문제를 해결했다

자.스는 **함수형 프로그래밍**과 **객체 지향 프로그래밍** 두 가지 스타일을 사용할 수 있다.
- <u>이 장에서는 두 스타일을 사용한 서로 다른 방식을 소개할 예정이다</u>
- 디자인에 정답은 없다
- 그러나 함수형 스타일은 배우기 어렵다는 단점이 있다.
- 그렇기 때문에 이 두 방식을 모두 배우고 상황에 가장 적합한 방식을 적용하는 것이 현명하다 

#### 3.4.1 함수 주입
예제 3-4. 함수를 의존성으로 전달하기
// 자바에서 함수형 인터페이스 선언해서 람다 함수로 전달하는게 생각나네

이전 테스트와 큰 차이는 없지만, 함수를 매개변수로 전달하는 것이 가능하다.
함수를 인수로 전달하는 방법은 특정 상황에서 예외를 만들어 내거나 테스트 내에서 특정한 동작을 하도록 만들 수 있어 유용하게 사용될 수 있다.

#### 3.4.2 부분 적용을 이용한 의존성 주입
팩토리 함수는 미리 정의된 컨텍스트를 가진 함수를 반환하는 함수로, 고차함수의 일종이다
다음 예제에서는 
- 팩토리 함수를 테스트의 준비 단계에서 사용 
- 반환된 함수를 실행 단계에서 호출 
- 준비 단계에서 rules, getDayen을 인수로 전달하면서 팩토리 함수가 반환하는 새로운 함수가 이들을 참조할 수 있도록 설정한다

예제 3-6. 고차 함수 사용하기
// 함수형 프로그래밍을 사용하여 테스트를 준비하고, 실행 단계에서 실행 할대까지 지연이 되는 구나
// **좋은 예제**이다


### 3.5 모듈을 이용한 주입 방법
- 자.스에서는 모듈을 가져오거나(require) 불어오는(import) 기능을 제공한다
- 외부 의존성은 제어할 수 없기 때문에 테스트를 어렵게 한다
- 즉, 의존성을 대체할 수 있는 **심**을 만들어야 한다

p291 예제 3-7. 필수 의존성 추상화하기 


```javascript
const {  
    inject,  
    verifyPassword,  
    SATURDAY  
} = require('./password-verifier-time00-modular');  
  
// stub, fake 함수를 생성하여 반환  
const injectDate = (newDay) => {  
    const reset = inject({  
        moment: function () {  
            return {  
                day: () => newDay  
            };  
        }  
    });  
  
    return reset; // 함수를 반환  
};  
  
  
describe('verifyPassword', () => {  
    describe('when its the weekend', () => {  
        it('throws an error', () => {  
            const reset = injectDate(SATURDAY);  
  
            expect(() => verifyPassword('any input'))  
                .toThrowError("It's the weekend!");  
  
            reset(); // 모듈 의존성을 원래 의존성으로 복구  
        });  
    });  
});

```

- injectDate() 함수는 테스트에서 반복되는 코드를 **보일러 플레이트 코드**라고 한다
	- 줄여서 **헬퍼 함수** 라고도 한다
	- moment().day() 함수가 () => newDay로 대체되도록 한다
- 제어할 수 없는 서드 파티 의존성을 코드에 직접 가져오지 말고, 항상 제어할 수 있는 중간 추상화를 사용해야 한다. 포트와 어댑터 아키텍처(헥사고날 아키텍처, 어니언 아키텍처라고도 한다)가 좋은 예시이다.

p299
>[!note] 역자의 노트. 포트와 어댑터 아키텍처에 대한 이해 (읽어보기)
>- 포트는 시스템의 내부와 외부를 연결하는 인터페이스를 의미한다.
>- 어댑터는 포트를 통해 들어오는 요청을 처리하는 구체적인 구현체다


이 아키텍처의 주요 장점은 다음과 같다.
- 유연성
- 테스트 용이성
- 유지 보수성

<u>p299 ~ 309까지 음악 플레이어를 예제로 가짜 의존성 주입하여 테스트 하는 방식을 설명한다</u>
- 인터페이스(객체)를 정의하고 상속한 구현체 2개와 가짜 구현체 1개
- 앞선 예제와 같이 보일러 플레이트 코드 구조로 만든 stub 함수로 테스트하는 예제 설명


### 3.6 생성자 함수를 사용하여 객체 지향적으로 전환

password-verifier-time02-modular.js
```javascript
const SUNDAY = 0;  
const SATURDAY = 0;  

// new 키워드와 함께 호출되면 생성자 함수라고 한다.
// this는 생성된 객체를 참조하여 초기화 작업을 수행한다
const Verifier = function(rules, dayOfWeekFn) {  
    this.verify = function(input) {  
        if([].includes(dayOfWeekFn())) {  
            throw new Error("It's the weekend!");  
        }  
  
        // do something  
    };  
};  
  
module.exports = {  
    SUNDAY,  
    SATURDAY,  
    Verifier  
}
```

password-verifier-time02-modular.spec.js
```javascript 
const {SUNDAY, Verifier} = require('./password-verifier-time02-modular');  
  
test('constructor function : on weekends, throws exception', () => {  
    const alwaysSunday = () => SUNDAY;  
    const verifier = new Verifier([], alwaysSunday);  // 생성자 함수
    expect(() => verifier.verify('anything'))  
        .toThrow("It's the weekend!");  
});
```


ES6 문법+ 클래스 문법으로 적용하면 아래와 같다 
```javascript 
class Verifier {
    constructor(rules, dayOfWeekFn) {
        this.rules = rules; // 필요하다면 rules를 저장
        this.dayOfWeekFn = dayOfWeekFn; // 필요하다면 저장
    }

    verify(input) {
        if ([].includes(this.dayOfWeekFn())) {
            throw new Error("It's the weekend!");
        }

        // do something
    }
}
```


chat-gpt 답변. 첫번째 예제가 함수형 프로그래밍이라 할 수 있나요?
- 첫 번째 방식은 **객체지향 프로그래밍(OOP)** 의 특징이 강하며, 함수형 프로그래밍이라 보기에는 어렵습니다.
- 함수형 프로그래밍에서는 상태 변경을 피하고, 순수 함수와 고차 함수를 적극 활용하며, 불변성을 유지하는 코드를 작성합니다.
- 만약 함수형 프로그래밍 스타일을 사용하려면, 객체 대신 함수를 반환하거나 상태를 명시적으로 전달받아 사용하는 방식을 선택하는 것이 더 적합합니다.


> 함수형 프로그래밍과 객체 지향 프로그래밍 스타일 중 선택
### 3.7 객체 지향적으로 의존성을 주입하는 방법

#### 3.7.1 생성자 주입 
- 클래스의 생성자를 이요하여 의존성을 주입하는 설계를 의미
- 앞서 했던 함수형 방식을 클래스 기반으로 바꾼다.
- 상태를 가지는(스테이트풀) 클래스는 한번만 설정하면 다음부터는 재사용할 수 있어 반복 작업을 줄일 수 잇다는 장점이 있다.

- 하지만 객체 지향적으로 만들수록 코드가 점점 더 장황해 지는 것을 볼 수 잇는데, 이것이 객체 지향 프로그래밍의 특징이다.
- 반면에 함수형 스타일의 코드는 더 간결한 경우가 많으며, 이러한 이유로 많은 사람이 함수형 스타일을 선택하기도 한다.

예제
- 생성자 주입 방식 
- 생성자를 헬퍼 함수, 팩토리 함수로 분리하기


#### 3.7.2 함수 대신 객체 주입
- 매개변수 dayOfWeekFn을 함수 대신 객체로 사용해보자
#### 3.7.3 공통 인터페이스 추출
