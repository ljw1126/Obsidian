참고. 
- [mac에 닷넷 설치 - 공식 문서](https://learn.microsoft.com/ko-kr/dotnet/core/install/macos)
- [배열과 컬렉션 - 공식 문서](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/builtin-types/collections)
- [C# 지식 창고 MSDN](https://learn.microsoft.com/en-us/dotnet/csharp/)
	- pdf 문서도 지원한다는데
	- [닷넷 콘솔 API 문서](https://learn.microsoft.com/ko-kr/dotnet/api/system.console?view=net-9.0)



헷갈리는 점
- 변수 타입이 부호가 있는 경우와 없는 경우가 나뉨
- 접근 제어자도 상대적으로 더 세밀함 
- 객체 소멸자 메서드를 직접 선언하는게 특이 `~클래스명()`
- 상속과 인터페이스 표기가 `:`로 동일하게 사용
- `namespace`가 자바에서는 `package`에 해당하는 걸로 보임 
	- 폴더로 안 나누고 직접 내부에서 감싸는 이유는 모르겠음

>[!note] 멤버 변수 접근 제어자에 따라 케이스가 달라짐 
>- public 멤버는 파스칼 케이스 (Name)
>- private 멤버는 lower 카멜 케이스 (name)
>  일부 개발자는 내부 private 필드임을 강조하기 위해 _ 붙이기도 함



## 섹션1. C# 알아보기

`C#`
- MS에서 개발한 **닷넷(.NET) 프레임워크** 기반 범용 목적의 **다중 패러다임** 프로그래밍 언어

`닷넷 프레임워크 (.NET Framework)`
- 웹 앱, 모바일 앱, 데스크톱 프로그램, 게임 프로그램, 사물인터넷(IoT) 프로그램 등을 만들기 위한 오픈소스, 크로스 플랫폼 개발 환경
- https://dotnet.microsoft.com/ko-kr/learn/dotnet/what-is-dotnet-framework
- .NET Framework 통해 C#(고급 언어)를 기계어(저급 언어)로 변경
- C# 언어로 개발하는 건 같지만 어떤 플랫폼에 개발하냐에 따라 프레임워크가 달라진다 함
	- .NET Framework
	- .NET Core
	- Xamarin

> 자바로 치면 JVM에 해당하는 듯

📚 범용 프로그래밍 언어 
- 다양한 도메인의 SW를 개발하기 위해 설계된 프로그래밍 언어
- https://en.wikipedia.org/wiki/General-purpose_programming_language

📚 다중 패러다임 언어 
-  명령형 (Imperative)
	- 절차적 프로그래밍 언어
	- 객체 지향 프로그래밍 언어
- 선언형(Declarative)
	- 함수형 프로그래밍 언어 
	- 논리형 프로그래밍 언어 
	- 데이터 흐름형 프로그래밍 언어 

---

절차적 프로그래밍 언어
- `샌드위치 코딩` , 유튜브 검색 

객체지향 프로그래밍 언어
- 모든 사물을 객체로 표현 
- 객체의 속성과 메소드의 호출로 프로그램 작성
- 대표적인 언어로 C++, C#, Java

---

C#으로 만들 수 있는 것 
- 윈도우 프로그램
- 유니트로 만든 콘텐츠
	- 2차원, 3차원, 증강현실, 가상현실, 시뮬레이션 등
	- 유니티 엔진을 통해 제작된 콘텐츠
- 웹 어플리케이션 
	- 인터넷을 통해 웹 브라우저에서 이용할 수 있는 응용 SW
- 사물인터넷 연동 장치
	- C#에서 제공하는 네트워크 기능을 활용해 외부 장치로부터 데이터 수집 및 분석, 그래프 등으로 가시화할 수 있는 프로그램 제작

> C#은 범용 프로그래밍 언어다

---

## 섹션2.



```shell
❯ dotnet -version

.NET 9.0을(를) 시작합니다.
---------------------
SDK 버전: 9.0.304

원격 분석
---------
.NET 도구는 사용자 환경 개선을 위해 사용량 현황 데이터를 수집합니다. Microsoft에서 데이터를 수집하여 커뮤니티와 공유합니다. 원하는 셸을 사용하여 DOTNET_CLI_TELEMETRY_OPTOUT 환경 변수를 '1' 또는 'true'로 설정하여 원격 분석을 옵트아웃할 수 있습니다.

.NET CLI 도구 원격 분석에 대한 자세한 내용은 https://aka.ms/dotnet-cli-telemetry를 참조하세요.

----------------
ASP.NET Core HTTPS 개발 인증서를 설치했습니다.
인증서를 신뢰하려면 'dotnet dev-certs https --trust'를 실행하세요.
HTTPS에 관한 자세한 정보: https://aka.ms/dotnet-https

----------------
첫 번째 앱 작성: https://aka.ms/dotnet-hello-world
새로운 기능 확인: https://aka.ms/dotnet-whats-new
설명서 살펴보기: https://aka.ms/dotnet-docs
GitHub에서 문제 보고 및 소스 찾기: https://github.com/dotnet/core
사용 가능한 명령을 보려면 'dotnet --help'를 사용하거나 https://aka.ms/dotnet-cli를 방문하세요.
--------------------------------------------------------------------------------------
워크로드를 확인하는 동안 문제가 발생했습니다. 자세한 내용을 확인하려면 "dotnet workload update"를 실행하세요.
지정한 명령 또는 파일을 찾을 수 없어 실행하지 못했습니다.
이에 대한 예상 원인은 다음과 같습니다.
  * 기본 제공 dotnet 명령의 철자가 잘못되었습니다.
  * .NET 프로그램을 실행하려고 했지만 dotnet--version이(가) 없습니다.
  * 전역 도구를 실행하려고 했지만 PATH에서 이 이름의 dotnet 접두사 실행 파일을 찾지 못했습니다.
```

콘솔 앱이 실행되지 않을때 (mac)
- .NET sdk 설치 후
- https://stackoverflow.com/questions/53030531/dotnet-command-not-found-in-mac
- https://dotnet.microsoft.com/ko-kr/learn/dotnet/hello-world-tutorial/next
```shell
sudo ln -s /usr/local/share/dotnet/dotnet /usr/local/bin/
```

솔루션 (멀티 모듈 구성을 의미 하는듯함?)


웹 통합개발환경(IDE)으로 C# 코드 작성하기 
- 통합 개발 환경  = 코딩 + 디버깅 + 컴파일 
- 웹 IDE 
	-  https://dotnetfiddle.net/
	- https://www.codingrooms.com/
	- (✅ 권장) https://replit.com/

> 강의가 옛날이라서 웹 UI가 조금 다르다


---
## 섹션3. C# 기본기 쌓기 

`변수`
- 값을 저장하는 곳
- [공식 문서](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/builtin-types/built-in-types)

```c#
int variable; // 변수의 선언
int variable = 10; // 변수의 초기화
```

`조건식` 
- 프로그램의 흐름 
```text
A == B
A != B
A > B
A >= B
A < B
A <= B
```

```text
if(조건식)
	// 조건식이 참인 경우 실행되는 한줄 
else if()
	// 두번째 조건식이 참인 경우 실행되는 한줄
else
	// 조건식이 거짓인 경우 실행되는 한줄

	
if(조건식){
	// 조건식이 참인 경우 
	// 실행되는 두 줄 이상의 코드
} else if(조건식) {
	//
} else {
	//
}
```


> 웹 IDE로 실행시 namespace 선언 없이 class를 바로 선언해서 확인하네?


`반복문`
- 비슷한 작업을 반복적으로 수행해야 할 때 사용하는 문법
- `for`, `while` 둘 다 Java와 사용 방법 동일

```text
for(초기화; 조건식; 반복식)
	// 반복 실행될 코드 (한줄)
	
for(초기화; 조건식; 반복식) {
	// 반복 실행될 코드
}	
```

```text
while(조건식)
	// 반복 실행될 코드 
	
while(조건식) {
	// 반복 실행될 코드
}	
```


`데이터를 연산자로 요리하기 `
- 산술 연산자
	- `+`, `-`, `*`, `/`, `% (mod)`
- 증가/감소 연산자
	- `++`, `--`
	- 사용되는 위치에 따라 달라짐 
	- 앞에 달 경우 먼저 값을 처리 후 할당
- 관계 연산자 
	- `>`, `<`, `>=`, `<=`, `==`, `!=`
- 논리 연산자
	- `&&`, `||`, `! (not)`
- [공식 문서](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/operators/)

```C#
using System;

class MainClass {
	public static void Main(string[] args) {
		int num = 0;
		Console.writeLine(num++); // 0
		Console.writeLine(num); // 1
		Console.writeLine(--num); // 0
		Console.writeLine(num); // 0
	}
}
```


`데이터를 옮겨 담기(형변환)`
- 데이터의 형식을 변경해 데이터를 담는 과정 
- `s*` : signed, 음수 ~ 양수
- `u*` : unsigned, 부호가 없어서 정수만 표현
- **형 변환(Type Conversion)시** 
	- 오버 플로우(Overflow), 언더플로우(Underflow) 발생 가능

```c#
using System;

class MainClass {
	public static void Main(string[] args) {
		sbyte num = 128; // -128 ~ 127
		Console.writeLine(num);
		
		sbyte v1 = 64;
		sbyte v2 = 64;
		sbyte v3 = v1 + v2; // overflow
		Console.writeLine(v3);
	}
}

```
- 콘솔에 에러 표기가 친철하지 않다
- 암시적 형변환이 되는데 좌변에 알맞게 형 선언을 해줘야 한다

---

## 섹션4. 클래스 알아보기 

클래스와 인스턴스 차이 

```C#
using System;

class MainClas {

	public static void Main(string[] args) {
		// 코드 
	}
	
}
```
- 클래스 네이밍은 Upper Camel Case 사용
- 속성(Property), 행위(Method)

```C#
using System;

class Person {
	public string Name; // 파스칼 케이스 사용
	public string Birthday;
	public string Gender;
	
	public void Eat() {
		Console.WriteLine(..);
	}
}

class Program {
	public static void Main (string[] args) {
		Person p1 = new Person();
		p1.Name = '테스터';
		p1.Eat();
	}
}
```
- 속성과 메서드 네이밍이 왜 다 Upper이지??
	- `파스칼 케이스 (PascalCase)`를 보통 사용한다 함
		- 각 단어의 첫 글자를 대문자로 표기하며, 단어 사이에 공백이 없습니다.

**사용 대상**:
- **클래스**: `class Person`
- **메서드**: `public void CalculateTotal()`
- **속성 (Property)**: `public string FirstName { get; set; }`
- **네임스페이스**: `namespace MyCompany.MyProject`
- **열거형 (Enum)**: `enum Color { Red, Green, Blue }`

`네임스페이스?`
C#의 네임스페이스는 자바의 패키지(package)와 개념적으로 가장 유사합니다. 네임스페이스와 자바의 패키지 모두 클래스들을 논리적으로 묶어 이름 충돌을 방지하고 코드를 체계적으로 관리하는 역할을 합니다.
```c#
// 네임스페이스 예시
namespace Outer.Inner
{
    public class MyClass
    {
        // ...
    }
}

// 중첩 클래스 예시
public class OuterClass
{
    // OuterClass의 private 멤버에 접근 가능
    private int _outerValue = 10;
    
    public class NestedClass
    {
        // ...
    }
    
    public class AnotherNestedClass
    {
        public void DoSomething()
        {
            // OuterClass의 private 멤버에 접근 가능
            OuterClass outer = new OuterClass();
            int value = outer._outerValue;
        }
    }
}
```


### 클래스의 시작과 종료 
- 생성자(Constructor)와 소멸자 (Destructor)
	- 생성자는 자바와 동일 
	- 소멸자는 `~`를 추가


```c#
using System;

class Cat {
	public string Name;
	public int Weight;

	public Cat(string name) {
		Name = name;
		Console.WriteLine("생성자 호출");
		Console.WriteLine("고양이의 이름은 " + Name + " 입니다");
	}
	
	// 오버로딩(Overloading)
	public Cat(string name, int weight) {
		Name = name;
		Weight = weight;
	}
	
	// 소멸자
	// .NET 프레임워크에서 객체가 소멸할때 호출됨
	~Cat() {
		Console.WriteLine(Name + "이(가) 사라집니다.")
	}
}

class Program {
	public static void Main (string[] args) {
		Cat myCat = new Cat("톰");
	}
}

```

C#의 소멸자는 클래스 인스턴스가 **가비지 컬렉터에 의해 메모리에서 해제될 때 호출되는 특별한 메서드**입니다. 소멸자는 다음과 같은 특징을 가집니다.
- 클래스 이름 앞에 물결표(`~`)를 붙여서 정의합니다.
- 매개변수를 가질 수 없고, 접근 지정자(public, private)를 사용할 수 없습니다.
- 소멸자는 개발자가 직접 호출할 수 없으며, **GC가 호출 시점을 결정**합니다.

`소멸자가 필요한 이유`
C#의 가비지 컬렉터는 관리되는 메모리(Managed Memory)를 자동으로 처리하지만, 비관리 리소스(Unmanaged Resources)는 자동으로 해제하지 못합니다. 비관리 리소스는 파일 핸들, 데이터베이스 연결, 네트워크 소켓, OS 리소스 등을 포함합니다. 소멸자는 이러한 비관리 리소스를 명시적으로 해제할 때 주로 사용됩니다.

> [!info] C# 소멸자의 한계와 `IDisposable` 패턴 (생략)


### 클래스를 상속으로 재활용하기 


```c#
using System;

class Robot {
	public void Move() {
		Console.WriteLine("로봇이 움직입니다");
	}
}

class CleanRobot : Robot {
	public void Clean() {
		Console.WriteLine("청소를 시작합니다");
	}
	
	// 오버라이딩
	public void Move() {
		Console.WriteLine("청소 로봇이 움직입니다");
	}
}

class RescueRobot : Robot {
	// 오버라이딩
	public void Move() {
		Console.WriteLine("구조 로봇이 움직입니다");
	}
}

class MainClass {
	public static void Main (string[] args) {
		CleanRobot cleanRobot = new CleanRobot();
		cleanRobot.Move();
		cleanRobot.Clean();
		
		
		RescueRobot rescueRobot = new RescueRobot();
		rescueRobot.Move();
	}
}
```
- 인터페이스나 상속이나 둘다 `:` 을 붙여서 표기
	- 자바와 마찬가지로 **단일 상속**, **다중 구현** 가능


### 클래스의 데이터 전달 
- 함수(ex. 메서드, 생성자)의 `메게변수`로 전달 
- 인스턴스에서 `멤버 변수` 접근해서 가져오기

`private, this 키워드`
```c#
using System;

class Cat {
	private string name;
	
	public void SetName(string name) {
		this.name = name;
	}
	
	public string GetName() {
		return this.name;
	}
}

class MainClass {
	public static void Main(string[] args) {
		Cat tom = new Cat();
		tom.SetName("톰");
		Console.WriteLine("고양이의 이름은 " + tom.GetName()+ "입니다");
	}
}

```
- getter, setter도 `파스칼 케이스`를 사용

>[!note] 멤버 변수 접근 제어자에 따라 케이스가 달라짐 
>- public 멤버는 파스칼 케이스 (Name)
>- private 멤버는 lower 카멜 케이스 (name)

---

## 섹션5. C# 실력 쌓기
[컬렉션 - 공식 문서](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/builtin-types/collections)
[C# 지식 창고 MSDN](https://learn.microsoft.com/en-us/dotnet/csharp/)

### 데이터 저장을 위한 클래스 활용 - 배열 (Array)

> ✅ 배열의 선언 방식
> 데이터형[] 변수명;
- 같은 타입의 데이터를 저장할 수 있는 자료구조

```c#
using System;

class MainClass {

	public static void Main(string[] args) {
		// 배열을 초기화하는 첫 번째 방법 
		int[] arr = new int[3];
		arr[0] = 10;
		arr[1] = 20;
		arr[2] = 30;
		
		// 배열 초기화 방법2
		int[] arr2 = new int[] {1, 2, 3};
		
		// 배열 초기화 방법3
		int[] arr3 = {4, 5, 6};
		
		Console.WriteLine(arr); // System.Int32[] 출력됨
		Console.WriteLine(arr2);
		Console.WriteLine(arr3);
		
		
		Console.WriteLine(arr.length);
		
		foreach(int i in arr) {
			Console.WriteLine(i);
		}
	}
}

```
- `Arrays.toString(..)` 같은 메서드는 없는가??
	- 콘솔 출력하니 클래스가 출력되네
- foreach는 표기법이 살짝 다름

### 데이터 저장을 위한 클래스 활용 - 컬렉션

`컬렉션`
- 여러 데이터 형을 포함해 입력과 출력, 데이터를 처리를 수행할 수 있는 자료구조
	- ArrayList
	- Queue
	- Stack
	- Hashtable

`ArrayList`
```c#
using System;
using System.Collections; // namespace (패키지랑 비슷)

class MainClass {
	public static void Main(string[] args) {
		ArrayList al = new ArrayList();
		
		al.Add(1);
		al.Add("Hello");
		al.Add(3.3);
		al.Add(true);
		
		// 타입을 모르니 var 선언
		foreach(var item in al) {
			Console.WriteLine(item);
		}
		Console.WriteLine();
		
		// 삭제
		al.Remove("Hello");
		
		// 타입을 모르니 var 선언
		foreach(var item in al) {
			Console.WriteLine(item);
		}
	}

}


```


`Queue`
```c#
using System;
using System.Collections; // namespace (패키지랑 비슷)

class MainClass {
	public static void Main(string[] args) {
		Queue que = new Queue();
		
		que.Enqueue(1);
		que.Enqueue(2);
		que.Enqueue(3);
		
		// Count 멤버변수에 접근해서 괄호가 없음
		while(que.Count > 0) {
			Console.WriteLine(que.Dequeue());
		}
	}

}

```

`Stack`

```c#
using System;
using System.Collections; // namespace (패키지랑 비슷)

class MainClass {
	public static void Main(string[] args) {
		Stack stack = new Stack();
		
		stack.Push(1);
		stack.Push(2);
		stack.Push(3);
		
		// Count 멤버변수에 접근해서 괄호가 없음
		while(stack.Count > 0) {
			Console.WriteLine(st.Pop());
		}
	}

}

```


`Hashtable`
```c#
using System;
using System.Collections; // namespace (패키지랑 비슷)

class MainClass {
	public static void Main(string[] args) {
		Hashtable ht = new Hashtable();
		
		ht["apple"] = "사과";
		ht["banana"] = "바나나";
		ht["oragne"] = "오랜지";
		
		Console.WriteLine(ht["apple"]);
		Console.WriteLine(ht["banana"]);
		Console.WriteLine(ht["orange"]);
	}

}
```


### 예외 처리하기

```c#
using System;
using System.Collections;

public class MainClass {
	public static void Main() {
		Console.Write("나눌 숫자를 입력하세요");
		int num = int.Parse(Console.ReadLine());
		try {
			Console.WriteLine(10 / num);
		} catch(Exception e) {
			Console.WriteLine("예외 : " + e.Message);
		}
		
	}
}

```


🤖 chat-gpt
C#에는 자바처럼 컴파일러가 강제하는 **체크 예외(Checked Exception)** 개념이 없습니다. C#의 모든 예외는 자바의 **언체크 예외(Unchecked Exception)**처럼 동작합니다.

---

`C#의 예외 처리`
C#의 예외는 모두 `Exception` 클래스를 상속받습니다. 이 예외들은 메서드 시그니처에 명시적으로 선언할 필요가 없으며, 컴파일러가 예외를 처리하라고 강제하지 않습니다. 개발자가 필요에 따라 `try-catch` 블록으로 예외를 처리하거나, 예외를 던지는 것을 선택할 수 있습니다.

`특정 예외를 잡는 방법`
자바와 마찬가지로, C#에서도 `try-catch` 블록을 사용하여 **특정 예외를 지정해 잡을 수 있습니다**.
```c#
using System;

public class Program
{
    public static void Main(string[] args)
    {
        try
        {
            // NullReferenceException을 발생시킬 수 있는 코드
            string myString = null;
            Console.WriteLine(myString.Length); 
        }
        catch (NullReferenceException ex)
        {
            // 특정 예외(NullReferenceException)만 처리
            Console.WriteLine($"예외가 발생했습니다: {ex.Message}");
        }
        catch (Exception ex)
        {
            // 모든 다른 예외를 처리 (범용적인 catch)
            Console.WriteLine($"예상치 못한 예외가 발생했습니다: {ex.Message}");
        }
    }
}
```


> 토비님께서는 복구 가능한 예외라면 try-catch로 잡고, 복구 불가능하면 잡지 말고 밖으로 던지라고 했었던거 같다 (`복구 가능 유무`)