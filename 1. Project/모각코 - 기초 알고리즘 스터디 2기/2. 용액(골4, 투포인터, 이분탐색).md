https://www.acmicpc.net/problem/2467

> 투포인터로 풀었는데 이분탐색으로는 시간 걸림

**이진탐색 (1시간내 풀이 x)**
- 시간복잡도 : `O(n log n)`
- 각 i 번째 용액과 가장 가까운 수를 i + 1 ~ n - 1 범위 내에서 찾는다
- `lowerbound(arr, x`)의 경우 정렬된 `arr`에서 `x` 이상인 첫 인덱스 반환
    - 하지만 x 이상이 되는 첫 번째 값이 항상 최적의 해임이 보장되지 않는다
        - 아래 예시에서 7 이상이 되는 첫번째 용액은 9이지만, 6이 더 차이가 적다
    - 고로 이진탐색으로 구한 현재 포인터의 용액과 그 이전의 용액을 둘 다 비교할 필요가 있다
- 최소값을 초기화해주는게 지저분해보인다..

```java
5
-7 -2 4 6 9

답 -7 6
```


```java
import java.util.*;
import java.io.*;

public class Main {
   private static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws IOException {
        input();
        pro();
        output();
    }

    private static int n;
    private static int[] liquid;

    private static void input() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        n = Integer.parseInt(br.readLine());

        liquid = new int[n]; // 정렬된 상태
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0; i < n; i++) {
            liquid[i] = Integer.parseInt(st.nextToken());
        }
    }

    private static void pro() {
        int min = Integer.MAX_VALUE;
        int a = -1;
        int b = -1;

        for(int i = 0; i < n - 1; i++) {
            int left = liquid[i];
            int right = binarySearch(-liquid[i], i + 1, n - 1);
            int sum = Math.abs(left + right);

            if(sum <= min) {
                min = sum;
                a = left;
                b = right;
            }
        }

        sb.append(a).append(" ").append(b);
    }

		// lowerbound는 target이상이 되는 첫번째 값을 찾게 된다 
		// 하지만 target 이상의 최적의 해임이 보장되지 않는 문제이다 
		// 예로 target = 7일때 target이상이 되는 수는 9이지만, 가장 가까운 수는 6이다
		// 고로 lowerbound로 구하려면 (idx)와 (idx-1) 비교해야 함
    private static int binarySearch(int target, int from, int end) {
        int L = from;
        int R = end;
        int idx = -1;
        int minDiff = Integer.MAX_VALUE;

        while(L <= R) {
            int mid = (L + R) / 2;
            int diff = Math.abs(liquid[mid] - target);

            if(diff < minDiff) {
                minDiff = diff;
                idx = mid;
            }

            if(liquid[mid] < target) {
                L = mid + 1;
            } else {
                R = mid - 1;
            }
        }

        return liquid[idx];
    }

    private static void output() throws IOException {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
}
```