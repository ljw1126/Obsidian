https://school.programmers.co.kr/learn/courses/30/lessons/42897

- 직접 풀이 못함
- dp 배열을 두 개 따로 선언하는 것도 인상적임 .. 어떻게 든 푼다인듯 

- 최대치 `int`
- 2차원 dp 배열로 풀이시 시간초과 발생
    - 테스트 케이스 1
    - 효율성 2개
- 절차
    - 0번 집을 선택하는 경우와 선택하지 않는 경우를 나눠서 dp 배열을 채워나간다
        - dpX : 0번집을 선택하지 않는 경우
        - dpO : 0번집을 선택하는 경우
    - 이때 0번 집을 선택하지 않는 경우 마지막 인덱스에 최대치가 존재
        - 반면, 0번집을 선택하는 경우 length - 2번 인덱스에 최대치가 존재
            - 왜냐하면 마지막 집을 선택하게 되는 경우 0번 집과 연결되어서 방범이 울리게 된다

```java
10 5	3	1	10
답: 15

# 0번 집을 선택하지 않는 경우 (두번째 집까지 초기화)
10 5 3 1 10
------------
0  5 5 6 15   
	 o		 o
	 
# 0번 집을 선택하는 경우 (두번째 집까지 초기화)
10 5 3 1 10
------------
10 10 13 13 23
o			o		 
- 마지막 집을 선택하게 되면 0번집과 연결되어 방범이 울린다
```

📌 `int[][] dp` 이차원 배열을 사용할 때 시간초과가 발생하는 이유 (Chat-GPT🤖)

- 공간복잡도는 최대치로 연산해도 `8Mb`

```
# 1. 캐시(Locality) 문제
2차원 배열 dp[n][2] 형태는 메모리 접근 패턴이 더 분산됩니다.
JVM의 메모리 레이아웃에서 int[][] 는 사실 “배열의 배열”이라서, 연속된 블록이 아니라 참조(포인터) 배열 + 각 행 배열로 구성됩니다.
따라서 dp[i][0], dp[i][1]을 접근할 때마다 여러 객체로 점프해야 해서 CPU 캐시 효율이 크게 떨어집니다.
반대로 int[] dpX, int[] dpO는 각각 단일 메모리 블록이라 캐시 히트율이 높습니다 → 실행 속도가 눈에 띄게 개선됩니다.

# 2. 자바의 오브젝트 오버헤드
int[][] 는 내부적으로 int[] 객체가 n개 있는 구조라서, 단순한 int[n][2]도 n + 1개의 객체가 생성됩니다.
각 배열 객체는 헤더(12~16 byte) + align padding 오버헤드를 갖습니다.
즉, 10^6 집이라면 객체만 1,000,001개가 생깁니다 → GC 부담 + 힙 메모리 관리 오버헤드 때문에 성능이 확 떨어집니다.

# 3. 메모리 대역폭과 GC
2차원 배열로 8MB만 쓴다고 계산하셨는데, 실제 JVM에서는 오브젝트 헤더 때문에 훨씬 커집니다 (100MB 이상으로 불어날 수 있음).
대규모 객체가 많아지면 GC 동작이 잦아지고, 그 과정에서 시간초과로 이어질 수 있습니다.

# 4. 정리
int[n][2] → 실제론 n+1개의 배열 객체, 캐시 미스 많음, GC 부담 큼.
int[n] 두 개 → 단일 배열이라 메모리 연속, 캐시 효율 높음, 오버헤드 없음.
이론적 복잡도는 같아도 실제 실행 속도에서 큰 차이가 발생하는 게 이유입니다.

👉 그래서 DP 문제에서 Java로 2차원 배열 대신 1차원 배열 두 개나 rolling array (길이 2짜리 배열만 번갈아 쓰기) 방식을 많이 씁니다.
```



```java
class Solution {
    public int solution(int[] money) {
        int length = money.length;
        
        //dpX : 첫번째 집을 선택하지 않는 경우 
        //dpO : 첫번째 집을 선택하는 경우
        int[] dpX = new int[length];
        int[] dpO = new int[length];
        
        dpX[0] = 0;
        dpX[1] = money[1];
        
        dpO[0] = money[0];
        dpO[1] = money[0];
        
        for(int i = 2; i < length; i++) {
            dpX[i] = Math.max(dpX[i - 1], dpX[i - 2] + money[i]);
            dpO[i] = Math.max(dpO[i - 1], dpO[i - 2] + money[i]);
        }
        
        // dpX[length - 1] : 첫번째 집을 선택하지 않는 경우 마지막 집에 최대치가 존재 
        // dpO[length - 2] : 첫번째 집을 선택하는 경우 (마지막 집 - 1)에 최대치가 존재
        return Math.max(dpX[length - 1], dpO[length - 2]);
    }
}
```