https://www.acmicpc.net/problem/1012

- BFS(너비우선탐색) 풀이
- `(1,1)` → `(n,m)` 최단 거리를 구하는 문제
- 상하좌우로 이동가능한 격자형 그래프 문제
    - N, M(2 ≤ N, M ≤ 100)
        - 최대 100 * 100 격자형 그래프
        - 노드: 최대 10,000개
        - 간선: 각 노드 당 4개씩
    - 시간 복잡도 : O(4NM) ⇒ `O(NM)`

```java
import java.util.*;
import java.io.*;

public class Main {
    
    private static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws IOException {
        input();
        pro();
        output();
    }

    private static int n, m;
    private static int[][] matrix;

    private static void input() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        matrix = new int[n + 1][m + 1];
        for(int i = 1; i <= n; i++){
            String line = br.readLine();
            for(int j = 1; j <= m; j++) {
                matrix[i][j] = line.charAt(j - 1) - '0';
            }
        }
    }

    private static void pro() {
        int[][] dist = new int[n + 1][m + 1];
        for(int i = 1; i <= n; i++){
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }

        int[][] dir = {
                {0, 1},
                {1, 0},
                {0, -1},
                {-1, 0}
        };

        Deque<Integer> que = new ArrayDeque<>(); // Multisource BFS
        que.add(1);
        que.add(1);
        
        dist[1][1] = 1;

        while(!que.isEmpty()){
            int x = que.poll();
            int y = que.poll();

            if(x == n && y == m) {
                continue;
            }

            for(int i = 0; i < 4; i++) {
                int dx =  x + dir[i][0];
                int dy =  y + dir[i][1];

                if(dx < 1 || dy < 1 || dx > n || dy > m) continue;
                if(matrix[dx][dy] == 0) continue;
                if(dist[dx][dy] != Integer.MAX_VALUE) continue;

                dist[dx][dy] = dist[x][y] + 1;
                que.add(dx);
                que.add(dy);
            }
        }

        sb.append(dist[n][m]);
    }

    private static void output() throws IOException {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
}
```