https://www.acmicpc.net/problem/1966

- 시간복잡도는 정렬이 가장 많이 차지 O(N log N)
- m 번 숫자가 몇번째에 출력되는지 구하면 되는 문제
    - 중요도는 `1 ~ 9`
    - 중요도를 따로 저장할 컬렉션을 선언 후 역정렬 (`내림차순`)하여 사용

```
// 예제 입력1 중 두번째 케이스
4 2
1 2 3 4
A B C D

2는 C에 해당함 
1) D A B C -- D 출력
2) C A B -- C 출력 (종료)

// 예제 입력1 중 세번째 케이스
6 0 
1 1 9 1 1 1
A B C D E F

0은 A에 해당함
1) C D E F A B -- C 출력
2) D E F A B -- D 출력 
3) E F A B -- E 출력 
4) F A B -- F 출력
5) A B -- A 출력 (종료)
```

```java
import java.util.*;
import java.io.*;

public class Main {
    
    private static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws IOException {
        input();
        output();
    }

    private static int n, m;
    private static Deque<Node> que;
    private static List<Integer> priority;

    private static void input() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int t =  Integer.parseInt(br.readLine());
        while(t > 0) {
            t -= 1;
            StringTokenizer st = new StringTokenizer(br.readLine());

            n = Integer.parseInt(st.nextToken()); // 문서의 개수
            m = Integer.parseInt(st.nextToken()); // 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는

            priority = new ArrayList<>();
            que = new ArrayDeque<>();
            st = new StringTokenizer(br.readLine());
            for(int i = 0; i < n; i++) {
                int w = Integer.parseInt(st.nextToken());

                Node node = new Node(i, w);
                que.add(node);
                priority.add(w);
            }

            pro();
        }

    }

    private static class Node {
        private int idx;
        private int weight;

        public Node(int idx, int weight) {
            this.idx = idx;
            this.weight = weight;
        }

        public boolean isGreaterThanOrEqual(int o) {
            return weight >= o;
        }
        
        public boolean isTarget(int o) {
		        return idx == o;
        }
    }

    private static void pro() {
        Collections.sort(priority, Collections.reverseOrder()); // 내림차순 정렬

        int idx = 0;
        while(!que.isEmpty()) {
            Node cur = que.poll();

            if(cur.isGreaterThanOrEqual(priority.get(idx))) {
                idx += 1;

                if(cur.isTarget(m)) break;

                continue;
            }

            que.add(cur);
        }

        sb.append(idx).append("\n");
    }

    private static void output() throws IOException {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
}
```