https://www.acmicpc.net/problem/1931

- 첫번째 풀이
    - 회의 시작 시간 asc, 종료 시간 asc 기준으로 정렬한 후 이중 for문으로 풀이
    - 시간 복잡도 : `O(N^2)` ⇒ 시간초과💩
- 두번째 풀이
    - 시간 복잡도 : `O(NlogN)`
        - 정렬이 가장 많은 시간을 차지함
        - 최대 개수 구하는 연산은 O(N)
    - 핵심 아이디어: **끝나는 시간이 빠를수록 다음 회의를 더 일찍 배치할 수 있음.**
        - 정렬 기준이 point 📌  ⇒ **회의 종료 시간 asc, 회의 시작 시간 asc**
    - 정렬 후 첫번째 회의실을 기준으로 해서 갱신
        - `이전 회의 종료시간 ≤ 다음 회의 시작 시간`
        - 겹치지 않게 의미? 회의가 겹친다는 것은 `[1, 4]`와 `[3, 5]`처럼 시간대가 겹치는 경우 뜻함
            - (끝나는 시간 == 시작 시간) 경우를 허용
            - **겹치지 않고 선택할 수 있는 회의의 최대 개수를 구하는 문제**

반례1

```
3
0 1
3 8
0 0

// 답: 3

// 정렬 후
0 0
0 1
3 8
```

반례2

```
5
3 10
3 8
8 10
2 3
0 9

// 답 : 3

// 정렬 후
2 3
3 8
0 9
3 10
8 10

```

```java
import java.util.*;
import java.io.*;

public class Main {
   private static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws IOException {
        input();
        pro();
        output();
    }

    private static int n;
    private static List<Meeting> room;

    private static void input() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        n = Integer.parseInt(br.readLine());

        room = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            room.add(new Meeting(start, end));
        }
    }

    private static class Meeting implements Comparable<Meeting> {
        private int start;
        private int end;

        public Meeting(int start, int end) {
            this.start = start;
            this.end = end;
        }
				
				// 끝나는 시간이 빠를수록 다음 회의를 더 일찍 배치할 수 있다
        public int compareTo(Meeting o) {
            if(this.end != o.end) {
                return this.end - o.end;
            }

            return this.start - o.start;
        }
    }

    private static void pro() {
        Collections.sort(room);

        int result = 1;
        int cur = 0;
        for(int i = 1; i < n; i++) {
            Meeting prev = room.get(cur);
            Meeting next = room.get(i);
            if(prev.end <= next.start) { // 회의 시간이 겹치지 않는다 = (시간 ~ 종료) 사이에 끼치 않음을 뜻함
                cur = i;
                result += 1;
            }
        }

        sb.append(result);
    }

    private static void output() throws IOException {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
}
```