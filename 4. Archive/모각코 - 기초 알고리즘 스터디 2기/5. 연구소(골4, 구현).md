https://www.acmicpc.net/problem/14502

- 구현 = 백트래킹(조합) + BFS
- 중복 제외하고 벽을 3개 세우는 경우의 수 (조합)
    - `64C3` (최대 8 * 8 크기 일때)
- 바이러스 전파와 안전한 칸을 구하기 위해 각 최대 n^2 연산 수행 (n^2 보다는 적음)

```java
import java.util.*;
import java.io.*;

public class Main {
    private static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws IOException {
        input();
        pro();
        output();
    }

    private static final int[][] dir = {
            {0, 1},
            {1, 0},
            {0, -1},
            {-1, 0}
    };

    private static int n, m, result;
    private static int[][] fields;
    private static List<int[]> blanks, virous;

    private static void input() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken()); // 세로
        m = Integer.parseInt(st.nextToken()); // 가로

        blanks = new ArrayList<>();
        virous = new ArrayList<>();

        fields = new int[n][m];

        for(int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            for(int j = 0; j < m; j++) {
                int v = Integer.parseInt(st.nextToken());
                fields[i][j] = v;

                if(v == 2) {
                    virous.add(new int[] {i, j});
                } else if(v == 0) {
                    blanks.add(new int[] {i, j});
                }
            }
        }
    }

    private static void pro() {
        buildWall(0, 0);

        sb.append(result);
    }

    private static void buildWall(int count, int idx) {
        if(count == 3) {
            result = Math.max(result, safetyCount());
            return;
        }
        if(idx >= blanks.size()) return;

        // idx번 벽을 세운다
        int[] blank = blanks.get(idx);
        fields[blank[0]][blank[1]] = 1;
        buildWall(count + 1, idx + 1);
        fields[blank[0]][blank[1]] = 0;

        // idx번 벽을 세우지 않는다
        buildWall(count, idx + 1);
    }

    private static int safetyCount() {
        Deque<int[]> que = new ArrayDeque<>(); // multisource bfs 풀이가 공간복잡도 덜 나옴

        boolean[][] visited = new boolean[n][m]; // 바이러스 방문 기록
        for(int[] v : virous) {
            que.add(v);
            visited[v[0]][v[1]] = true;
        }

        while(!que.isEmpty()) {
            int[] cur = que.poll();
            int x = cur[0];
            int y = cur[1];

            for(int i = 0; i < 4; i++) {
                int dx = x + dir[i][0];
                int dy = y + dir[i][1];

                if(dx < 0 || dy < 0 || dx >= n || dy >= m) continue;
                if(visited[dx][dy]) continue;
                if(fields[dx][dy] != 0) continue;

                visited[dx][dy] = true; // 바이러스 전파
                que.add(new int[] {dx, dy});
            }
        }

        int result = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(!visited[i][j] && fields[i][j] == 0) { // 바이러스가 방문하지 않은 빈칸인 경우
                    result += 1;
                }
            }
        }

        return result;
    }

    private static void output() throws IOException {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
}
```