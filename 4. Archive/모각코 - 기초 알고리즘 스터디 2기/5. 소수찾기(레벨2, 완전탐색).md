https://school.programmers.co.kr/learn/courses/30/lessons/42839

- 완전 탐색
    - 순열 중에 소수가 몇개인지 구하는 문제
- 제한사항
    - numbers는 길이 1 이상 7 이하인 문자열입니다. ⇒ O(7!) = `O(**5040)**`
    - numbers는 0~9까지 숫자만으로 이루어져 있습니다. ⇒ 최대 숫자 `9,999,999` , 천만 이하
- 풀이 절차
    - 에라스토테네스의 체를 사용해서 1000만 미만까지 소수를 찾아둔다
        - O(n log log n)
    - 문자열을 나눠서, int[] 로 변환
        - 재귀로 완전 탐색을 한다 ⇒ 시간복잡도 O(7!) = `O(**5040)**`
        - 이때 방문 처리를 `비트 연산자 (int flag)` 를 사용함. 왜냐하면 최대 7자리이기때문에
        - 다음 값을 구할 때 10을 곱한 후 선택한 수를 더한다
            - 현재 선택한 값이 1이고, 다음 선택한 값이 2이면 `12`가 된다
        - 자바는 `call by value`라서 다음 재귀 호출시 인자 값이 복사되어 전달된다

```java
import java.util.*;

class Solution {
    private Set<Integer> unique;
    
    public int solution(String numbers) {
		    // 1. 전처리
        boolean[] notPrime = new boolean[10000000];
        notPrime[0] = true; // true라는건 소수가 아니라는 의미
        notPrime[1] = true;
        
        for(int i = 2; i < Math.sqrt(10000000); i++) {
            if(notPrime[i]) continue;
            
            for(int j = i + i; j < 10000000; j += i) {
                notPrime[j] = true;
            }
        }
        
        // 2. 순열 구하기
        char[] chars = numbers.toCharArray();
        int[] nums = new int[chars.length];
        for(int i = 0; i < chars.length; i++) {
            nums[i] = chars[i] - '0';
        }
        
        unique = new HashSet<>();
        rec(nums, 0, 0);
        
        // 3. 소수 카운트
        int answer = 0;
        for(int n : unique) {
            if(notPrime[n]) continue;
            
            answer += 1;
        }
        
        return answer;
    }
    
    private void rec(int[] nums, int flag, int value) {
        if(2 <= value) {
            unique.add(value);
        }
        
        for(int i = 0; i < nums.length; i++) {
            if((flag & (1 << i)) != 0) continue;
            
            rec(nums, flag | (1 << i), value * 10 + nums[i]);
        }
    }
    
    
}
```