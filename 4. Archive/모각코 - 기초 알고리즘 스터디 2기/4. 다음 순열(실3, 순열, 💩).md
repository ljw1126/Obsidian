https://www.acmicpc.net/problem/10972

- 시간복잡도 : O(N)
    - 완전 탐색의 경우 O(N!), **시간초과 발생**
- **절차**
    - a[i - 1] < a[i]가 되는 피벗을 찾는다 (뒤에서부터)
        - a[i] ~ a[n - 1] 부분 수열은 이미 가장 큰 순서로 정렬되어 있다고 할 수 있다
        - 이때 a[i - 1]이 교체될 기준점
    - (n -1) ~ i (오른쪽 범위)에서 a[i - 1] < a[j] 조건을 만족하는 가장 작은 수를 찾는다
        - 다음 순열을 찾을 때 **최소한으로만 값을 증가시켜야** 하기 때문
        - 즉, 사전식으로 바로 다음 순열을 만들기 위함
    - a 배열을 i ~ n - 1 범위내에 오름차순 정렬한다
        - 스왑 후 a[i] ~ a[n - 1] 수열은 여전히 내림차순 특성을 가질 수 있다
        - 하지만 우리는 a[i - 1] 기준으로 다음으로 큰 순열을 구해야 한다
        - 답을 구하기 위해 a[i] ~ a[n - 1]을 오름차순 정렬해서 가장 작은 순서의 수열이 만들어짐

```
 0 1 2 3 4
[1 2 5 4 3]
  			 ^
				
절차 1) 뒤에서부터 a[i - 1] < a[i] 조건을 만족하는 위치를 찾는다
			[1 2 5 4 3]
  			   ^	
			    i = 2 ~ n - 1까지 가장 큰 순서로 정렬되어 있다고 본다	
				
절차 2) (n - 1) ~ i 오른쪽 그룹에서 a[i - 1]보다 크고, 그룹내에서 가장 작은 수를 찾아 swap 한다 
				[1 2 5 4 3]
			  			   ^
						a[i - 1] < a[j] 만족

				[1 3 5 4 2]			

절차 3) i ~ n - 1까지 여전히 내림차순 특성을 가지므로, 가장 작은 순서의 수열을 만들기 위해 오름차순 정렬한다 
			[1 3 5 4 2]			
					 s   e
					 
✅결과	[1 3 2 4 5] 		 
```

```java
import java.util.*;
import java.io.*;

public class Main {
    
    private static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws IOException {
        input();
        pro();
        output();
    }

    private static int n;
    private static int[] data;

    private static void input() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        n = Integer.parseInt(br.readLine());

        data = new int[n];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0; i < n; i++) {
            data[i] = Integer.parseInt(st.nextToken());
        }

    }

    private static void pro() {
        int idx = -1;
        // 오른쪽 그룹 시작점을 찾는다
        for(int i = n - 1; i > 0; i--) {
            if(data[i - 1] < data[i]) {
                idx = i;
                break;
            }
        }

        if(idx == -1) {
            sb.append(-1);
            return;
        }

				// 오른쪽 그룹에서 data[idx - 1] < data[i]인 가장 작은 수를 찾아 swap
        for(int i = n - 1; i >= idx; i--) {
            if(data[idx - 1] < data[i]) {
                int temp = data[idx - 1];
                data[idx - 1] = data[i];
                data[i] = temp;
                break;
            }
        }

				// idx ~ n - 1 까지 (내림차순) 큰 순서로 정렬이 보장되므로, 가장 작은 순서 수열을 구하기 위해 정렬
        Arrays.sort(data, idx, n);
        for(int i = 0; i < n; i++) {
            sb.append(data[i]).append(" ");
        }
    }

    private static void output() throws IOException {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
}
```