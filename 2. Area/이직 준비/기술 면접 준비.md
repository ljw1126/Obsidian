


**참고.** 
- [GitHub, tech-interview-for-developer](https://github.com/gyoogle/tech-interview-for-developer)
- [GitHub, CS](https://github.com/NKLCWDT/cs)
- [GitHub, front-end-interview](https://github.com/suwan98/front-end-interview?tab=readme-ov-file)
- 갯츠비님 
	- https://catsbi.oopy.io/
	- https://catsbi.notion.site/c93c7419abc847b88e10a137cedfffc8
- [F-lab, 자바 기술면접 대비하기1편](https://f-lab.kr/blog/java-backend-interview-1)

## \[Frontend\]

### 리액트란?
- 웹/앱 UI를 만들기 위한 JS 라이브러리이다
- 리액트는 `컴포넌트의 집합체`이기도 한다 
	- DOM 트리를 구성하는 노드 중 하나를 컴포넌트라고 한다 (컨테이너)
- 리액트 어플리케이션을 만들어간다는 것은 컴포넌트를 잘 만들어 간다는 것이다 
	- 컴포넌트를 잘 만들기 위해서는? 
		- SRP : 하나의 컴포넌트는 하나의 책임과 역할을 가져야 한다 
		- DRY : 컴포넌트는 재사용 가능해야 한다
	- 좋은 컴포넌트란 **높은 응집도**와 **낮은 결합도**를 가진다 
- 컴포넌트 구성요소 
	- **state** : 내부 상태
	- **props** : 외부로부터 전달받은 상태
	- **render** : 이 두가지 상태를 jsx(js xml) 언어로 나타냄
		- 상태가 변경되게 되면 re-render가 발생
- 리액트는 상태가 변경될 때 re-render한다
	- 이때 `virtual-dom-tree`와 `previous-tree`를 비교해 변경된 부분만 웹 브라우저 DOM 트리에 반영한다
	- 변경된 부분만 업데이트 되기 때문에 효율적이고 빠르다

**React Hooks**
- "낚아 채다" 의미
- 재사용 가능한 로직을 함수로 선언해 사용하는 것을 React Hooks라 한다
- 보통 `use*` prefix로 시작하는 것은 React Hooks에 해당한다 
- React에서 기본 제공하는 Hooks 외에 커스텀 훅을 만들어 공유하여 사용한다
- 기본 제공
	- `useState(..)`
		- 함수형 컴포넌트에서 상태(state)를 개별 독립적으로 관리할 때 사용 
		- 상태 값이 변경되면 다시 랜더링(re-render)이 된다 
	- 아래 컴포넌트 3가지는 불필요한 재랜더링을 방지하고 성능을 최적화하는데 사용
		- `useEffect(..)`
			- 랜더링 이후에 부수효과(side effect)를 실행하기 위한 훅
			- 여기서 부수효과란 데이터 가져오기(fetching), 구독(subscription), DOM 조작 등
			- **핵심**: 상태가 변경될때마다 함수를 실행 (두번째 인자에 의존성 배열을 통해 제어)
		- `useMemo(..)`
			- 대상: 연산량이 많은 함수의 결과값
			- 목적: 연산량이 많은 값을 캐싱하여 불필요한 재연산을 방지 
			- `React.memo`는 컴포넌트 자체를 대상으로 캐싱 
				- props가 변하지 않았을때 컴포넌트의 불필요한 re-render를 방지
		- `useCallback(..)`
			- **함수 자체**를 **메모리제이션** 하기 위해 사용하는 훅
			- 컴포넌트가 re-render될때마다 함수가 새로 생성되는 것을 방지
		- `useEffect(.., [])`, `useMemo(.., [])`, `useCallback(.., [])`
- 커스텀 훅 
	- **react-router** 라이브러리에 useParam(url에 파라미터 가져옴), useNavigate(상세 게시글 같은 url 파라미터 추가해 이동하는 navigate('/articles/{articleId}') 함수 호출할 때 사용)
	- **react-query** 
		- 네트워크 API 요청, 캐싱, 캐싱 무효화, 재요청(retry)
- 그 외 re-render가 되기 위해서는 재생성되어 참조값이 변경되거나 해야 한다. 이러한 수작업을 반복하기 어려움이 있어 immer, redux와 같은 라이브러리나 useReducer를 사용하기도 한다고만 간단히 이해 


**Context API**
- 컴포넌트 트리를 따라 props를 일일이 전달(props drilling)하지 않고 전역 상태나 함수를 공유하도록 해주는 훅
	- props를 통해 컴포넌트끼리 상태를 공유할 수 있다
	- 단순히 부모 노드와 자식 노드, 두 노드 사이에서라면 문제가 되지 않을 수 있지만, 노드의 깊이가 깊어질수록 props에 대한 결합도가 높아지고, 응집도가 낮아진다 
- ex. 로그인 상태, 테마(다크 모드), 언어 설정
- 자식 컴포넌트에서는 useContext 사용해 필요한 속성과 함수를 전달받아 사용


**CSR (Client Side Rendering)**
html과 리액트 코드를 브라우저를 통해 전송 받은 후 클라이언트 브라우저에서 코드가 동작하면 필요한 DOM 요소를 동적 생성하여 보여주는 방식이 CSR이다.


**React Lifecycle**
- [React 공식 문서](https://ko.legacy.reactjs.org/docs/react-component.html)
- 크게 `마운트(Mount)`, `업데이트(Update)`, `언마운트(Unmount)` 세 단계가 있음 
	- re-render는 업데이트 단계를 의미 
- 함수형 컴포넌트와 훅(Hooks)이 등장하기 이전에 **컴포넌트의 생명 주기를 다루는 유일한 방법**은 **클래스 컴포넌트의 특정 메서드를 오버라이드(override)하는 방식**이었음

```javascript
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```
- `componentDidMount` 
	- 컴포넌트가 DOM에 완전히 마운트(삽입)된 후 호출됨 
	- 주로 초기 데이터 로딩이나 이벤트 리스너 등록 작업을 이 메서드에서 처리함
- `componentDidUpdate`
	- 컴포넌트의 상태(state, props)가 변경되어 랜더링이 다시 일어난 직후에 호출됨
	- 최초 랜더링에서는 호출되지 x
	- 변경된 상태에 따라 특정 작업을 수행할 때 사용함
- `componentWillUnmount()` 
	- 마운트 해제 
	- 컴포넌트가 DOM 상에서 제거될 때 호출


**useState가 비동기인 이유**
- 상태 변경 요청 (state update)
	- 사용자가 버튼을 클릭하거나, 어떤 이벤트가 발생하면 setCount(count + 1)과 같이 상태 변경을 요청 
- 프레임 준비(Batching)
	- React는 이 요청을 즉시 처리하지 않고, 다음 랜더링 사이클(프레임)이 시작될 때까지 변경 사항을 모아둡니다. 이 과정을 배치(Batching)라고 합니다. 
- 프레임 랜더링(Rendering)
	- React는 모아둔 모든 상태 변경 요청을 한번에 처리하고, 최종적으로 변경된 상태를 바탕으로 컴포넌트를 한번만 다시 랜더링합니다. 

> 다음 랜더링이라는 '프레임'이 올때까지 기다린다. 
> - useState는 setState 호출시 상태 변경을 즉시 반영하지 않고, 다음 랜더링 사이클이 시작될 때까지 변경 사항들을 모아(batching) 한 번에 처리합니다. 
> - 이는 여러 개의 상태 업데이트가 있을때, 매번 랜더링을 일으키는 것을 막아 **성능 최적화**를 하기 위한 **React의 전략**입니다.


### ajax vs fetch(with Promise)

**ajax (Asynchronous JavaScript and XML)** 
- 비동기적으로 서버와 통신하는 웹 개발 기술 
- 브라우저에 내장된 `XMLHttpRequest`를 사용해 페이지 새로고침하지 않고도 서버로부터 데이터를 가져오는 방식 
- 특징 
	- jquery 라이브러리를 통해 보다 쉽고 간편하게 사용 가능(`$.ajax`)
	- 콜백함수(callback function)을 주로 사용하여 비동기 결과를 처리한다. 이 때문에 복잡한 로직에서는 **콜백 지옥(callback hell)** 에 빠질 수 있다 
		- 가독성 저하, 복잡성 증가

**Promise**
- 콜백 지옥으로 인한 가독성 저하와 복잡성 증가 문제를 해결하기 위해 ES6에서 도입
- `Promise는 자바스크립트 비동기 처리를 위한 객체`이다.
	- **비동기 작업의 결과를 다루는 객체**
- 대기, 성공, 실패(Pending, Fulfilled, Rejected) 3가지 상태로 객체를 구분하고, 비동기 작업을 보다 쉽게 처리할 수 있게 해줌 
	- 왜냐하면 비동기 로직을 순차적으로 표현할 수 있기 때문 (method chaining 방식)

> 프로미스를 사용하면 비동기 작업의 연쇄적인 처리가 가능해지며, 코드의 가독성과 유지 보수성이 향상됨 -> fetch 함수를 통해 비동기로 서버 요청하면 성공 여부에 따라 프로미스를 반환한다 

참고. [F-lab, 자바스크립트 프로미스와 비동기 처리의 이해](https://f-lab.kr/insight/understanding-javascript-promises-and-asynchronous-programming?gad_source=1&gad_campaignid=22368870602&gbraid=0AAAAACGgUFcQ-JIh1RE-f0Q4PW1fQj2Hy&gclid=Cj0KCQjwqebEBhD9ARIsAFZMbfxgRC3s1iWH2__BIqLFgZ7SvN7N_WegADGMGD55FpHtbY5Mc-9LjvUaAlmjEALw_wcB)



**Fetch API**
- Ajax를 대체하기 위해 ES6에 도입된 새로운 웹 API 
- `Promise 기반으로 동작하는 비동기 통신 API`이다
	- **비동기 네트워크 요청 후 Promise 객체를 반환한다**
- 특징 
	- 기본적으로 **Promise를 반환**하므로, then(), catch()를 이용해 비동기 결과를 메서드 체인 방식으로 처리 할 수 있다
	- 문법이 간결하고 가독성이 뛰어남 
	- async/await 문법과 함께 사용하면 비동기 코드를 작성할 수 있어 가독성을 더 높일 수 있음 




### 동기 vs 비동기

**동기(Synchronous)**
- 작업이 순차적으로 진행됩니다. 한 작업이 완료 될때까지 다음 작업은 시작할 수 없고 대기해야 한다.

**비동기(Asynchronous)**
- 작업이 수행 될 때 특정 비동기 작업의 완료를 기다리지 않고 다음 작업을 시작합니다. 
- 완료된 비동기 작업은 나중에 결과를 받아 콜백 함수로 처리하거나 합니다. 


**자바스크립트의 async, await**
- async 키워드가 붙은 함수는 항상 Promise를 반환하게 됩니다. 
	- 이는 곧 await 키워드를 사용할 수 있는 함수라는 것을 나타내는 표식
- await: async 함수 안에서만 사용 가능하며, Promise 앞에 붙여 그 결과가 반환될때까지 함수의 실행을 일시 중지 시킵니다. 이 Promise가 성공적으로 처리되면 await는 결과를 반환하고, 함수는 멈췄던 지점부터 다시 실행됨 
- 비동기식 처리를 해야 하지만, 마치 동기처럼 순서대로 작성할 수 있게 해주는 문법적 편의 기능(syntactic sugar)입니다.
- 이를 통해 복잡한 비동기 작업 흐름을 훨씬 쉽게 이해하고 관리할 수 있음 
	- **코드의 가독성과 유지보수성이 크게 향상됨**

참고. [F-lab, 자바스크립트의 비동기 처리와 콜백, 프로미스, 그리고 async/await](https://f-lab.kr/insight/javascript-async-handling-20240724?gad_source=1&gad_campaignid=22368870602&gbraid=0AAAAACGgUFcQ-JIh1RE-f0Q4PW1fQj2Hy&gclid=Cj0KCQjwqebEBhD9ARIsAFZMbfzsxqltuOKFXhe9zPiL6BX5prmAWBUHQi1xGM5KZwlYYXWtz4gTYIEaAjT1EALw_wcB)

```javascript
async function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 1000);
    });
}

async function main() {
    try {
        const data = await fetchData(); // 대기했다고 이후 실행됨
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}

main();
```


참고. 
- [리액트 면접 대비 질문](https://florescene.tistory.com/559)
- [항해 - 리액트 기술면접](https://hanghae99.spartacodingclub.kr/blog/react-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%98%88%EC%83%81%EC%A7%88%EB%AC%B8-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B01-17721)

### 리액트 면접 질문 10가지

참고. [유튜브](https://www.youtube.com/watch?v=S6GlgPX0Q7k)
1. 리액트에서 **상태 관리**를 위해 useState와 useReducer를 선택하는 기준을 설명해주세요
2. 리액트에서 커스텀 훅을 사용하는 이유와 장점은 무엇인가요?
	1. 로직의 재사용
	2. 한 가지의 책임과 역할을 가지도록 설계한다면 컴포넌트에 순수한 비즈니스 로직만 남고 책임을 위임할 수 있다. 유지보수 용이
3.  리액트의 렌더링 성능 최적화하기 위해 `React.memo`, `useMemo`, `useCallback` 을 어떻게 활용하나요?
	1. React.memo : 컴포넌트 재활용 
	2. useMemo : 복잡한 연산을 메모리제이션해서 re-render시 재활용 (dependency가 같다면)
	3. useCallback : 마찬가지로 콜백 함수 정의를 re-render시 재활용 (dependency가 같다면)
4. 리액트에서 `useEffect`를 사용할 때 **모범 사례**와 **주의할 점**을 설명해주세요 
	1. return의 경우 unmount에 실행되는데 
	2. dependency가 []인 경우, 아닌 경우
5. 리액트에서 **코드 스플리팅**을 구현할 때 `React.lazy`와 `Suspense(정지)`를 어떻게 사용하나요? (기초 질문x)
	1. React.lazy : 지연 처리해서 필요한 시점에 가져올 수 있다
6. 리액트에서 useContext를 사용하여 상태를 공유할 때의 장점과 주의사항을 설명해주세요
	1. 장점 - props drilling을 없애준다
	2. 단점 - provider에서 정의한 컴포넌트를 사용하는 하위 컴포넌트 모두가 리랜더링이 많이 일어날 수 있다. 이러한 부분에서 전역 상태나 함수를 잘 정의해야 한다. 그리고 Provider가 여러 책임을 가지는 경우 사용하는 클라이언트가 너무 많으면 캡슐화를 깨뜨릴 수 있고, 사이드 이펙트가 발생할 수 있을거란 생각도 든다. 그리고 Provider를 너무 많이 나누면 복잡도 증가하여 가독성이나 유지보수가 저하 될 수 있을거란 생각도 드네
7. 복잡한 상황에서 **컴포넌트 설계 원칙**과 **전략**을 설명해주세요 
	1. DRY(UI 로직에서 재사용 가능한 부분을 분리), SRP (단일 책임 원칙, 각 컴포넌트는)
	2. 컴포넌트의 응집도를 높이고, 결합도를 낮춰야 한다
	3. 상태 관리 라이브러리, 커스텀 훅을 사용해서 책임을 분리할 수도 있다
8. 리액트에서 성능 문제를 분석할 때 사용하는 도구와 기법에 대해 설명해주세요 
	1. 크롬 개발자 도구 
		1. source tab -> sourceMap 활용
		2. 리액트 개발도구를 사용해서 profiling 한다 => re-render 확인
			1. [React Developer Toolds](https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
9. Todolist 를 관리하는 애플리케이션에서 실시간으로 항목을 추가, 삭제, 변경하는 기능을 구현하려고 한다. 본인의 경험을 바탕으로 상태 관리를 어떻게 할지 설명해보세요
	1. 브라우저의 로컬 스토리지 사용하는 경우 
	2. useState 초기화시 localStorage에서 아이템을 읽어온다 
		1. 이때 없는 경우 빈 배열을 반환 
	3. todo 아이템 추가 todos에 추가하고, useEffect를 사용해 localStorage에 백업한다 
		1. 이때 useEffect(.., \[todos\]) 디펜던시 설정
	4. `\<TodoItem\>` 컴포넌트를 선언하여 props 전달받아 재활용
10. virtualDOM이 어떻게 성능을 최적화하는지?
	1. 브라우저 DOM에 대한 가벼운 복사본으로 이해..


```
import React, {useEffect, useState} from "react";
import AddTodo from "../AddTodo/AddTodo";
import TodoItem from "../Todo/TodoItem";
import styles from "./TodoList.module.css";

export default function TodoList({filter}) {
	const [todos, setTodos] = useState(() => readTodos());

	const handleAdd = (todo) => {
		const data = [...todos, todo];
		setTodos(data);
	}
	
	const handleUpdate = (updated) => {
		const data = todos.map(t => t.id === updated.id ? updated : t);
		setTodos(data);
	}
	
	const handleDelete = (deleted) => {
		const data = todos.filter(t => t.id !== deleted.id);
		setTodos(data);
	};

	useEffect(() => {
		localStorage.setItem("todoItems", JSON.stringify(todos));
	}, [todos]);

	const filtered = getFilteredItems(todos, filter)

	return (
	
	<section className={styles.container}>
		<ul className={styles.list}>
		{
			filtered.map(item => (
				<TodoItem key={item.id} todo={item} onUpdate={handleUpdate} onDelete={handleDelete}/>
			))
		}
		</ul>
	
		<AddTodo onAdd={handleAdd}/>
	</section>
	);

}

function getFilteredItems(todos, filter) {
	if(filter === 'all') {
		return todos;
	}

	if(filter === 'active') {
		return todos.filter(t => t.status === 'active');
	}

	if(filter === 'completed') {
		return todos.filter(t => t.status === 'completed');
	}

}

function readTodos() {
	const todoItems = localStorage.getItem("todoItems");
	return todoItems ? JSON.parse(todoItems) : [];
}
```


## \[Java\]


## \[Spring\]

### DI, IoC, AOP

**객체 주입 방식** 
1. 필드 주입 (@Autowired)
2. setter 주입 
3. 생성자 주입 (가장 선호)

### SOLID


### TDD


### Restful API vs REST API
- https://dev-coco.tistory.com/97



### 비동기 vs 동기


### \[Spring Batch\]

### 면접 질문 

참고. [유튜브](https://www.youtube.com/watch?v=livWcPTzgPE)
1. 왜 스프링 배치를 사용하는가  (해당 기술을 선택한 기준, 장단점)
2. 멱등성은 어떻게 유지하는가 
3. 스프링 배치 메타데이터 테이블은 어떤 것이 있나 
4. 배치 실행 도중 실패시 처리 방법
	1. Skip, Retry 개념 및 사용 경험 
5. 스프링 배치의 multi thread, partitionning 방법과 차이점
	1. 정해진 시간에 처리량을 높이기 위해 사용
6. 스프링 배치에서 트랜잭션 관리를 왜 chunk size 단위로 하는가
7. tasklet vs Reader/Processor/Writer 차이
8. cursor 기반 vs paging 기반 차이 (사용 클래스)
	1. ItemReader 구현체 중에 cursor와 paging 기반이 있다
9. 배치 실행은 ? (ex. 젠킨스)
10. 배치 모니터링 방법 
	1. 연쇄되는 job이 있다면 지연되는 배치 잡은 어떻게 모니터링 하는지

> 그 개념을 직접 사용해본 사례를 같이 언급하는게 좋다 (2,4,5,7,9,10번 질문에 대해)

**1. 스프링 배치를 사용하는 이유**
- 엔터프라이즈 급의 배치 애플리케이션의 요구사항을 충족시키기 때문에 사용 
	- **안정적인 대용량 처리 지원**
	- **견고한 기능** 
	- **검증된 프레임워크**
		- 검증된 오픈소스 프레임워크이라 신뢰도가 높고 공식 문서와 예제 저장소가 잘되어 있다
- 스프링 배치를 선택하는 기준 
	- 1. **대용량 데이터를 처리하기 위해 안정성이 요구 되는 경우**
	- 2. **복잡한 작업 흐름 제어하거나 병렬 처리가 필요한 경우**
- 스프링 배치의 장단점 
	- 장점 
		- 높은 생산성 
		- 유연성과 확장성
		- 자동화
	 - 단점 
		 - 러닝 커브
		 - 스케줄러 미지원 
		 - 복잡성 : 동시성 제어 관련 thread-safe 한지 상황에 따라 선택하고 flow 전략을 고려해야 함


**2. 멱등성을 지키는 방법**
- 멱등성은 동일한 작업을 여러 번 실행해도 같은 결과를 보장하는 중요한 특성이다
- 스프링 배치를 활용했을때 JobParameter를 활용하여 멱등성을 확보했습니다.
- 예를 들어 shell script, crontab으로 특정 주기의 날짜의 데이터를 수집하거나 처리할 때 배치 실행 커맨드에 파라미터를 명시적으로 전달하여 작업을 시작합니다. 
- 이렇게 하면 스프링 배치는 이 파라미터들을 JobParameters 객체로 관리하고 동일한 파라미터 객체를 가지고 Job이 끝나는 경우 재실행하지 않는 기본 정책을 가지고 있습니다. 
- 만약 작업이 실패했다면, 동일한 파라미터로 재시작하면 되고, 이 경우 스프링 배치는 실패했던 Job 인스턴스를 찾아 중단됨 지점부터 다시 실행합니다. 
- `JobParameters`가 동일하기 때문에 중복 실행을 방지하고, 처음 실행했을때와 동일한 결과를 보장 가능 


**3. 스프링 배치 메타 테이블**
참고. [스프링 공식 문서](https://docs.spring.io/spring-batch/reference/schema-appendix.html#metaDataSchemaOverview)

<img src="./images/spring batch tables.png"/>
- 시퀀스 테이블 3개 생략됨
	- `BATCH_JOB_SEQ`
	- `BATCH_JOB_EXECUTION_SEQ`
	- `BATCH_STEP_EXECUTION_SEQ`


**4. 배치 실행 도중 실패시 처리 방법 (Skip, Retry)** 

`skip`, `retry` 모두 예외 발생시 배치가 실패하지 않고 작업을 계속 진행하기 위한 전략이다 

| 지원 여부 | ItemReader | ItemProcess | ItemWriter |
| ----- | ---------- | ----------- | ---------- |
| skip  | ✅          | ✅           | ✅          |
| retry | ❌          | ✅           | ✅          |

**skip(건너뛰기)**
- 특정 아이템에 예외가 발생하는 경우 건너뛰는 전략 
- **사용지점**: 데이터가 유효하지 않아 처리할 수 없는 경우 (ex. 잘못된 포맷의 데이터)

**retry(재시도)**
- 예외가 발생했을때 동일한 아이템을 여러번 재처리하는 전략
- **사용지점**: 일시적인 문제로 인해 예외가 발생한 경우 (ex. 네트워크 오류, DB Lock)
- retry를 우선 횟수만큼 재시도하고, 이를 초과하면 `item skip` ➡️ skip 횟수가 일정 초과하면 해당 job은 최정적으로 실패로 간주된다


**5. 스프링 배치의 multi thread, partitionning 방법과 차이점**




**6. 스프링 배치에서 트랜잭션 관리를 왜 chunk size 단위로 하는가**

>[!note] 내 생각 
>한꺼번에 너무 많은 양의 데이터를 읽고 처리하고 저장한다고 치면 이로 인한 시스템 부하와 네트워크 통신 비용이 많이 들것이고, 장애 발생시 복구하기 어려울것이다. chunk size 단위로 나눠 처리하게 될 경우 시스템 부하를 방지 가능하고, 네트워크 비용, 성능 최적화, 장애 복구도 용이한 것으로 알고 있다.

- 시스템 부하 및 성능 최적화 관점
	- **배치 메모리 효율** : 모든 데이터를 한꺼번에 메모리에 로드하고 OOM가 발생할 수 있습니다. chunk 단위로 데이터를 읽고 처리하면 메모리 사용량을 일정하게 유지하여 시스템 부하를 줄 일 수 있습니다. 
	- **DB 네트워크 부하 방지** : 대량의 SQL 요청을 한 번에 보내는 대신 chunk 단위만큼 모아 batchInsert 하며 커밋 처리합니다. 이는 DB와 네트워크 I/O를 최소화하여 성능 최적화합니다.
- 안정성 및 복구 용이성 
	- **트랜잭션 범위** : chunk 단위로 트랜잭션 커밋되므로, 작업 도중 실패하더라도 이미 커밋된 데이터는 안전하게 유지됨 
	- **재시작** : 스프링 배치는 JobRepository를 통해 각 Chunk의 실행 상태를 DB에 저장합니다. 따라서 작업이 실패하면 마지막으로 성공한 Chunk의 다음 아이템 부터 재시작할 수 있습니다. 이를 통해 처음부터 다시 시작하는 비효율을 막고, 빠른 복구를 가능하게 합니다.


**7. tasklet vs  ItemReader/Processor/Writer 차이**

**Tasklet 방식**
- 단일 Step 내에서 한 가지 작업을 수행하고 종료되는 단순한 방식
- 전체 Step의 비즈니스 로직이 execute 메서드 내에 모두 포함됨
- 복잡한 단계가 필요없이 단순하고 짧은 작업에 적합
- 구현이 간단
- 대량 데이터 처리시 트랜잭션 관리, 청크 단위 처리, 재시작 기능 등 스프링 배치의 핵심 기능들을 직접 구현해야 함💩

**Chunk 지향 처리(ItemReader/Process/Writer)**
- 대용량 데이터를 읽고, 가공하고, 쓰는 과정을 독립적인 세 컴포넌트로 분리한 방식이다 
	- 명확한 책임분리, 유지보수성이 높고 고수준 모듈에 의존하고 있어 구현체를 갈아끼워 기능 확장에도 유연하다
- ✨**Chunk 단위**로 트랜잭션을 관리함
- 대용량 데이터를 안정적으로 처리하는데 최적화

| 구분     | Tasklet                       | Chunk 지향 처리                           |
| ------ | ----------------------------- | ------------------------------------- |
| 처리 단위  | 하나의 작업                        | chunk 단위의 item                        |
| 적합한 작업 | 단순한 단일 작업(ex. 파일 이동, 스크립트 실행) | 대용량 데이터 처리(ItemReader/Process/Writer) |
| 구현 난이도 | 간단                            | Tasklet보다 복잡하지만, 생산성/유지보수성이 높음        |
| 주요 장점  | 구현이 단순하고 직관적이다                | 안정성과 성능이 뛰어나며, 재시작 및 트랜잭션 관리가 용이      |


**8. cursor 기반 vs paging 기반 차이**
- ItemReader 구현체 중에 cursor와 paging기반이 있다 




**9. 배치 실행 방식**
전 회사에서는 배치 개발 후 jenkins 통해 빌드/배포가 되었습니다. 직접 배포 서버에 접속해 shell script와 log4j 설정 추가 후 주기적으로 실행가능하도록 crontab을 활용하도록 했었습니다. 


**10. 배치 모니터링 방법** 
- 전 회사에서는 log4j 활용해 로그를 기록 후 ssh 접속해 직접 확인하거나, shell script 기반으로 배치 성공/실패 여부를 slack webhook으로 보내는 형태로 관리했던 것으로 기억 
- 이외 배치 세미나 영상 찾아봤을 때 두 가지 방법이 있는 것으로 확인했습니다.
	- 1. Spring Cloud Data Flow 방법
		- 배치 및 스트림 처리 애플리케이션을 통합 관리할 수 있는 플랫폼
		- GUI 환경에서 배치 작업을 구성/실행/모니터링 할 수 있으며, 배치 작업의 실행 상태/로그/통계 등을 시각적으로 제공 
		- 이는 복잡한 배치 파이프라인을 관리할 때 특히 유용합니다
	- 2. Spring Actuactor + Prometheus + Grafana 방법
		- 매트릭 수집하여 오픈소스 기반으로 수집하고, 이를 시각화

	  
## \[DB\]

### RDB vs NoSQL


### 인덱스란


### 클러스터 인덱스 vs 넌 클러스터 인덱스



## \[인프라\]