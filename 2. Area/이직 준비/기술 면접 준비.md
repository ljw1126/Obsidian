


**참고.** 
- [GitHub, tech-interview-for-developer](https://github.com/gyoogle/tech-interview-for-developer)
- [GitHub, CS](https://github.com/NKLCWDT/cs)
- [GitHub, front-end-interview](https://github.com/suwan98/front-end-interview?tab=readme-ov-file)
- 갯츠비님 
	- https://catsbi.oopy.io/
	- https://catsbi.notion.site/c93c7419abc847b88e10a137cedfffc8
- [F-lab, 자바 기술면접 대비하기1편](https://f-lab.kr/blog/java-backend-interview-1)

## \[Frontend\]

### 리액트란?
- 웹/앱 UI를 만들기 위한 JS 라이브러리이다
- 리액트는 `컴포넌트의 집합체`이기도 한다 
	- DOM 트리를 구성하는 노드 중 하나를 컴포넌트라고 한다 (컨테이너)
- 리액트 어플리케이션을 만들어간다는 것은 컴포넌트를 잘 만들어 간다는 것이다 
	- 컴포넌트를 잘 만들기 위해서는? 
		- SRP : 하나의 컴포넌트는 하나의 책임과 역할을 가져야 한다 
		- DRY : 컴포넌트는 재사용 가능해야 한다
	- 좋은 컴포넌트란 **높은 응집도**와 **낮은 결합도**를 가진다 
- 컴포넌트 구성요소 
	- **state** : 내부 상태
	- **props** : 외부로부터 전달받은 상태
	- **render** : 이 두가지 상태를 jsx(js xml) 언어로 나타냄
		- 상태가 변경되게 되면 re-render가 발생
- 리액트는 상태가 변경될 때 re-render한다
	- 이때 `virtual-dom-tree`와 `previous-tree`를 비교해 변경된 부분만 웹 브라우저 DOM 트리에 반영한다
	- 변경된 부분만 업데이트 되기 때문에 효율적이고 빠르다

**React Hooks**
- "낚아 채다" 의미
- 재사용 가능한 로직을 함수로 선언해 사용하는 것을 React Hooks라 한다
- 보통 `use*` prefix로 시작하는 것은 React Hooks에 해당한다 
- React에서 기본 제공하는 Hooks 외에 커스텀 훅을 만들어 공유하여 사용한다
- 기본 제공
	- `useState(..)`
		- 함수형 컴포넌트에서 상태(state)를 개별 독립적으로 관리할 때 사용 
		- 상태 값이 변경되면 다시 랜더링(re-render)이 된다 
	- 아래 컴포넌트 3가지는 불필요한 재랜더링을 방지하고 성능을 최적화하는데 사용
		- `useEffect(..)`
			- 랜더링 이후에 부수효과(side effect)를 실행하기 위한 훅
			- 여기서 부수효과란 데이터 가져오기(fetching), 구독(subscription), DOM 조작 등
			- **핵심**: 상태가 변경될때마다 함수를 실행 (두번째 인자에 의존성 배열을 통해 제어)
		- `useMemo(..)`
			- 대상: 연산량이 많은 함수의 결과값
			- 목적: 연산량이 많은 값을 캐싱하여 불필요한 재연산을 방지 
			- `React.memo`는 컴포넌트 자체를 대상으로 캐싱 
				- props가 변하지 않았을때 컴포넌트의 불필요한 re-render를 방지
		- `useCallback(..)`
			- **함수 자체**를 **메모리제이션** 하기 위해 사용하는 훅
			- 컴포넌트가 re-render될때마다 함수가 새로 생성되는 것을 방지
		- `useEffect(.., [])`, `useMemo(.., [])`, `useCallback(.., [])`
- 커스텀 훅 
	- **react-router** 라이브러리에 useParam(url에 파라미터 가져옴), useNavigate(상세 게시글 같은 url 파라미터 추가해 이동하는 navigate('/articles/{articleId}') 함수 호출할 때 사용)
	- **react-query** 
		- 네트워크 API 요청, 캐싱, 캐싱 무효화, 재요청(retry)
- 그 외 re-render가 되기 위해서는 재생성되어 참조값이 변경되거나 해야 한다. 이러한 수작업을 반복하기 어려움이 있어 immer, redux와 같은 라이브러리나 useReducer를 사용하기도 한다고만 간단히 이해 


**Context API**
- 컴포넌트 트리를 따라 props를 일일이 전달(props drilling)하지 않고 전역 상태나 함수를 공유하도록 해주는 훅
	- props를 통해 컴포넌트끼리 상태를 공유할 수 있다
	- 단순히 부모 노드와 자식 노드, 두 노드 사이에서라면 문제가 되지 않을 수 있지만, 노드의 깊이가 깊어질수록 props에 대한 결합도가 높아지고, 응집도가 낮아진다 
- ex. 로그인 상태, 테마(다크 모드), 언어 설정
- 자식 컴포넌트에서는 useContext 사용해 필요한 속성과 함수를 전달받아 사용


**CSR (Client Side Rendering)**
html과 리액트 코드를 브라우저를 통해 전송 받은 후 클라이언트 브라우저에서 코드가 동작하면 필요한 DOM 요소를 동적 생성하여 보여주는 방식이 CSR이다.


**React Lifecycle**


**useState가 비동기인 이유**
- 상태 변경 요청 (state update)
	- 사용자가 버튼을 클릭하거나, 어떤 이벤트가 발생하면 setCount(count + 1)과 같이 상태 변경을 요청 
- 프레임 준비(Batching)
	- React는 이 요청을 즉시 처리하지 않고, 다음 랜더링 사이클(프레임)이 시작될 때까지 변경 사항을 모아둡니다. 이 과정을 배치(Batching)라고 합니다. 
- 프레임 랜더링(Rendering)
	- React는 모아둔 모든 상태 변경 요청을 한번에 처리하고, 최종적으로 변경된 상태를 바탕으로 컴포넌트를 한번만 다시 랜더링합니다. 

> 다음 랜더링이라는 '프레임'이 올때까지 기다린다. 
> - useState는 setState 호출시 상태 변경을 즉시 반영하지 않고, 다음 랜더링 사이클이 시작될 때까지 변경 사항들을 모아(batching) 한 번에 처리합니다. 
> - 이는 여러 개의 상태 업데이트가 있을때, 매번 랜더링을 일으키는 것을 막아 **성능 최적화**를 하기 위한 **React의 전략**입니다.


### ajax vs fetch(with Promise)

**ajax (Asynchronous JavaScript and XML)** 
- 비동기적으로 서버와 통신하는 웹 개발 기술 
- 브라우저에 내장된 `XMLHttpRequest`를 사용해 페이지 새로고침하지 않고도 서버로부터 데이터를 가져오는 방식 
- 특징 
	- jquery 라이브러리를 통해 보다 쉽고 간편하게 사용 가능(`$.ajax`)
	- 콜백함수(callback function)을 주로 사용하여 비동기 결과를 처리한다. 이 때문에 복잡한 로직에서는 **콜백 지옥(callback hell)** 에 빠질 수 있다 
		- 가독성 저하, 복잡성 증가

**Promise**
- 콜백 지옥으로 인한 가독성 저하와 복잡성 증가 문제를 해결하기 위해 ES6에서 도입
- `Promise는 자바스크립트 비동기 처리를 위한 객체`이다.
	- **비동기 작업의 결과를 다루는 객체**
- 대기, 성공, 실패(Pending, Fulfilled, Rejected) 3가지 상태로 객체를 구분하고, 비동기 작업을 보다 쉽게 처리할 수 있게 해줌 
	- 왜냐하면 비동기 로직을 순차적으로 표현할 수 있기 때문 (method chaining 방식)

> 프로미스를 사용하면 비동기 작업의 연쇄적인 처리가 가능해지며, 코드의 가독성과 유지 보수성이 향상됨 -> fetch 함수를 통해 비동기로 서버 요청하면 성공 여부에 따라 프로미스를 반환한다 

참고. [F-lab, 자바스크립트 프로미스와 비동기 처리의 이해](https://f-lab.kr/insight/understanding-javascript-promises-and-asynchronous-programming?gad_source=1&gad_campaignid=22368870602&gbraid=0AAAAACGgUFcQ-JIh1RE-f0Q4PW1fQj2Hy&gclid=Cj0KCQjwqebEBhD9ARIsAFZMbfxgRC3s1iWH2__BIqLFgZ7SvN7N_WegADGMGD55FpHtbY5Mc-9LjvUaAlmjEALw_wcB)



**Fetch API**
- Ajax를 대체하기 위해 ES6에 도입된 새로운 웹 API 
- `Promise 기반으로 동작하는 비동기 통신 API`이다
	- **비동기 네트워크 요청 후 Promise 객체를 반환한다**
- 특징 
	- 기본적으로 **Promise를 반환**하므로, then(), catch()를 이용해 비동기 결과를 메서드 체인 방식으로 처리 할 수 있다
	- 문법이 간결하고 가독성이 뛰어남 
	- async/await 문법과 함께 사용하면 비동기 코드를 작성할 수 있어 가독성을 더 높일 수 있음 




### 동기 vs 비동기

**동기(Synchronous)**
- 작업이 순차적으로 진행됩니다. 한 작업이 완료 될때까지 다음 작업은 시작할 수 없고 대기해야 한다.

**비동기(Asynchronous)**
- 작업이 수행 될 때 특정 비동기 작업의 완료를 기다리지 않고 다음 작업을 시작합니다. 
- 완료된 비동기 작업은 나중에 결과를 받아 콜백 함수로 처리하거나 합니다. 


**자바스크립트의 async, await**
- async 키워드가 붙은 함수는 항상 Promise를 반환하게 됩니다. 
	- 이는 곧 await 키워드를 사용할 수 있는 함수라는 것을 나타내는 표식
- await: async 함수 안에서만 사용 가능하며, Promise 앞에 붙여 그 결과가 반환될때까지 함수의 실행을 일시 중지 시킵니다. 이 Promise가 성공적으로 처리되면 await는 결과를 반환하고, 함수는 멈췄던 지점부터 다시 실행됨 
- 비동기식 처리를 해야 하지만, 마치 동기처럼 순서대로 작성할 수 있게 해주는 문법적 편의 기능(syntactic sugar)입니다.
- 이를 통해 복잡한 비동기 작업 흐름을 훨씬 쉽게 이해하고 관리할 수 있음 
	- **코드의 가독성과 유지보수성이 크게 향상됨**

참고. [F-lab, 자바스크립트의 비동기 처리와 콜백, 프로미스, 그리고 async/await](https://f-lab.kr/insight/javascript-async-handling-20240724?gad_source=1&gad_campaignid=22368870602&gbraid=0AAAAACGgUFcQ-JIh1RE-f0Q4PW1fQj2Hy&gclid=Cj0KCQjwqebEBhD9ARIsAFZMbfzsxqltuOKFXhe9zPiL6BX5prmAWBUHQi1xGM5KZwlYYXWtz4gTYIEaAjT1EALw_wcB)

```javascript
async function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 1000);
    });
}

async function main() {
    try {
        const data = await fetchData(); // 대기했다고 이후 실행됨
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}

main();
```


참고. 
- [리액트 면접 대비 질문](https://florescene.tistory.com/559)
- [항해 - 리액트 기술면접](https://hanghae99.spartacodingclub.kr/blog/react-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%98%88%EC%83%81%EC%A7%88%EB%AC%B8-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B01-17721)




## \[Java\]


## \[Spring\]

### DI, IoC, AOP


### SOLID


### TDD


### Restful API vs REST API
- https://dev-coco.tistory.com/97



### 비동기 vs 동기


### \[Spring Batch\]




## \[DB\]

### RDB vs NoSQL


### 인덱스란


### 클러스터 인덱스 vs 넌 클러스터 인덱스



## \[인프라\]



