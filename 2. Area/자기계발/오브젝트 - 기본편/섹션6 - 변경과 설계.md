
> 응집도, 결합도, 캡슐화를 제대로 이해하기 위해서는 변경 관점에서 이해해야 한다
### 6-1. 변경과 설계 
**설계란?**
기능은 동일하지만 **코드를 배치하는 방식에 차이**가 남
- 절차적인 설계
	- 데이터와 기능을 별도의 모듈로 `분리`
- 객체지향 설계
	- 데이터와 기능을 하나의 모듈로 `통합`


**훌륭한 설계?**
`응집도가 높고, 결합도가 낮고 캡슐화를 지키도록` 코드를 배치하는 것


**응집도 (Cohesion)** //높이고
> 클래스 내부의 기능적인 집중도
- `모듈(클래스)` 내부의 특성 
- 모듈 내부 요소들 사이의 **기능적인 집중도** 
- 모듈 내부의 데이터와 메서드 간에 **관련된 정도** 
- 응집도가 높다(high)/낮다(low)로 표현
- 훌륭한 설계는 `응집도가 높은 설계`
	- **높은 응집도** : 하나의 기능에 집중
	- **낮은 응집도** : 서로 다른 기능이 혼재


**결합도 (Coupling)** // 낮추고
> 클래스가 다른 클래스에 의존하는 정도
- 모듈이 외부의 다른 모듈에 의존하는 정도
- 모듈이 다른 모듈에 대해 알고 있는 **지식의 양**
- 결합도가 높다(high)/낮다(low), 강하다(tight)/느슨하다(loose)로 표현
- 훌륭한 설계는 `결합도가 낮은 설계`
	- **높은 결합도** : 많은 지식 
	- **낮은 결합도** : 적은 지식


**캡슐화(Encapsulation)** // 준수
> 데이터를 감추고 공용 메서드를 외부에 공개
- 내부의 데이터와 메서드를 **하나의 단위로 묶음** 
- 외부로부터 데이터에 대한 **직접적인 접근 제한**
- `공용 인터페이스 (public interface)`를 통한 접근만 허용


**개발자 / 프로그램의 의무**
> [!note] 샌디 메츠
> 우리가 짜는 프로그램은 두 가지 요구사항을 만족시켜야 한다. **우리는 오늘 완성해야 하는 기능을 구현**하는 코드를 작성하는 동시에 **내일 쉽게 변경할 수 있는** 코드를 작성해야 한다 

>[!note] 훌륭한 설계란 
>변경하기 쉽게 코드를 배치하는 것


**설계의 핵심** 
- 모든 설계 원칙과 이론은 `변경`과 관련된다
- 설계와 변경을 함계 고려해야 한다 
	- SOLID 원칙
- 디자인 패턴도 `변경`과 관련
	- 다양한 디자인 패턴의 목적은 `변경을 감추는 것`
- 응집도, 결합도, 캡슐화 역시 `변경`과 관련

> [!info] 변경을 예상하지 마라, 로버트 C.마틴
> 변경의 축은 **변경이 실제로 일어날 때만 변경의 축**이다. 이것은 처음에는 코드가 변경되지 않을 것이라 생각하고 작성한다는 것을 의미한다. 변경이 일어나면, 나중에 일어날 그런 종류의 변경에 대해 보호하는 추상화를 구현한다 


### 6-2. 응집도 

**응집도 (Cohesion)** - 전통적인 관점
> 클래스 내부의 기능적인(데이터와 메서드) 집중도 
- `모듈(클래스)` 내부의 특성 
- 모듈 내부 요소들 사이의 **기능적인 집중도** 
- 모듈 내부의 데이터와 메서드 간에 **관련된 정도** 
- 응집도가 높다(high)/낮다(low)로 표현
- 훌륭한 설계는 `응집도가 높은 설계`
	- **높은 응집도** : 하나의 기능에 집중
	- **낮은 응집도** : 서로 다른 기능이 혼재


**응집도 (Cohesion)**  - 변경 관점
- 모듈 내부 요소들이 함께 번경되는 정도
	- **높은 응집도** : 
		- 모듈 전체가 동일한 시점에 동일한 속도로 변경
		- 모듈 전체가 `동일한 이유로 변경`
	- **낮은 응집도** : 
		- 모듈의 요소들이 서로 다른 시점에 다른 속도로 변경
		- 모듈 각 부분이 `서로 다른 이유로 변경`

영화관 예시에서 할인 정책의 종류나 할인 금액 계산 방법이 변경될때 코드 수정이 발생한다. 또한, 할인 조건의 종류나 할인 여부를 판단하는 방법이 변경될때 코드 수정이 발생한다. 

다양한 이유로 변경되는 절차적인 모듈은 `응집도가 낮다`고 말할 수 있다 

// 객체 지향적으로 변경된 모듈의 경우 설명 
각 할인 조건과 할인 정책은 각 모듈이 담당하는 정책이 바뀌면 수정이 발생한다 (이미지 추가하기)

`각 클래스의 변경 이유는 하나이다`, 따라서 객체 지향 설계는 응집도가 높다 

> 응집도는 단일 책임 원칙과 관련있다
> - SRP : 각 클래스는 단 하나의 이유로만 변경되어야 한다


**응집도 - 클래스 크기 기준에 대한 가이드**
- `변경의 이유`를 기준으로 클래스의 크기를 정하라 (4:32 이미지 추가)
- `변하는 이유가 다른 코드들을 서로 다른 모듈로 분리하라`
- 클래스의 라인수가 중요한게 아니라, 변경 이유가 중요


**응집도를 높이기 위한 분리 기준**
- 클래스가 하나 이상의 이유로 변경된다면 응집도가 낮은 것이다. 
	- `변경의 이류를 기준으로 클래스를 분리하라`
- 특정한 메서드 그룹이 특저한 속성 그룹만 사용한다면 응집도가 낮은 것이다. 
	- `함께 사용되는 메서드와 속성 그룹을 기준으로 클래스를 분리하라`
- 클래스의 인스턴스를 초기화할 때 경우에 다라 서로 다른 속성들을 초기화한다면 응집도가 낮은 것이다. 
	- `초기화되는 속성의 그룹을 기준으로 클래스를 분리하라`



### 6-3. 결합도 

**결합도 (Coupling)** - 전통적인 관점
> 클래스가 다른 클래스에 의존하는 정도, 알고 있는 지식의 양
- 모듈이 외부의 다른 모듈에 의존하는 정도
- 모듈이 다른 모듈에 대해 알고 있는 **지식의 양**
- 결합도가 높다(high)/낮다(low), 강하다(tight)/느슨하다(loose)로 표현
- 훌륭한 설계는 `결합도가 낮은 설계`
	- **높은 결합도** : 많은 지식 
	- **낮은 결합도** : 적은 지식

**지식의 양**
- 절차적인 코드와 객체 지향 코드를 비교해봄
- 절차 지향의 경우 DiscountPolicy의 이름과 getter와 같은 시그니처를 알고 있다.
- 객체 지향의 경우에도는 클래스 이름과 메서드 시그니처에 대해 알고 있다. 


**결합도 (Coupling)** - 변경 관점 
- `외부`의 다른 모듈에 의해 `함께 변경되는 정도`
- 높은 결합도 
	- 외부의 모듈이 변경될 때 함께 변경되는 빈도가 상대적으로 높음 
	- 여러 모듈이 서로 영향을 주고 받으며 함께 변경
- 낮은 결합도
	- 외부의 모듈이 변경될 때 함께 변경되는 빈도가 상대적으로 적음 
	- 각 모듈이 다른 모듈에 영향을 주지 않고 변경 가능 


**의존성과 결합도는 밀접한 개념**
- 의존성은 있다/없다의 개념
- 의존성은 특정한 경우에 함께 변경될 수 있음을 의미
- 의존성이 항상 함께 변경되다는 의미는 아님
	- `A -> B` 일대 B가 변경될 경우 A가 변경될 수도 있다 (`변경 가능성`을 나타냄)
- 결합도는 의존성과 함께 존재 
- 결합도는 빈번하다/드믈다의 개념
- 결합도는 함께 변경되는 빈도를 의미
- 결합도는 상대적인 개념

> 좋은 설계는 결합도가 낮은 설계이고, 결합도가 낮다는건 함께 변경될 빈도가 낮다는 걸 의미
- 결합도 낮추기 : 함께 변경될 가능성 낮추기의 의미 
	- 의존성을 통제해서 B가 변경될 때 A가 함께 변경되는 경우를 제한
	- A가 B의 `자주 변하지 않는 부분에만 의존`하면 함께 변경될 가능성을 낮출 수 있음

>[!note] 의존성 제어 원칙
>1. 자주 변하는 것과 변하지 않는 것을 분리하라
>2. 자주 변하지 않는 것에 의존하라
- `A -> B`일때 
	- 자주 변하지 않는 `안정적인 부분(= 추상화)`에 의존하게 한다 
	- 자주 변하는 `불안정한 부분(= 구현)`

설계에서 추상화는 자주 변하지 않는 안정적인 부분을 의미한다 
추상화는 불필요한 부분을 감추는데 이때 불필요한 부분이 구현에 해당한다

추상화된 인터페이스를 의존한다는건 구현이 변경될 경우 추상화가 변경 전파를 방지한다✅
- 구현이 변경될 경우의 부수효과 방지 

높은 결합도 : 외부 모듈의 내부 구현이 변경될 때 함께 변경
낮은 결합도 : 외부 모듈의 내부 구현이 변경될 때 함께 변경되지 않음✅

협력관점에서 `추상화`를 `인터페이스`라고 한다 
- 인터페이스와 구현의 분리 원칙 

> 결합도를 낮추기 위해서는 구현이 아닌 인터페이스에 의존하도록 프로그래밍해야 함

> 8:06 접근 제어자와 결합도에 대한 설명
- 절차적 설계
	- getter/setter도 구현에 해당한다 
	- 고로 시그니처를 변경하면 변경 전파된다
	- 따라서 절차적인 설계는 높은 결합도를 가진다. 
- 객체지향 설계
	- 인터페이스에만 의존하고 있다. 


> 오 절차 지향과 객체 지향의 변경 전파에 대한 설명이 인상 깊다. 


**변경하기 쉬운 코드를 위한** 객체지향 설계 원칙
- 협력에 필요한 `행동`을 `먼저` 결정하고 행동에 적합한 `객체`를 `나중에` 선택하라
- 👉 객체의 `행동`을 `먼저` 구현하고 행동에 필요한 `데이터`를 `나중에` 선택하라

**협력에 필요한 행동을 먼저 결정**
- 1. 행동에 대한 `메시지`를 먼저 결정 (**calculateDiscount**)
- 2. 행동을 제공하기에 적합한 `객체를 선택` (**DiscountPolicy**)
- 3. 행동을 구현하면서 구현에 적합한 데이터를 결정  (**DiscountCondition**)

> Movie는 DiscountPolicy에 느슨한 결합을 하고 있다
- 추상화가 변경에 의한 전파를 막는다 ✅

> 객체 지향 설계나 절차적인 설계보다 낮은 결합도를 만들기 쉽다 


### 6-4. 캡슐화 
**캡슐화(Encapsulation)**  - 전통적인 관점
> 데이터를 감추고 공용 메서드를 외부에 공개
- **내부**의 데이터와 메서드를 **하나의 단위로 묶음** 
- **외부**로부터 데이터에 대한 **직접적인 접근 제한**
- `공용 인터페이스 (public interface)`를 통한 접근만 허용

> 절차적인 모듈(클래스)과 객체지향 모듈의 캡슐화는 같을까?

> 캡슐화를 제대로 이해하기 위해서는 변경 관점에서 바라봐야 한다

**캡슐화(Encapsulation)**  - 변경 관점 
- `변경되는 부분`을 내부로 `숨기는` 추상화 기법
- 변경될 수 있는 `어떤 것`이라도 감추는 것
- ✅ 설계에서 변하는 부분이 무엇인지 고민하고 `변하는 개념을 캡슐화`
	- 자주 변하는 부분을 안정적인 부분 안에 감춘다

> 캡슐화는 낮은 결합도와 연관


**데이터 캡슐화(Data Encapsulation)**
- 캡슐화의 한 종류
- 전통적인 객체지향 캡슐화의 다른 이름
- **데이터의 변경을 감추고** 안정적인 공용 인터페이스를 외부에 공개
	- 절차적인 설계에서는 데이터 타입을 변경하면, 클라이언트 코드가 구현(getter)에 의존하고 있어 캡슐화가 실패하게 된다 💩
	- 반면 객체 지향은 데이터가 아닌 인터페이스에 의존해서 데이터 캡슐화를 성공할 수 있다✅ 

> xxx 캡슐화 = xxx의 변경을 외부에 감춤
> 데이터 캡슐화 = 데이터의 변경을 외부에 감춤
> 타입 캡슐화 = 타입의 변경을 외부에 감춤 (객체 지향 설계에서 가장 중요)
- "비율 할인을 계산하라", "금액 할인을 계산하라"
	- 책임은 동일, 메시지만 다름
- 결론, `Movie는 DiscountPolicy 추상화에 의존한다`
	- Movie 입장에서 DiscountPolicy 타입이 캡슐화된다

>[!note] 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

> 클라이언트 입장에서 서브 타입이 부모 타입을 대체 할 수 있도록하는 원칙을 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)라고 함
> - LSP는 `타입 캡슐화 원칙`일 수 있다

> [!note] OCP
> 새로운 동작을 추가하면서도 기존 코드를 수정하지 않는 원칙을 뜻함
> 확장에는 열려있고 수정에는 닫혀있다.
> `타입 캡슐화`를 통해 확장 지원한다


### 6-5. 설계 평가하기 

> [!note] 응집도 (Cohesion)
> 클래스 내부의 기능적인 집중도

>[!note] 결합도 (Coupling)
>클래스가 다른 클래스에 의존하는 정도

> [!note] 캡슐화 (Encapsulation)
> 데이터를 감추고 공용 메서드를 외부에 공개

- 처음 서비스에서는 할인 정책이 하나 뿐이라 Movie 클래스 내에 선언해서 사용 
- 서비스가 성장하면서
	- 새로운 할인 정책을 추가하게 된다. 
	- Movie 안에 새로운 계산 로직을 추가 (조건절로)
- Movie안에 점점 쌓여가는 로직들 
	- `응집도, 결합도, 캡슐화 관점에서 코드를 검토하는게 좋다`
	- 응집도 관점에서 Movie 평가 
		- 서로 다른 이유로 변경되는 로직이 공존


**응집도를 높이기 위한 분리 기준**
- 클래스가 하나 이상의 이유로 변경된다면 응집도가 낮은 것이다. 
	- `변경의 이유를 기준으로 클래스를 분리하라`
	- 가장 간단한 방법이 **상속 계층 구성**
- 특정한 메서드 그룹이 특저한 속성 그룹만 사용한다면 응집도가 낮은 것이다. 
	- `함께 사용되는 메서드와 속성 그룹을 기준으로 클래스를 분리하라`
		- ex. `fee`, `conditions`
- 클래스의 인스턴스를 초기화할 때 경우에 다라 서로 다른 속성들을 초기화한다면 응집도가 낮은 것이다. 
	- `초기화되는 속성의 그룹을 기준으로 클래스를 분리하라`
		- 금액 할인, 비율 할인 정책에 필요없는 필드를 null로 초기화하네

> 상속을 사용하면 자주 변하는 것과 변하지 않는 것을 분리할 수 있다 (= 응집도를 높일 수 있다)

**상속을 이용한 클래스 계층 구조 구성**
- ..
- 하지만 상속이 가지는 한계로 인해 응집도가 낮아지고 결합도가 낮아 질 수 있다
	- 부모 클래스의 protected 필드에 직접 사용하고 있어 변경에 취약
	- 런타임에 할인 정책을 변경한다면 컴파일 타임 결합으로 인한 클래스 변경 필요 
		- 초기화를 따로 어디서 수동으로 하고 있다면
		- 컴파일 타임에 결합이 되는 문제
- ✅ 상속에서 합성으로
	- 컴파일 타입 결합으로 인한 클래스 변경 필요한 경우
	- (setter 메서드를 통해) Movie 인스턴스 타입을 유지하면서 할인 정책 변경 가능

> [!note] 응집도, 결합도, 캡슐와에 대한 관점이 객체 협력과 클래스 구조를 변경
> 
- 그리고 3가지 요소가 `설계에 대한 피드백`을 제공한다

> [!tip] 변경은 변경이 발생할 때만 변경이다.
- 변경이 발생하지 않는데 쓸데없이 복잡성을 높일 필요 없다 
- 설계를 트레이드 오프하기 위해서는 변경의 관점에서 3요소를 살펴봐야 한다✅

### 6-6. 중복 할인 정책 추가하기 

문제는 기존 코드 수정을 통해 기능을 확장하는 것
- 이를 위해서는 코드를 읽고 이해하고 그안에 포함하는 기능을 수정하게 될 경우 여러 문제가 발생가능 
	- 버그와 사이드 이펙트
	- 기존 코드를 수정해야 한다는 두려움으로 이어진다
	- 테스트하기 어려운 코드
	- 중복할인이라는 개념도 표현도 안된다 (알고리즘으로 풀고 있는 상태)
		- ✅ `객체 지향은 명사를 이용해서 동사로 풀수 있는 강력한 체계를 제공`
	- 레거시는 코드를 읽고 이해한 후에 중복 할인이라는 개념과 연결 지어야 한다💩
		- 고로, 현재 코드는 읽기도 이해하기도 수정하기도 어렵다 

> 좋은 설계는 쉽게 수정할 수 있도록 코드를 배치한 설계이다 

**우리가 감추고 싶은 것**
- oo 캡슐화 <- oo의 변경을 외부에 감춤
	- oo  : 개수

**메시지 기반의 추상화를 이용한 협력 통합**

**✅ COMPOSITE 디자인 패턴**
- Movie는 DiscountPolicy의 개수와 무관하게 협력 가능

> 개념을 명시적으로 표현 (=중복할인)
> 표현적 차이를 줄일 수 있다

> OCP 원칙 준수


**객체지향 설계의 핵심** 
- `메시지`에 초점을 맞춰라
	- 1. 메시지를 먼저 결정한다 
	- 2. 메시지에 적합한 객체를 선택한다
	- 3. 책임을 수행하는데 필요한 메서드와 데이터를 객체에 추가한다

>[!note] 엘런 케이
>의도는 **메시징**이다
>훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가 보다는 **모듈이 어떻게 커뮤니케이션하는가**에 달려 있다
- ✅ 객체 사이의 커뮤니케이션 , 메시지에 초점을 맞추는 것이 유지보수 하기 쉬운 객체 설계에 이르는 지름길입니다
- ✅ 클래스가 아니라 객체 사이의 협력에 초점을 맞추는게 객체 지향의 핵심

### 6-6 예제. 중복 할인 정책 추가하기
// 테스트 코드 기반 


### 퀴즈 

**Q. 설계 품질을 평가할 때 가장 중요한 관점은 무엇일까요?**

A. 변경에 대한 적응성 

 이 강의에서는 모든 설계 원칙과 이론이 '변경'이라는 관점에서 연결된다고 강조합니다. 따라서 설계의 핵심은 변경에 얼마나 잘 대처하느냐 일까요?


**Q. 강의에서 강조하는 변경의 관점에서 응집도는 무엇을 의미할까요?**

A. 요소들이 같은 이유로 함께 변경되는 정도

 응집도는 모듈 내 요소들이 얼마나 같은 이유로 함께 변경되는지를 나타냅니다. 높은 응집도는 변경 발생 시 한 곳만 수정하면 되는 상황일까요?


**Q. 변경의 관점에서 낮은 결합도가 의미하는 것은 무엇일까요?**

A. 다른 모듈의 변경이 나에게 미치는 영향이 적다

 결합도는 의존성이 있는 다른 모듈의 변경이 나에게 얼마나 자주 영향을 미치는지를 의미합니다. 낮은 결합도는 변경의 파급 효과가 적다는 뜻일까요?


**Q. 변경의 관점에서 캡슐화가 설계에 주로 어떻게 기여할까요?**

A. 변화하는 내부를 안정적인 인터페이스 뒤에 숨긴다.

 캡슐화는 변화하기 쉬운 부분을 안정적인 추상화(인터페이스) 뒤에 숨기는 기법입니다. 이를 통해 외부에서 내부 변경의 영향을 덜 받게 될까요?


**Q. 객체지향 설계에서 낮은 결합도와 좋은 캡슐화를 달성하는 데 핵심적이라고 반복 강조된 방법은 무엇일까요?**

A. 추상화(인터페이스)에 의존하기

 추상화에 의존함으로써 내부 구현 변경이 외부에 영향을 주지 않도록 할 수 있습니다. 이는 결합도를 낮추고 캡슐화를 강화하는 핵심 방법일까요?

---
